<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>foreverorange</title>
  
  
  <link href="/blog/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2020-06-16T16:46:34.680Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>foreverorange</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>ribbon源码分析</title>
    <link href="http://yoursite.com/2020/06/15/ribbon%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    <id>http://yoursite.com/2020/06/15/ribbon%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/</id>
    <published>2020-06-15T12:55:28.000Z</published>
    <updated>2020-06-16T16:46:34.680Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、-LoadBalanced注解"><a href="#一、-LoadBalanced注解" class="headerlink" title="一、@LoadBalanced注解"></a>一、@LoadBalanced注解</h2><p>唯一加的注解就是<code>@LoadBalanced</code>，如下所示</p><pre><code class="hljs java"><span class="hljs-meta">@Bean</span><span class="hljs-meta">@LoadBalanced</span><span class="hljs-function"><span class="hljs-keyword">public</span> RestTemplate <span class="hljs-title">restTemplate</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> RestTemplate();&#125;</code></pre><p>点进<code>@LoadBalanced</code>注解如下：</p><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * Annotation to mark a RestTemplate or WebClient bean to be configured to use a</span><span class="hljs-comment"> * LoadBalancerClient.</span><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> Spencer Gibb</span><span class="hljs-comment"> */</span><span class="hljs-meta">@Target</span>(&#123; ElementType.FIELD, ElementType.PARAMETER, ElementType.METHOD &#125;)<span class="hljs-meta">@Retention</span>(RetentionPolicy.RUNTIME)<span class="hljs-meta">@Documented</span><span class="hljs-meta">@Inherited</span><span class="hljs-meta">@Qualifier</span><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> LoadBalanced &#123;&#125;</code></pre><ol><li>使用了@Qualifier注解进行限定标识</li><li>类注释意思是，该注解用于标记一个<code>RestTemplate</code>或者<code>WebClient</code>实例，它将会被配置成使用<code>LoadBalancerClient</code></li></ol><blockquote><p>由此可以初步猜测，ribbon最终是通过<code>LoadBalancerClient</code>实现的客户端负载均衡。</p></blockquote><h2 id="二、jar包中META-INF-spring-factories"><a href="#二、jar包中META-INF-spring-factories" class="headerlink" title="二、jar包中META-INF/spring.factories"></a>二、jar包中META-INF/spring.factories</h2><pre><code class="hljs yaml"><span class="hljs-string">org.springframework.boot.autoconfigure.EnableAutoConfiguration=\</span><span class="hljs-string">org.springframework.cloud.netflix.ribbon.RibbonAutoConfiguration</span></code></pre><blockquote><p>声明了RibbonAutoConfiguration的自动配置类</p></blockquote><h3 id="1、ribbon自动配置"><a href="#1、ribbon自动配置" class="headerlink" title="1、ribbon自动配置"></a>1、ribbon自动配置</h3><ul><li>RibbonAutoConfiguration</li></ul><p>点进去如下：</p><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * Auto configuration for Ribbon (client side load balancing).</span><span class="hljs-comment"> *</span><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> Spencer Gibb</span><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> Dave Syer</span><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> Biju Kunjummen</span><span class="hljs-comment"> */</span><span class="hljs-meta">@Configuration</span><span class="hljs-meta">@Conditional</span>(RibbonAutoConfiguration.RibbonClassesConditions<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span><span class="hljs-class">@<span class="hljs-title">RibbonClients</span></span><span class="hljs-class">@<span class="hljs-title">AutoConfigureAfter</span>(</span><span class="hljs-class"><span class="hljs-title">name</span> </span>= <span class="hljs-string">"org.springframework.cloud.netflix.eureka.EurekaClientAutoConfiguration"</span>)<span class="hljs-meta">@AutoConfigureBefore</span>(&#123; LoadBalancerAutoConfiguration<span class="hljs-class">.<span class="hljs-keyword">class</span>,</span><span class="hljs-class"><span class="hljs-title">AsyncLoadBalancerAutoConfiguration</span>.<span class="hljs-title">class</span> &#125;)</span><span class="hljs-class">@<span class="hljs-title">EnableConfigurationProperties</span>(</span>&#123; RibbonEagerLoadProperties<span class="hljs-class">.<span class="hljs-keyword">class</span>,</span><span class="hljs-class"><span class="hljs-title">ServerIntrospectorProperties</span>.<span class="hljs-title">class</span> &#125;)</span><span class="hljs-class"><span class="hljs-title">public</span> <span class="hljs-title">class</span> <span class="hljs-title">RibbonAutoConfiguration</span> </span>&#123;···<span class="hljs-meta">@Bean</span>  <span class="hljs-meta">@ConditionalOnMissingBean</span>(LoadBalancerClient<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span><span class="hljs-class">  <span class="hljs-title">public</span> <span class="hljs-title">LoadBalancerClient</span> <span class="hljs-title">loadBalancerClient</span>() </span>&#123;    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> RibbonLoadBalancerClient(springClientFactory());  &#125;    <span class="hljs-meta">@Bean</span><span class="hljs-meta">@ConditionalOnMissingBean</span><span class="hljs-function"><span class="hljs-keyword">public</span> SpringClientFactory <span class="hljs-title">springClientFactory</span><span class="hljs-params">()</span> </span>&#123;SpringClientFactory factory = <span class="hljs-keyword">new</span> SpringClientFactory();factory.setConfigurations(<span class="hljs-keyword">this</span>.configurations);<span class="hljs-keyword">return</span> factory;&#125;···</code></pre><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SpringClientFactory</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">NamedContextFactory</span>&lt;<span class="hljs-title">RibbonClientSpecification</span>&gt; </span>&#123;<span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String NAMESPACE = <span class="hljs-string">"ribbon"</span>;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">SpringClientFactory</span><span class="hljs-params">()</span> </span>&#123;super(RibbonClientConfiguration.class, NAMESPACE, "ribbon.client.name");&#125;</code></pre><p>可以看出，它声明了<code>LoadBalancerClient</code>的实例为<code>RibbonLoadBalancerClient</code>，在生成<code>RibbonLoadBalancerClient</code>时传入了<code>springClientFactory()</code>，其内部引入了<code>RibbonClientConfiguration.class</code></p><h3 id="2、ribbonClient实例配置"><a href="#2、ribbonClient实例配置" class="headerlink" title="2、ribbonClient实例配置"></a>2、ribbonClient实例配置</h3><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * Ribbon client default connect timeout.</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> DEFAULT_CONNECT_TIMEOUT = <span class="hljs-number">1000</span>;<span class="hljs-comment">/**</span><span class="hljs-comment"> * Ribbon client default read timeout.</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> DEFAULT_READ_TIMEOUT = <span class="hljs-number">1000</span>;<span class="hljs-comment">/**</span><span class="hljs-comment"> * Ribbon client default Gzip Payload flag.</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> DEFAULT_GZIP_PAYLOAD = <span class="hljs-keyword">true</span>;<span class="hljs-meta">@RibbonClientName</span><span class="hljs-keyword">private</span> String name = <span class="hljs-string">"client"</span>;<span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> maybe re-instate autowired load balancers: identified by name they could be</span><span class="hljs-comment">// associated with ribbon clients</span><span class="hljs-meta">@Autowired</span><span class="hljs-keyword">private</span> PropertiesFactory propertiesFactory;<span class="hljs-comment">// 定义ribbonClientConfig的配置类</span><span class="hljs-meta">@Bean</span><span class="hljs-meta">@ConditionalOnMissingBean</span><span class="hljs-function"><span class="hljs-keyword">public</span> IClientConfig <span class="hljs-title">ribbonClientConfig</span><span class="hljs-params">()</span> </span>&#123;DefaultClientConfigImpl config = <span class="hljs-keyword">new</span> DefaultClientConfigImpl();config.loadProperties(<span class="hljs-keyword">this</span>.name);config.set(CommonClientConfigKey.ConnectTimeout, DEFAULT_CONNECT_TIMEOUT);config.set(CommonClientConfigKey.ReadTimeout, DEFAULT_READ_TIMEOUT);config.set(CommonClientConfigKey.GZipPayload, DEFAULT_GZIP_PAYLOAD);<span class="hljs-keyword">return</span> config;&#125;<span class="hljs-comment">// 定义默认的负载均衡策略</span><span class="hljs-meta">@Bean</span><span class="hljs-meta">@ConditionalOnMissingBean</span><span class="hljs-function"><span class="hljs-keyword">public</span> IRule <span class="hljs-title">ribbonRule</span><span class="hljs-params">(IClientConfig config)</span> </span>&#123;<span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.propertiesFactory.isSet(IRule<span class="hljs-class">.<span class="hljs-keyword">class</span>, <span class="hljs-title">name</span>)) </span>&#123;<span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.propertiesFactory.get(IRule<span class="hljs-class">.<span class="hljs-keyword">class</span>, <span class="hljs-title">config</span>, <span class="hljs-title">name</span>)</span>;&#125;ZoneAvoidanceRule rule = <span class="hljs-keyword">new</span> ZoneAvoidanceRule();rule.initWithNiwsConfig(config);<span class="hljs-keyword">return</span> rule;&#125;<span class="hljs-comment">// 定义默认的ping规则</span><span class="hljs-meta">@Bean</span><span class="hljs-meta">@ConditionalOnMissingBean</span><span class="hljs-function"><span class="hljs-keyword">public</span> IPing <span class="hljs-title">ribbonPing</span><span class="hljs-params">(IClientConfig config)</span> </span>&#123;<span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.propertiesFactory.isSet(IPing<span class="hljs-class">.<span class="hljs-keyword">class</span>, <span class="hljs-title">name</span>)) </span>&#123;<span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.propertiesFactory.get(IPing<span class="hljs-class">.<span class="hljs-keyword">class</span>, <span class="hljs-title">config</span>, <span class="hljs-title">name</span>)</span>;&#125;<span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> DummyPing();&#125;<span class="hljs-comment">// 定义服务列表</span><span class="hljs-meta">@Bean</span><span class="hljs-meta">@ConditionalOnMissingBean</span><span class="hljs-meta">@SuppressWarnings</span>(<span class="hljs-string">"unchecked"</span>)<span class="hljs-function"><span class="hljs-keyword">public</span> ServerList&lt;Server&gt; <span class="hljs-title">ribbonServerList</span><span class="hljs-params">(IClientConfig config)</span> </span>&#123;<span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.propertiesFactory.isSet(ServerList<span class="hljs-class">.<span class="hljs-keyword">class</span>, <span class="hljs-title">name</span>)) </span>&#123;<span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.propertiesFactory.get(ServerList<span class="hljs-class">.<span class="hljs-keyword">class</span>, <span class="hljs-title">config</span>, <span class="hljs-title">name</span>)</span>;&#125;ConfigurationBasedServerList serverList = <span class="hljs-keyword">new</span> ConfigurationBasedServerList();serverList.initWithNiwsConfig(config);<span class="hljs-keyword">return</span> serverList;&#125;  <span class="hljs-comment">// 定义服务列表更新器</span><span class="hljs-meta">@Bean</span><span class="hljs-meta">@ConditionalOnMissingBean</span><span class="hljs-function"><span class="hljs-keyword">public</span> ServerListUpdater <span class="hljs-title">ribbonServerListUpdater</span><span class="hljs-params">(IClientConfig config)</span> </span>&#123;<span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> PollingServerListUpdater(config);&#125;<span class="hljs-comment">// 定义负载均衡器，传入默认的rule和ping，生成ZoneAwareLoadBalancer默认负载均衡器</span><span class="hljs-meta">@Bean</span><span class="hljs-meta">@ConditionalOnMissingBean</span><span class="hljs-function"><span class="hljs-keyword">public</span> ILoadBalancer <span class="hljs-title">ribbonLoadBalancer</span><span class="hljs-params">(IClientConfig config,</span></span><span class="hljs-function"><span class="hljs-params">ServerList&lt;Server&gt; serverList, ServerListFilter&lt;Server&gt; serverListFilter,</span></span><span class="hljs-function"><span class="hljs-params">IRule rule, IPing ping, ServerListUpdater serverListUpdater)</span> </span>&#123;<span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.propertiesFactory.isSet(ILoadBalancer<span class="hljs-class">.<span class="hljs-keyword">class</span>, <span class="hljs-title">name</span>)) </span>&#123;<span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.propertiesFactory.get(ILoadBalancer<span class="hljs-class">.<span class="hljs-keyword">class</span>, <span class="hljs-title">config</span>, <span class="hljs-title">name</span>)</span>;&#125;<span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ZoneAwareLoadBalancer&lt;&gt;(config, rule, ping, serverList,serverListFilter, serverListUpdater);&#125;</code></pre><h3 id="3、负载均衡器自动配置"><a href="#3、负载均衡器自动配置" class="headerlink" title="3、负载均衡器自动配置"></a>3、负载均衡器自动配置</h3><ul><li>LoadBalancerAutoConfiguration</li></ul><p>而在类的上方，使用了<code>@AutoConfigureBefore({ LoadBalancerAutoConfiguration.class</code>，点进去如下：</p><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * Auto-configuration for Ribbon (client-side load balancing).</span><span class="hljs-comment"> *</span><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> Spencer Gibb</span><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> Dave Syer</span><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> Will Tran</span><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> Gang Li</span><span class="hljs-comment"> */</span><span class="hljs-meta">@Configuration</span>(proxyBeanMethods = <span class="hljs-keyword">false</span>)<span class="hljs-meta">@ConditionalOnClass</span>(RestTemplate<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span><span class="hljs-class">@<span class="hljs-title">ConditionalOnBean</span>(<span class="hljs-title">LoadBalancerClient</span>.<span class="hljs-title">class</span>)</span><span class="hljs-class">@<span class="hljs-title">EnableConfigurationProperties</span>(<span class="hljs-title">LoadBalancerRetryProperties</span>.<span class="hljs-title">class</span>)</span><span class="hljs-class"><span class="hljs-title">public</span> <span class="hljs-title">class</span> <span class="hljs-title">LoadBalancerAutoConfiguration</span> </span>&#123;<span class="hljs-comment">// 这里使用了@LoadBalanced注解进行限定，即只有被该注解标注的restTemplates才会被注入到list中</span><span class="hljs-meta">@LoadBalanced</span><span class="hljs-meta">@Autowired</span>(required = <span class="hljs-keyword">false</span>)<span class="hljs-keyword">private</span> List&lt;RestTemplate&gt; restTemplates = Collections.emptyList();<span class="hljs-meta">@Autowired</span>(required = <span class="hljs-keyword">false</span>)<span class="hljs-keyword">private</span> List&lt;LoadBalancerRequestTransformer&gt; transformers = Collections.emptyList();<span class="hljs-meta">@Bean</span><span class="hljs-function"><span class="hljs-keyword">public</span> SmartInitializingSingleton <span class="hljs-title">loadBalancedRestTemplateInitializerDeprecated</span><span class="hljs-params">(</span></span><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">final</span> ObjectProvider&lt;List&lt;RestTemplateCustomizer&gt;&gt; restTemplateCustomizers)</span> </span>&#123;<span class="hljs-comment">// 这里返回了一个SmartInitializingSingleton实例</span>    <span class="hljs-keyword">return</span> () -&gt; restTemplateCustomizers.ifAvailable(customizers -&gt; &#123;      <span class="hljs-comment">// 循环限定注入的List&lt;RestTemplate&gt;，使用RestTemplateCustomizer进行定制</span><span class="hljs-keyword">for</span> (RestTemplate restTemplate : LoadBalancerAutoConfiguration.<span class="hljs-keyword">this</span>.restTemplates) &#123;<span class="hljs-keyword">for</span> (RestTemplateCustomizer customizer : customizers) &#123;customizer.customize(restTemplate);&#125;&#125;&#125;);&#125;···    <span class="hljs-meta">@Bean</span><span class="hljs-meta">@ConditionalOnMissingBean</span><span class="hljs-function"><span class="hljs-keyword">public</span> LoadBalancerRequestFactory <span class="hljs-title">loadBalancerRequestFactory</span><span class="hljs-params">(</span></span><span class="hljs-function"><span class="hljs-params">LoadBalancerClient loadBalancerClient)</span> </span>&#123;<span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> LoadBalancerRequestFactory(loadBalancerClient, <span class="hljs-keyword">this</span>.transformers);&#125;  <span class="hljs-meta">@Configuration</span>(proxyBeanMethods = <span class="hljs-keyword">false</span>)<span class="hljs-meta">@ConditionalOnMissingClass</span>(<span class="hljs-string">"org.springframework.retry.support.RetryTemplate"</span>)<span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LoadBalancerInterceptorConfig</span> </span>&#123;<span class="hljs-meta">@Bean</span>    <span class="hljs-comment">// 声明拦截器实例</span><span class="hljs-function"><span class="hljs-keyword">public</span> LoadBalancerInterceptor <span class="hljs-title">ribbonInterceptor</span><span class="hljs-params">(</span></span><span class="hljs-function"><span class="hljs-params">LoadBalancerClient loadBalancerClient,</span></span><span class="hljs-function"><span class="hljs-params">LoadBalancerRequestFactory requestFactory)</span> </span>&#123;<span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> LoadBalancerInterceptor(loadBalancerClient, requestFactory);&#125;<span class="hljs-meta">@Bean</span><span class="hljs-meta">@ConditionalOnMissingBean</span>    <span class="hljs-comment">// 声明在SmartInitializingSingleton中用于定制的处理实例</span><span class="hljs-function"><span class="hljs-keyword">public</span> RestTemplateCustomizer <span class="hljs-title">restTemplateCustomizer</span><span class="hljs-params">(</span></span><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">final</span> LoadBalancerInterceptor loadBalancerInterceptor)</span> </span>&#123;      为restTemplate增加一个额外的拦截器loadBalancerInterceptor<span class="hljs-keyword">return</span> restTemplate -&gt; &#123;List&lt;ClientHttpRequestInterceptor&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;(restTemplate.getInterceptors());list.add(loadBalancerInterceptor);restTemplate.setInterceptors(list);&#125;;&#125;···    <span class="hljs-comment">/**</span><span class="hljs-comment"> * Auto configuration for retry mechanism.</span><span class="hljs-comment"> */</span><span class="hljs-meta">@Configuration</span>(proxyBeanMethods = <span class="hljs-keyword">false</span>)<span class="hljs-meta">@ConditionalOnClass</span>(RetryTemplate<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span><span class="hljs-class"><span class="hljs-title">public</span> <span class="hljs-title">static</span> <span class="hljs-title">class</span> <span class="hljs-title">RetryAutoConfiguration</span> </span>&#123;<span class="hljs-meta">@Bean</span><span class="hljs-meta">@ConditionalOnMissingBean</span><span class="hljs-function"><span class="hljs-keyword">public</span> LoadBalancedRetryFactory <span class="hljs-title">loadBalancedRetryFactory</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> LoadBalancedRetryFactory() &#123;&#125;;&#125;&#125;    ···&#125;</code></pre><p>可以看出，在<code>LoadBalancerAutoConfiguration</code>中，维护了一个<code>List&lt;RestTemplate&gt;</code>，并注入被<code>LoadBalanced</code>修饰的<code>RestTemplate</code>实例。之后对限定的<code>RestTemplate</code>实例增加一个<code>LoadBalancerInterceptor</code>拦截器。另外可以看出，重试机制使用的<code>RetryTemplate.class</code>，重试的时候也会走配置好的负载均衡拦截器。</p><h4 id="PS：-Qualifier注解解读"><a href="#PS：-Qualifier注解解读" class="headerlink" title="PS：@Qualifier注解解读"></a>PS：@Qualifier注解解读</h4><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * This annotation may be used on a field or parameter as a qualifier for</span><span class="hljs-comment"> * candidate beans when autowiring. It may also be used to annotate other</span><span class="hljs-comment"> * custom annotations that can then in turn be used as qualifiers.</span><span class="hljs-comment"> * 1、该注解可以声明在一个字段或者参数上，用于表示在自动注入时，仅限定的候选实例才会被注入，</span><span class="hljs-comment"> * 例如同一个接口多个实现时，可以用它限定注入哪一个实例。</span><span class="hljs-comment"> * 2、该注解也可以使用在一个自定义注解上，那么该自定义注解可以被当做限定词使用，</span><span class="hljs-comment"> * 可以理解为是<span class="hljs-doctag">@Qualifier</span>("<span class="hljs-doctag">@xx</span>")这种限定</span><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> Mark Fisher</span><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> Juergen Hoeller</span><span class="hljs-comment"> * <span class="hljs-doctag">@since</span> 2.5</span><span class="hljs-comment"> * <span class="hljs-doctag">@see</span> Autowired</span><span class="hljs-comment"> */</span><span class="hljs-meta">@Target</span>(&#123;ElementType.FIELD, ElementType.METHOD, ElementType.PARAMETER, ElementType.TYPE, ElementType.ANNOTATION_TYPE&#125;)<span class="hljs-meta">@Retention</span>(RetentionPolicy.RUNTIME)<span class="hljs-meta">@Inherited</span><span class="hljs-meta">@Documented</span><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> Qualifier &#123;   <span class="hljs-function">String <span class="hljs-title">value</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> ""</span>;&#125;</code></pre><h3 id="4、负载均衡拦截器"><a href="#4、负载均衡拦截器" class="headerlink" title="4、负载均衡拦截器"></a>4、负载均衡拦截器</h3><ul><li>LoadBalancerInterceptor</li></ul><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LoadBalancerInterceptor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">ClientHttpRequestInterceptor</span> </span>&#123;<span class="hljs-keyword">private</span> LoadBalancerClient loadBalancer;<span class="hljs-keyword">private</span> LoadBalancerRequestFactory requestFactory;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">LoadBalancerInterceptor</span><span class="hljs-params">(LoadBalancerClient loadBalancer,</span></span><span class="hljs-function"><span class="hljs-params">LoadBalancerRequestFactory requestFactory)</span> </span>&#123;<span class="hljs-keyword">this</span>.loadBalancer = loadBalancer;<span class="hljs-keyword">this</span>.requestFactory = requestFactory;&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">LoadBalancerInterceptor</span><span class="hljs-params">(LoadBalancerClient loadBalancer)</span> </span>&#123;<span class="hljs-comment">// for backwards compatibility</span><span class="hljs-keyword">this</span>(loadBalancer, <span class="hljs-keyword">new</span> LoadBalancerRequestFactory(loadBalancer));&#125;<span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">public</span> ClientHttpResponse <span class="hljs-title">intercept</span><span class="hljs-params">(<span class="hljs-keyword">final</span> HttpRequest request, <span class="hljs-keyword">final</span> <span class="hljs-keyword">byte</span>[] body,</span></span><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">final</span> ClientHttpRequestExecution execution)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<span class="hljs-keyword">final</span> URI originalUri = request.getURI();    <span class="hljs-comment">// 这里得到的就是我们在resttemplate中填写的服务名</span>String serviceName = originalUri.getHost();Assert.state(serviceName != <span class="hljs-keyword">null</span>,<span class="hljs-string">"Request URI does not contain a valid hostname: "</span> + originalUri);    <span class="hljs-comment">// 这里可以看出，拦截器内部使用LoadBalancerClient实例进行实际调用</span><span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.loadBalancer.execute(serviceName,<span class="hljs-keyword">this</span>.requestFactory.createRequest(request, body, execution));&#125;&#125;</code></pre><p>跟踪到这里才发现，通过注解对<code>RestTemplate</code>进行拦截，使用<code>LoadBalancerClient</code>做实际调用处理。</p><p><code>LoadBalancerClient</code>就是之前声明的<code>RibbonLoadBalancerClient</code>，其具体处理如下：</p><pre><code class="hljs java"><span class="hljs-meta">@Override</span><span class="hljs-keyword">public</span> &lt;T&gt; <span class="hljs-function">T <span class="hljs-title">execute</span><span class="hljs-params">(String serviceId, LoadBalancerRequest&lt;T&gt; request)</span></span><span class="hljs-function"><span class="hljs-keyword">throws</span> IOException </span>&#123;<span class="hljs-keyword">return</span> execute(serviceId, request, <span class="hljs-keyword">null</span>);&#125;<span class="hljs-comment">/**  使用key选择一个server来执行请求</span><span class="hljs-comment"> * New: Execute a request by selecting server using a 'key'. The hint will have to be</span><span class="hljs-comment"> * the last parameter to not mess with the `execute(serviceId, ServiceInstance,</span><span class="hljs-comment"> * request)` method. This somewhat breaks the fluent coding style when using a lambda</span><span class="hljs-comment"> * to define the LoadBalancerRequest.</span><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &lt;T&gt; returned request execution result type</span><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> serviceId id of the service to execute the request to</span><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> request to be executed</span><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> hint used to choose appropriate &#123;<span class="hljs-doctag">@link</span> Server&#125; instance</span><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> request execution result</span><span class="hljs-comment"> * <span class="hljs-doctag">@throws</span> IOException executing the request may result in an &#123;<span class="hljs-doctag">@link</span> IOException&#125;</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> &lt;T&gt; <span class="hljs-function">T <span class="hljs-title">execute</span><span class="hljs-params">(String serviceId, LoadBalancerRequest&lt;T&gt; request, Object hint)</span></span><span class="hljs-function"><span class="hljs-keyword">throws</span> IOException </span>&#123;    <span class="hljs-comment">// 根据服务名获取一个ILoadBalancer负载均衡器处理实例</span>ILoadBalancer loadBalancer = getLoadBalancer(serviceId);Server server = getServer(loadBalancer, hint);<span class="hljs-keyword">if</span> (server == <span class="hljs-keyword">null</span>) &#123;<span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalStateException(<span class="hljs-string">"No instances available for "</span> + serviceId);&#125;RibbonServer ribbonServer = <span class="hljs-keyword">new</span> RibbonServer(serviceId, server,isSecure(server, serviceId),serverIntrospector(serviceId).getMetadata(server));<span class="hljs-keyword">return</span> execute(serviceId, ribbonServer, request);&#125;</code></pre><p>当一个被<code>@LoadBalanced</code>修饰的<code>RestTemplate</code>实例向外发送请求时，会被<code>LoadBalancerInterceptor</code>类的intercept函数拦截。之后通过<code>originalUri.getHost()</code>拿到具体的服务名，然后调用execute方法，根据服务名选择实例发起实际的请求。</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">protected</span> Server <span class="hljs-title">getServer</span><span class="hljs-params">(ILoadBalancer loadBalancer, Object hint)</span> </span>&#123;<span class="hljs-keyword">if</span> (loadBalancer == <span class="hljs-keyword">null</span>) &#123;<span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;&#125;<span class="hljs-comment">// Use 'default' on a null hint, or just pass it on?</span><span class="hljs-keyword">return</span> loadBalancer.chooseServer(hint != <span class="hljs-keyword">null</span> ? hint : <span class="hljs-string">"default"</span>);&#125;</code></pre><p>getServer方法使用ILoadBalancer获取了具体的服务。由第二小节ribbonClient实例配置中，我们知道，默认的loadBalancer是<code>ZoneAwareLoadBalancer</code>，通过<code>ZoneAwareLoadBalancer</code>的chooseServer方法获取到负载均衡策略分配到的服务实例server，将其包装成RibbonServer，继续执行execute方法：</p><pre><code class="hljs java"><span class="hljs-meta">@Override</span><span class="hljs-keyword">public</span> &lt;T&gt; <span class="hljs-function">T <span class="hljs-title">execute</span><span class="hljs-params">(String serviceId, ServiceInstance serviceInstance,</span></span><span class="hljs-function"><span class="hljs-params">LoadBalancerRequest&lt;T&gt; request)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;Server server = <span class="hljs-keyword">null</span>;<span class="hljs-keyword">if</span> (serviceInstance <span class="hljs-keyword">instanceof</span> RibbonServer) &#123;server = ((RibbonServer) serviceInstance).getServer();&#125;<span class="hljs-keyword">if</span> (server == <span class="hljs-keyword">null</span>) &#123;<span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalStateException(<span class="hljs-string">"No instances available for "</span> + serviceId);&#125;RibbonLoadBalancerContext context = <span class="hljs-keyword">this</span>.clientFactory.getLoadBalancerContext(serviceId);    <span class="hljs-comment">// 这里还使用了RibbonStatsRecorder来跟踪服务请求记录</span>RibbonStatsRecorder statsRecorder = <span class="hljs-keyword">new</span> RibbonStatsRecorder(context, server);<span class="hljs-keyword">try</span> &#123;      <span class="hljs-comment">// 回调LoadBalancerInterceptor中的LoadBalancerRequest的apply函数，向一个实际的服务发起请求</span>T returnVal = request.apply(serviceInstance);statsRecorder.recordStats(returnVal);<span class="hljs-keyword">return</span> returnVal;&#125;<span class="hljs-comment">// catch IOException and rethrow so RestTemplate behaves correctly</span><span class="hljs-keyword">catch</span> (IOException ex) &#123;statsRecorder.recordStats(ex);<span class="hljs-keyword">throw</span> ex;&#125;<span class="hljs-keyword">catch</span> (Exception ex) &#123;statsRecorder.recordStats(ex);ReflectionUtils.rethrowRuntimeException(ex);&#125;<span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;&#125;</code></pre><blockquote><p>回调LoadBalancerInterceptor中的LoadBalancerRequest的apply函数，向一个实际的服务发起请求。从而实现了一开始以服务名作为host的URI到host:port形式的实际请求地址的转换。</p></blockquote><p>request.apply(serviceInstance)的具体实现如下</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> LoadBalancerRequest&lt;ClientHttpResponse&gt; <span class="hljs-title">createRequest</span><span class="hljs-params">(</span></span><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">final</span> HttpRequest request, <span class="hljs-keyword">final</span> <span class="hljs-keyword">byte</span>[] body,</span></span><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">final</span> ClientHttpRequestExecution execution)</span> </span>&#123;<span class="hljs-keyword">return</span> instance -&gt; &#123;      <span class="hljs-comment">// 接收传入的serviceInstance，将其包装成HttpRequest</span>HttpRequest serviceRequest = <span class="hljs-keyword">new</span> ServiceRequestWrapper(request, instance,<span class="hljs-keyword">this</span>.loadBalancer);<span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.transformers != <span class="hljs-keyword">null</span>) &#123;<span class="hljs-keyword">for</span> (LoadBalancerRequestTransformer transformer : <span class="hljs-keyword">this</span>.transformers) &#123;serviceRequest = transformer.transformRequest(serviceRequest,instance);&#125;&#125;      <span class="hljs-comment">// 调用ClientHttpRequestExecution并传入serviceRequest</span><span class="hljs-keyword">return</span> execution.execute(serviceRequest, body);&#125;;&#125;</code></pre><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">InterceptingClientHttpRequest</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractBufferingClientHttpRequest</span> </span>&#123;  ···<span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">public</span> ClientHttpResponse <span class="hljs-title">execute</span><span class="hljs-params">(HttpRequest request, <span class="hljs-keyword">byte</span>[] body)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.iterator.hasNext()) &#123;ClientHttpRequestInterceptor nextInterceptor = <span class="hljs-keyword">this</span>.iterator.next();<span class="hljs-keyword">return</span> nextInterceptor.intercept(request, body, <span class="hljs-keyword">this</span>);&#125;<span class="hljs-keyword">else</span> &#123;HttpMethod method = request.getMethod();Assert.state(method != <span class="hljs-keyword">null</span>, <span class="hljs-string">"No standard HTTP method"</span>);        <span class="hljs-comment">// 这里真正创建请求，传入request.getURI()，即调用了上一步包装的HttpRequest.getURI()</span>ClientHttpRequest delegate = requestFactory.createRequest(request.getURI(), method);request.getHeaders().forEach((key, value) -&gt; delegate.getHeaders().addAll(key, value));<span class="hljs-keyword">if</span> (body.length &gt; <span class="hljs-number">0</span>) &#123;<span class="hljs-keyword">if</span> (delegate <span class="hljs-keyword">instanceof</span> StreamingHttpOutputMessage) &#123;StreamingHttpOutputMessage streamingOutputMessage = (StreamingHttpOutputMessage) delegate;streamingOutputMessage.setBody(outputStream -&gt; StreamUtils.copy(body, outputStream));&#125;<span class="hljs-keyword">else</span> &#123;StreamUtils.copy(body, delegate.getBody());&#125;&#125;<span class="hljs-keyword">return</span> delegate.execute();&#125;&#125;&#125;</code></pre><p>包装类HttpRequest.getURI()方法如下：</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ServiceRequestWrapper</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">HttpRequestWrapper</span> </span>&#123;<span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> ServiceInstance instance;<span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> LoadBalancerClient loadBalancer;<span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">public</span> URI <span class="hljs-title">getURI</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-comment">// 这里获取URI时，调用了loadBalancer.reconstructURI方法</span>URI uri = <span class="hljs-keyword">this</span>.loadBalancer.reconstructURI(<span class="hljs-keyword">this</span>.instance, getRequest().getURI());<span class="hljs-keyword">return</span> uri;&#125;</code></pre><p>reconstructURI如下：</p><pre><code class="hljs java"><span class="hljs-keyword">private</span> SpringClientFactory clientFactory;<span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">public</span> URI <span class="hljs-title">reconstructURI</span><span class="hljs-params">(ServiceInstance instance, URI original)</span> </span>&#123;Assert.notNull(instance, <span class="hljs-string">"instance can not be null"</span>);    <span class="hljs-comment">// 获取服务id</span>String serviceId = instance.getServiceId();    <span class="hljs-comment">// 从SpringClientFactory中获取对应服务的负载均衡器的上下文对象</span>RibbonLoadBalancerContext context = <span class="hljs-keyword">this</span>.clientFactory.getLoadBalancerContext(serviceId);URI uri;Server server;<span class="hljs-keyword">if</span> (instance <span class="hljs-keyword">instanceof</span> RibbonServer) &#123;      <span class="hljs-comment">// 根据ServiceInstance构建具体服务实例信息的Server对象</span>RibbonServer ribbonServer = (RibbonServer) instance;      <span class="hljs-comment">// 将springCloud定义的ServiceInstance转成netflix中需要的Server对象</span>server = ribbonServer.getServer();uri = updateToSecureConnectionIfNeeded(original, ribbonServer);&#125;<span class="hljs-keyword">else</span> &#123;server = <span class="hljs-keyword">new</span> Server(instance.getScheme(), instance.getHost(),instance.getPort());IClientConfig clientConfig = clientFactory.getClientConfig(serviceId);ServerIntrospector serverIntrospector = serverIntrospector(serviceId);uri = updateToSecureConnectionIfNeeded(original, clientConfig,serverIntrospector, server);&#125;    <span class="hljs-comment">// 使用上下文对象来构建服务实例的URL</span><span class="hljs-keyword">return</span> context.reconstructURIWithServer(server, uri);&#125;</code></pre><blockquote><p>SpringClientFactory是一个用来创建客户端负载均衡器的工厂类，它为每一个不同名的ribbon客户端生成不同的Spring上下文。</p></blockquote><blockquote><p>RibbonLoadBalancerContext时LoadBalancerContext的子类，用于存储负载均衡器本身的一些上下文内容和常用API操作，如reconstructURIWithServer。</p></blockquote><p>reconstructURIWithServer如下：</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> URI <span class="hljs-title">reconstructURIWithServer</span><span class="hljs-params">(Server server, URI original)</span> </span>&#123;  <span class="hljs-comment">// 从server中获取host和port信息，然后和original中的其他信息进行拼接整合，形成最终要访问的服务实例的具体地址</span>        String host = server.getHost();        <span class="hljs-keyword">int</span> port = server.getPort();        String scheme = server.getScheme();                <span class="hljs-keyword">if</span> (host.equals(original.getHost())                 &amp;&amp; port == original.getPort()                &amp;&amp; scheme == original.getScheme()) &#123;            <span class="hljs-keyword">return</span> original;        &#125;        <span class="hljs-keyword">if</span> (scheme == <span class="hljs-keyword">null</span>) &#123;            scheme = original.getScheme();        &#125;        <span class="hljs-keyword">if</span> (scheme == <span class="hljs-keyword">null</span>) &#123;            scheme = deriveSchemeAndPortFromPartialUri(original).first();        &#125;        <span class="hljs-keyword">try</span> &#123;            StringBuilder sb = <span class="hljs-keyword">new</span> StringBuilder();            sb.append(scheme).append(<span class="hljs-string">"://"</span>);            <span class="hljs-keyword">if</span> (!Strings.isNullOrEmpty(original.getRawUserInfo())) &#123;                sb.append(original.getRawUserInfo()).append(<span class="hljs-string">"@"</span>);            &#125;            sb.append(host);            <span class="hljs-keyword">if</span> (port &gt;= <span class="hljs-number">0</span>) &#123;                sb.append(<span class="hljs-string">":"</span>).append(port);            &#125;            sb.append(original.getRawPath());            <span class="hljs-keyword">if</span> (!Strings.isNullOrEmpty(original.getRawQuery())) &#123;                sb.append(<span class="hljs-string">"?"</span>).append(original.getRawQuery());            &#125;            <span class="hljs-keyword">if</span> (!Strings.isNullOrEmpty(original.getRawFragment())) &#123;                sb.append(<span class="hljs-string">"#"</span>).append(original.getRawFragment());            &#125;            URI newURI = <span class="hljs-keyword">new</span> URI(sb.toString());            <span class="hljs-keyword">return</span> newURI;                    &#125; <span class="hljs-keyword">catch</span> (URISyntaxException e) &#123;            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(e);        &#125;    &#125;</code></pre><h3 id="5、负载均衡器接口"><a href="#5、负载均衡器接口" class="headerlink" title="5、负载均衡器接口"></a>5、负载均衡器接口</h3><ul><li><p>ILoadBalancer</p><p>ILoadBalancer 中定义了负载均衡器的操作的接口：</p></li></ul><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * Interface that defines the operations for a software loadbalancer. </span><span class="hljs-comment"> * A typical loadbalancer minimally need a set of servers to loadbalance for, a method to</span><span class="hljs-comment"> * mark a particular server to be out of rotation and a call that will choose a</span><span class="hljs-comment"> * server from the existing list of server.</span><span class="hljs-comment"> * 一个接口，用于定义软件负载均衡的操作。</span><span class="hljs-comment"> * 一个典型的负载均衡器最少需要一组实例进行负载均衡。</span><span class="hljs-comment"> * 一个方法去标记特定的服务不可用</span><span class="hljs-comment"> * 一个调用，从现有的服务列表中选择一个服务</span><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> stonse</span><span class="hljs-comment"> * </span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">ILoadBalancer</span> </span>&#123;<span class="hljs-comment">/**</span><span class="hljs-comment"> * Initial list of servers.</span><span class="hljs-comment"> * This API also serves to add additional ones at a later time</span><span class="hljs-comment"> * The same logical server (host:port) could essentially be added multiple times</span><span class="hljs-comment"> * (helpful in cases where you want to give more "weightage" perhaps ..)</span><span class="hljs-comment"> * 初始化服务列表。</span><span class="hljs-comment"> * 也可以用于追加服务到列表中。</span><span class="hljs-comment"> * 同一逻辑服务(host:port) 本质上可以多次添加。</span><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> newServers new servers to add</span><span class="hljs-comment"> */</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addServers</span><span class="hljs-params">(List&lt;Server&gt; newServers)</span></span>;<span class="hljs-comment">/**</span><span class="hljs-comment"> * Choose a server from load balancer.</span><span class="hljs-comment"> * 根据key从负载均衡器中选择一个服务</span><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> key An object that the load balancer may use to determine which server to return. null if </span><span class="hljs-comment"> *         the load balancer does not use this parameter.</span><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> server chosen</span><span class="hljs-comment"> */</span><span class="hljs-function"><span class="hljs-keyword">public</span> Server <span class="hljs-title">chooseServer</span><span class="hljs-params">(Object key)</span></span>;<span class="hljs-comment">/**</span><span class="hljs-comment"> * To be called by the clients of the load balancer to notify that a Server is down</span><span class="hljs-comment"> * else, the LB will think its still Alive until the next Ping cycle - potentially</span><span class="hljs-comment"> * (assuming that the LB Impl does a ping)</span><span class="hljs-comment"> * 由负载均衡器的客户端去调用，通知服务已关闭。否则LB将认为它仍然有效，直到下一个ping周期</span><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> server Server to mark as down</span><span class="hljs-comment"> */</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">markServerDown</span><span class="hljs-params">(Server server)</span></span>;<span class="hljs-comment">/**返回所有可用的服务列表</span><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> Only the servers that are up and reachable.</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;Server&gt; <span class="hljs-title">getReachableServers</span><span class="hljs-params">()</span></span>;    <span class="hljs-comment">/**返回所有的服务列表（包含可用、不可用的）</span><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> All known servers, both reachable and unreachable.</span><span class="hljs-comment">     */</span><span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;Server&gt; <span class="hljs-title">getAllServers</span><span class="hljs-params">()</span></span>;&#125;</code></pre><blockquote><p>Server对象包含了服务端节点的元数据信息，如host、port、以及一些部署信息。</p></blockquote><p>ILoadBalancer的实现类，完整的类图如下：</p><p><img src="/blog/2020/06/15/ribbon%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/ILoadBalancerDiagram.png" srcset="/blog/img/loading.gif" alt="ILoadBalancerDiagram"></p><p>从上面的类图可以看到，ILoadBalancer 有三个实现类，BaseLoadBalancer实现了基础的负载均衡，DynamicServerListLoadBalancer和ZoneAwareLoadBalancer则在策略上做了一些功能的扩展。他们之间是继承关系，最终的实现类是 ZoneAwareLoadBalancer。</p><p>很多东西都是定义在BaseLoadBalancer中的，先从 BaseLoadBalancer 中的 变量看：</p><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * A basic implementation of the load balancer where an arbitrary list of</span><span class="hljs-comment"> * servers can be set as the server pool. A ping can be set to determine the</span><span class="hljs-comment"> * liveness of a server. Internally, this class maintains an "all" server list</span><span class="hljs-comment"> * and an "up" server list and use them depending on what the caller asks for.</span><span class="hljs-comment"> * 一个基础的负载均衡器的实现类</span><span class="hljs-comment"> * 默认的ping策略去查明存活的服务</span><span class="hljs-comment"> * 维护一个所有服务的list和存活服务的list</span><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> stonse</span><span class="hljs-comment"> * </span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BaseLoadBalancer</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractLoadBalancer</span> <span class="hljs-keyword">implements</span></span><span class="hljs-class">        <span class="hljs-title">PrimeConnections</span>.<span class="hljs-title">PrimeConnectionListener</span>, <span class="hljs-title">IClientConfigAware</span> </span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Logger logger = LoggerFactory            .getLogger(BaseLoadBalancer<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;  <span class="hljs-comment">// 默认的线性轮询负载均衡策略</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">static</span> IRule DEFAULT_RULE = <span class="hljs-keyword">new</span> RoundRobinRule();  <span class="hljs-comment">// 串行ping策略</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">static</span> SerialPingStrategy DEFAULT_PING_STRATEGY = <span class="hljs-keyword">new</span> SerialPingStrategy();    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String DEFAULT_NAME = <span class="hljs-string">"default"</span>;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String PREFIX = <span class="hljs-string">"LoadBalancer_"</span>;    <span class="hljs-keyword">protected</span> IRule rule = DEFAULT_RULE;    <span class="hljs-keyword">protected</span> IPingStrategy pingStrategy = DEFAULT_PING_STRATEGY;    <span class="hljs-keyword">protected</span> IPing ping = <span class="hljs-keyword">null</span>;<span class="hljs-comment">// 所有服务列表</span>    <span class="hljs-meta">@Monitor</span>(name = PREFIX + <span class="hljs-string">"AllServerList"</span>, type = DataSourceType.INFORMATIONAL)    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">volatile</span> List&lt;Server&gt; allServerList = Collections            .synchronizedList(<span class="hljs-keyword">new</span> ArrayList&lt;Server&gt;());    <span class="hljs-comment">// 存续服务列表</span>  <span class="hljs-meta">@Monitor</span>(name = PREFIX + <span class="hljs-string">"UpServerList"</span>, type = DataSourceType.INFORMATIONAL)    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">volatile</span> List&lt;Server&gt; upServerList = Collections            .synchronizedList(<span class="hljs-keyword">new</span> ArrayList&lt;Server&gt;());<span class="hljs-comment">// 客户端配置</span>    <span class="hljs-keyword">private</span> IClientConfig config;     <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">BaseLoadBalancer</span><span class="hljs-params">(String name, IRule rule, LoadBalancerStats stats,</span></span><span class="hljs-function"><span class="hljs-params">            IPing ping, IPingStrategy pingStrategy)</span> </span>&#123;        logger.debug(<span class="hljs-string">"LoadBalancer [&#123;&#125;]:  initialized"</span>, name);                <span class="hljs-keyword">this</span>.name = name;        <span class="hljs-keyword">this</span>.ping = ping;        <span class="hljs-keyword">this</span>.pingStrategy = pingStrategy;        setRule(rule);        setupPingTask();        lbStats = stats;        init();    &#125;</code></pre><p>从上面的变量信息我们可以看出一些东西：</p><ol><li>默认的 负载均衡策略是随机负载均衡；</li><li>默认的Ping策略为串行化Ping；</li><li>使用了一个list来保存所有的服务列表，一个list来保存当前所有的存活状态的服务列表；</li><li>定义了客户端配置，用于初始化客户端以及负载均衡配置 。</li><li>PingTask定时验证服务器状态</li></ol><p>分析完 BaseLoadBalancer ，DynamicServerListLoadBalancer 和 ZoneAwareLoadBalancer 基本大同小异：</p><ul><li><strong>DynamicServerListLoadBalancer</strong> ：使用动态源的服务器， 即服务器列表可能是在运行时更改。 通过一些Filter函数来动态的过滤掉指定的服务器列表；</li><li><strong>ZoneAwareLoadBalancer</strong> ：这个负载均衡器适用于异地多机房的情况，在选择服务器的时候可以避免整个区域。LoadBalancer将计算并检查所有可用区域的区域统计信息。如果任何区域的“平均活动请求数”已达到配置的阈值，则该区域将从活动服务器列表中删除。如果多个区域已达到阈值，则将删除每台服务器上最活跃请求的区域。一旦删除了最坏的区域，将在其余区域中选择一个区域，其概率与其实例数成正比。服务器将从具有指定规则的选定区域返回。对于每个请求都将重复上述步骤，也就是说，每个区域相关的负载平衡决策都是在最新统计信息的帮助下实时做的。</li></ul><h2 id="三、总结"><a href="#三、总结" class="headerlink" title="三、总结"></a>三、总结</h2><p>使用<code>@LoadBalanced</code>注解标记<code>RestTemplate</code>，在<code>LoadBalancerAutoConfiguration</code>中注入被标记的<code>RestTemplate</code>，使用<code>RestTemplateCustomizer</code>（定制器）并为其增加<code>LoadBalancerInterceptor</code>的拦截器，拦截器中调用<code>LoadBalancerClient</code>（负载均衡客户端）进行处理，获取实际server信息，并回调request，将以逻辑服务名为host的URI转成具体的服务实例。而<code>LoadBalancerClient</code>（负载均衡客户端）内部实际还是调用netflix的 <code>ILoadBalancer</code>（负载均衡器）接口的实现<strong>（ZoneAwareLoadBalancer）</strong></p><p>在<code>ILoadBalancer</code> （负载均衡器）中配置了PIng策略、负载均衡策略、服务列表信息。整个过程如下：</p><p><code>@LoadBalanced</code>–&gt;<code>LoadBalancerAutoConfiguration</code>–&gt;<code>RestTemplateCustomizer</code>–&gt;<code>LoadBalancerInterceptor</code>–&gt;<code>LoadBalancerClient</code>–&gt;<code>ILoadBalancer</code></p><p>注解限定 –&gt; rest定制器 –&gt;  拦截器 –&gt;  客户端  –&gt; 负载均衡器</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;一、-LoadBalanced注解&quot;&gt;&lt;a href=&quot;#一、-LoadBalanced注解&quot; class=&quot;headerlink&quot; title=&quot;一、@LoadBalanced注解&quot;&gt;&lt;/a&gt;一、@LoadBalanced注解&lt;/h2&gt;&lt;p&gt;唯一加的注解就是&lt;c
      
    
    </summary>
    
    
      <category term="springCloud" scheme="http://yoursite.com/categories/springCloud/"/>
    
    
      <category term="ribbon" scheme="http://yoursite.com/tags/ribbon/"/>
    
  </entry>
  
  <entry>
    <title>eureka源码</title>
    <link href="http://yoursite.com/2020/06/13/eureka%E6%BA%90%E7%A0%81/"/>
    <id>http://yoursite.com/2020/06/13/eureka%E6%BA%90%E7%A0%81/</id>
    <published>2020-06-13T13:35:50.000Z</published>
    <updated>2020-06-13T15:17:05.142Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、两种方式禁用服务注册"><a href="#一、两种方式禁用服务注册" class="headerlink" title="一、两种方式禁用服务注册"></a>一、两种方式禁用服务注册</h2><h3 id="1、-EnableDiscoveryClient-autoRegister-false"><a href="#1、-EnableDiscoveryClient-autoRegister-false" class="headerlink" title="1、@EnableDiscoveryClient(autoRegister=false)"></a>1、@EnableDiscoveryClient(autoRegister=false)</h3><h3 id="2、spring-cloud-service-registry-auto-registration-enabled-false"><a href="#2、spring-cloud-service-registry-auto-registration-enabled-false" class="headerlink" title="2、spring.cloud.service-registry.auto-registration.enabled=false"></a>2、spring.cloud.service-registry.auto-registration.enabled=false</h3><pre><code class="hljs java"><span class="hljs-meta">@Import</span>(EnableDiscoveryClientImportSelector<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span><span class="hljs-class"><span class="hljs-title">public</span> @<span class="hljs-title">interface</span> <span class="hljs-title">EnableDiscoveryClient</span> </span>&#123;<span class="hljs-comment">/**</span><span class="hljs-comment"> * If true, the ServiceRegistry will automatically register the local server.</span><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> - &#123;<span class="hljs-doctag">@code</span> true&#125; if you want to automatically register.</span><span class="hljs-comment"> */</span><span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">autoRegister</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">true</span></span>;&#125;</code></pre><ul><li>该配置项默认为true，但是可以主动声明去禁用</li></ul><p><strong><code>@Import(EnableDiscoveryClientImportSelector.class)</code></strong>的源码如下：</p><pre><code class="hljs java"><span class="hljs-meta">@Order</span>(Ordered.LOWEST_PRECEDENCE - <span class="hljs-number">100</span>)<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">EnableDiscoveryClientImportSelector</span></span><span class="hljs-class"><span class="hljs-keyword">extends</span> <span class="hljs-title">SpringFactoryImportSelector</span>&lt;<span class="hljs-title">EnableDiscoveryClient</span>&gt; </span>&#123;<span class="hljs-meta">@Override</span><span class="hljs-keyword">public</span> String[] selectImports(AnnotationMetadata metadata) &#123;    <span class="hljs-comment">// 父类loadFactoryNames方法，定义去加载了FACTORIES_RESOURCE_LOCATION = "META-INF/spring.factories";中所有的自动配置类</span>String[] imports = <span class="hljs-keyword">super</span>.selectImports(metadata);AnnotationAttributes attributes = AnnotationAttributes.fromMap(metadata.getAnnotationAttributes(getAnnotationClass().getName(), <span class="hljs-keyword">true</span>));<span class="hljs-comment">// 获取注解声明的autoRegister，从而调用实际处理</span><span class="hljs-keyword">boolean</span> autoRegister = attributes.getBoolean(<span class="hljs-string">"autoRegister"</span>);<span class="hljs-keyword">if</span> (autoRegister) &#123;List&lt;String&gt; importsList = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;(Arrays.asList(imports));importsList.add(<span class="hljs-string">"org.springframework.cloud.client.serviceregistry.AutoServiceRegistrationConfiguration"</span>);imports = importsList.toArray(<span class="hljs-keyword">new</span> String[<span class="hljs-number">0</span>]);&#125;<span class="hljs-keyword">else</span> &#123;Environment env = getEnvironment();<span class="hljs-keyword">if</span> (ConfigurableEnvironment<span class="hljs-class">.<span class="hljs-keyword">class</span>.<span class="hljs-title">isInstance</span>(<span class="hljs-title">env</span>)) </span>&#123;ConfigurableEnvironment configEnv = (ConfigurableEnvironment) env;LinkedHashMap&lt;String, Object&gt; map = <span class="hljs-keyword">new</span> LinkedHashMap&lt;&gt;();        <span class="hljs-comment">// 从这里可以看出，其实还是通过这个方式处理的</span>map.put(<span class="hljs-string">"spring.cloud.service-registry.auto-registration.enabled"</span>, <span class="hljs-keyword">false</span>);MapPropertySource propertySource = <span class="hljs-keyword">new</span> MapPropertySource(<span class="hljs-string">"springCloudDiscoveryClient"</span>, map);configEnv.getPropertySources().addLast(propertySource);&#125;&#125;<span class="hljs-keyword">return</span> imports;&#125;</code></pre><h2 id="二、springCloud对netflixEureka进行了封装"><a href="#二、springCloud对netflixEureka进行了封装" class="headerlink" title="二、springCloud对netflixEureka进行了封装"></a>二、springCloud对netflixEureka进行了封装</h2><p>打开<code>spring-cloud-starter-netflix-eureka-client.jar</code>，找到<code>META-INF/spring.factories</code>，内容如下：</p><pre><code class="hljs yaml"><span class="hljs-string">org.springframework.boot.autoconfigure.EnableAutoConfiguration=\</span><span class="hljs-string">org.springframework.cloud.netflix.eureka.config.EurekaClientConfigServerAutoConfiguration,\</span><span class="hljs-string">org.springframework.cloud.netflix.eureka.config.DiscoveryClientOptionalArgsConfiguration,\</span><span class="hljs-comment"># EurekaClient的自动配置类</span><span class="hljs-string">org.springframework.cloud.netflix.eureka.EurekaClientAutoConfiguration,\</span><span class="hljs-string">org.springframework.cloud.netflix.ribbon.eureka.RibbonEurekaAutoConfiguration,\</span><span class="hljs-comment"># EurekaDiscoveryClient的自动配置类，默认就扫描加载了</span><span class="hljs-string">org.springframework.cloud.netflix.eureka.EurekaDiscoveryClientConfiguration,\</span><span class="hljs-string">org.springframework.cloud.netflix.eureka.reactive.EurekaReactiveDiscoveryClientConfiguration,\</span><span class="hljs-string">org.springframework.cloud.netflix.eureka.loadbalancer.LoadBalancerEurekaAutoConfiguration</span><span class="hljs-string">org.springframework.cloud.bootstrap.BootstrapConfiguration=\</span><span class="hljs-string">org.springframework.cloud.netflix.eureka.config.EurekaConfigServerBootstrapConfiguration</span></code></pre><p>打开<code>EurekaDiscoveryClientConfiguration</code>，发现，其构造是注入了netflix的EurekaClient，其本身也是一层包装</p><pre><code class="hljs java"><span class="hljs-keyword">import</span> com.netflix.discovery.EurekaClient;<span class="hljs-keyword">import</span> com.netflix.discovery.EurekaClientConfig;<span class="hljs-meta">@Bean</span><span class="hljs-meta">@ConditionalOnMissingBean</span><span class="hljs-function"><span class="hljs-keyword">public</span> EurekaDiscoveryClient <span class="hljs-title">discoveryClient</span><span class="hljs-params">(EurekaClient client,</span></span><span class="hljs-function"><span class="hljs-params">                                             EurekaClientConfig clientConfig)</span> </span>&#123;  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> EurekaDiscoveryClient(client, clientConfig);&#125;</code></pre><p>点进去<code>EurekaClient</code>,其接口和实现类<code>DiscoveryClient</code></p><pre><code class="hljs java"><span class="hljs-meta">@ImplementedBy</span>(DiscoveryClient<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span><span class="hljs-class"><span class="hljs-title">public</span> <span class="hljs-title">interface</span> <span class="hljs-title">EurekaClient</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">LookupService</span> </span>&#123;  ···&#125;</code></pre><p>在<code>DiscoveryClient</code>的构造函数中进行了定时任务的初始化</p><pre><code class="hljs java"><span class="hljs-meta">@Inject</span>DiscoveryClient(ApplicationInfoManager applicationInfoManager, EurekaClientConfig config, AbstractDiscoveryClientOptionalArgs args,                Provider&lt;BackupRegistry&gt; backupRegistryProvider, EndpointRandomizer endpointRandomizer) &#123;···<span class="hljs-comment">// finally, init the schedule tasks (e.g. cluster resolvers, heartbeat, instanceInfo replicator, fetch</span>initScheduledTasks();···</code></pre><h2 id="三、服务获取"><a href="#三、服务获取" class="headerlink" title="三、服务获取"></a>三、服务获取</h2><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * Initializes all scheduled tasks.</span><span class="hljs-comment"> */</span><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">initScheduledTasks</span><span class="hljs-params">()</span> </span>&#123;  <span class="hljs-comment">// 内部是EurekaClientConfigBean中的`eureka.client.fetch-registry=true`参数判断</span>    <span class="hljs-keyword">if</span> (clientConfig.shouldFetchRegistry()) &#123;        <span class="hljs-comment">// registry cache refresh timer</span>        <span class="hljs-keyword">int</span> registryFetchIntervalSeconds = clientConfig.getRegistryFetchIntervalSeconds();        <span class="hljs-keyword">int</span> expBackOffBound = clientConfig.getCacheRefreshExecutorExponentialBackOffBound();      <span class="hljs-comment">// 声明了一个定时任务</span>        cacheRefreshTask = <span class="hljs-keyword">new</span> TimedSupervisorTask(                <span class="hljs-string">"cacheRefresh"</span>,                scheduler,                cacheRefreshExecutor,                registryFetchIntervalSeconds,<span class="hljs-comment">//默认更新周期，30s</span>                TimeUnit.SECONDS,                expBackOffBound,                <span class="hljs-keyword">new</span> CacheRefreshThread()        );              scheduler.schedule(                cacheRefreshTask,                registryFetchIntervalSeconds, TimeUnit.SECONDS);    &#125;····</code></pre><ul><li>服务获取的逻辑处理是一个单独的if</li><li>其判断依据就是eureka.client.fetch-registry=true参数</li></ul><pre><code class="hljs java"><span class="hljs-meta">@ConfigurationProperties</span>(EurekaClientConfigBean.PREFIX)<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">EurekaClientConfigBean</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">EurekaClientConfig</span>, <span class="hljs-title">Ordered</span> </span>&#123;<span class="hljs-comment">/**</span><span class="hljs-comment"> * Default prefix for Eureka client config properties.</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String PREFIX = <span class="hljs-string">"eureka.client"</span>;<span class="hljs-comment">/**</span><span class="hljs-comment"> * Indicates whether this client should fetch eureka registry information from eureka</span><span class="hljs-comment"> * server.</span><span class="hljs-comment"> */</span>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> fetchRegistry = <span class="hljs-keyword">true</span>;</code></pre><h2 id="四、服务注册"><a href="#四、服务注册" class="headerlink" title="四、服务注册"></a>四、服务注册</h2><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment">     * Initializes all scheduled tasks.</span><span class="hljs-comment">     */</span><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">initScheduledTasks</span><span class="hljs-params">()</span> </span>&#123;  ···    <span class="hljs-keyword">if</span> (clientConfig.shouldRegisterWithEureka()) &#123;      ···      <span class="hljs-comment">// InstanceInfo replicator</span>      instanceInfoReplicator = <span class="hljs-keyword">new</span> InstanceInfoReplicator(        <span class="hljs-keyword">this</span>,        instanceInfo,        clientConfig.getInstanceInfoReplicationIntervalSeconds(),        <span class="hljs-number">2</span>); <span class="hljs-comment">// burstSize</span>      ···      instanceInfoReplicator.start(clientConfig.getInitialInstanceInfoReplicationIntervalSeconds());    &#125; <span class="hljs-keyword">else</span> &#123;      logger.info(<span class="hljs-string">"Not registering with Eureka server per configuration"</span>);    &#125;&#125;</code></pre><ul><li>创建了一个instanceInfoReplicator实例，start调用进行定时任务</li></ul><p>定时任务具体如下：</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;  <span class="hljs-keyword">try</span> &#123;    discoveryClient.refreshInstanceInfo();    Long dirtyTimestamp = instanceInfo.isDirtyWithTime();    <span class="hljs-keyword">if</span> (dirtyTimestamp != <span class="hljs-keyword">null</span>) &#123;      <span class="hljs-comment">// 真是出发调用注册的地方就在这里</span>      discoveryClient.register();     ···&#125;<span class="hljs-comment">/**</span><span class="hljs-comment">     * Register with the eureka service by making the appropriate REST call.</span><span class="hljs-comment">     */</span><span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">register</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Throwable </span>&#123;  logger.info(PREFIX + <span class="hljs-string">"&#123;&#125;: registering service..."</span>, appPathIdentifier);  EurekaHttpResponse&lt;Void&gt; httpResponse;  <span class="hljs-keyword">try</span> &#123;    <span class="hljs-comment">// 注册也是通过rest请求，传入了一个instanceInfo对象</span>    httpResponse = eurekaTransport.registrationClient.register(instanceInfo);  &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;    logger.warn(PREFIX + <span class="hljs-string">"&#123;&#125; - registration failed &#123;&#125;"</span>, appPathIdentifier, e.getMessage(), e);    <span class="hljs-keyword">throw</span> e;  &#125;  <span class="hljs-keyword">if</span> (logger.isInfoEnabled()) &#123;    logger.info(PREFIX + <span class="hljs-string">"&#123;&#125; - registration status: &#123;&#125;"</span>, appPathIdentifier, httpResponse.getStatusCode());  &#125;  <span class="hljs-keyword">return</span> httpResponse.getStatusCode() == Status.NO_CONTENT.getStatusCode();&#125;</code></pre><h2 id="五、服务续约"><a href="#五、服务续约" class="headerlink" title="五、服务续约"></a>五、服务续约</h2><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * Initializes all scheduled tasks.</span><span class="hljs-comment"> */</span><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">initScheduledTasks</span><span class="hljs-params">()</span> </span>&#123;    ···    <span class="hljs-keyword">if</span> (clientConfig.shouldRegisterWithEureka()) &#123;        <span class="hljs-keyword">int</span> renewalIntervalInSecs = instanceInfo.getLeaseInfo().getRenewalIntervalInSecs();        <span class="hljs-keyword">int</span> expBackOffBound = clientConfig.getHeartbeatExecutorExponentialBackOffBound();        logger.info(<span class="hljs-string">"Starting heartbeat executor: "</span> + <span class="hljs-string">"renew interval is: &#123;&#125;"</span>, renewalIntervalInSecs);        <span class="hljs-comment">// Heartbeat timer</span>        heartbeatTask = <span class="hljs-keyword">new</span> TimedSupervisorTask(                <span class="hljs-string">"heartbeat"</span>,                scheduler,                heartbeatExecutor,                renewalIntervalInSecs,                TimeUnit.SECONDS,                expBackOffBound,                <span class="hljs-keyword">new</span> HeartbeatThread()        );        scheduler.schedule(                heartbeatTask,                renewalIntervalInSecs, TimeUnit.SECONDS);···&#125;  <span class="hljs-comment">/**</span><span class="hljs-comment">     * The heartbeat task that renews the lease in the given intervals.</span><span class="hljs-comment">     */</span><span class="hljs-keyword">private</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HeartbeatThread</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Runnable</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;      <span class="hljs-keyword">if</span> (renew()) &#123;        lastSuccessfulHeartbeatTimestamp = System.currentTimeMillis();      &#125;    &#125;&#125;  <span class="hljs-comment">/**</span><span class="hljs-comment">     * Renew with the eureka service by making the appropriate REST call</span><span class="hljs-comment">     */</span><span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">renew</span><span class="hljs-params">()</span> </span>&#123;  EurekaHttpResponse&lt;InstanceInfo&gt; httpResponse;  <span class="hljs-keyword">try</span> &#123;    <span class="hljs-comment">// 续约也是rest方式</span>    httpResponse = eurekaTransport.registrationClient.sendHeartBeat(instanceInfo.getAppName(), instanceInfo.getId(), instanceInfo, <span class="hljs-keyword">null</span>);    logger.debug(PREFIX + <span class="hljs-string">"&#123;&#125; - Heartbeat status: &#123;&#125;"</span>, appPathIdentifier, httpResponse.getStatusCode());    <span class="hljs-keyword">if</span> (httpResponse.getStatusCode() == Status.NOT_FOUND.getStatusCode()) &#123;      REREGISTER_COUNTER.increment();      logger.info(PREFIX + <span class="hljs-string">"&#123;&#125; - Re-registering apps/&#123;&#125;"</span>, appPathIdentifier, instanceInfo.getAppName());      <span class="hljs-keyword">long</span> timestamp = instanceInfo.setIsDirtyWithTime();      <span class="hljs-keyword">boolean</span> success = register();      <span class="hljs-keyword">if</span> (success) &#123;        instanceInfo.unsetIsDirty(timestamp);      &#125;      <span class="hljs-keyword">return</span> success;    &#125;    <span class="hljs-keyword">return</span> httpResponse.getStatusCode() == Status.OK.getStatusCode();  &#125; <span class="hljs-keyword">catch</span> (Throwable e) &#123;    logger.error(PREFIX + <span class="hljs-string">"&#123;&#125; - was unable to send heartbeat!"</span>, appPathIdentifier, e);    <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;  &#125;&#125;</code></pre><ul><li>声明了一个heartbeatTask定时任务进行续约，传入HeartbeatThread</li><li>服务续约也是rest方式</li></ul><h2 id="六、配置详解"><a href="#六、配置详解" class="headerlink" title="六、配置详解"></a>六、配置详解</h2><p><code>META-INF/spring.factories</code>，内容中还有个<code>EurekaClientAutoConfiguration</code>，用于加载配置参数类</p><pre><code class="hljs yaml"><span class="hljs-comment"># EurekaClient的自动配置类</span><span class="hljs-string">org.springframework.cloud.netflix.eureka.EurekaClientAutoConfiguration,\</span></code></pre><pre><code class="hljs java"><span class="hljs-meta">@Bean</span><span class="hljs-meta">@ConditionalOnMissingBean</span>(value = EurekaClientConfig<span class="hljs-class">.<span class="hljs-keyword">class</span>,</span><span class="hljs-class">                          <span class="hljs-title">search</span> </span>= SearchStrategy.CURRENT)<span class="hljs-function"><span class="hljs-keyword">public</span> EurekaClientConfigBean <span class="hljs-title">eurekaClientConfigBean</span><span class="hljs-params">(ConfigurableEnvironment env)</span> </span>&#123;  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> EurekaClientConfigBean();&#125;<span class="hljs-meta">@Bean</span><span class="hljs-meta">@ConditionalOnMissingBean</span>(value = EurekaInstanceConfig<span class="hljs-class">.<span class="hljs-keyword">class</span>,</span><span class="hljs-class">                          <span class="hljs-title">search</span> </span>= SearchStrategy.CURRENT)<span class="hljs-function"><span class="hljs-keyword">public</span> EurekaInstanceConfigBean <span class="hljs-title">eurekaInstanceConfigBean</span><span class="hljs-params">(InetUtils inetUtils,</span></span><span class="hljs-function"><span class="hljs-params">                                                         ManagementMetadataProvider managementMetadataProvider)</span> </span>&#123;&#125;</code></pre><ul><li>可以查看<code>EurekaClientConfigBean</code>和<code>EurekaInstanceConfigBean</code>获取比官方文档更详细的解释说明</li><li>eureka的所有的配置信息，都是通过<code>EurekaInstanceConfigBean</code>加载的，真正注册时，内部包装成<code>InstanceInfo</code>进行传递</li></ul><h3 id="1、注册中心配置"><a href="#1、注册中心配置" class="headerlink" title="1、注册中心配置"></a>1、注册中心配置</h3><ul><li><code>eureka.client.serverUrl.defaultZone=xxx</code>：</li></ul><pre><code class="hljs java"><span class="hljs-keyword">private</span> Map&lt;String, String&gt; serviceUrl = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();&#123;   <span class="hljs-keyword">this</span>.serviceUrl.put(DEFAULT_ZONE, DEFAULT_URL);&#125;<span class="hljs-comment">/**</span><span class="hljs-comment"> * Default Eureka URL.</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String DEFAULT_URL = <span class="hljs-string">"http://localhost:8761"</span> + DEFAULT_PREFIX+ <span class="hljs-string">"/"</span>;<span class="hljs-comment">/**</span><span class="hljs-comment"> * Default availability zone if none is resolved based on region.</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String DEFAULT_ZONE = <span class="hljs-string">"defaultZone"</span>;</code></pre><h3 id="2、实例名配置"><a href="#2、实例名配置" class="headerlink" title="2、实例名配置"></a>2、实例名配置</h3><ul><li><code>eureka.instance.instanceId</code></li><li>它是区分同一服务不同实例的唯一标识</li><li>实例名采用主机名作为唯一标识，规则如下</li></ul><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title">getDefaultInstanceId</span><span class="hljs-params">(PropertyResolver resolver,</span></span><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">boolean</span> includeHostname)</span> </span>&#123;String vcapInstanceId = resolver.getProperty(<span class="hljs-string">"vcap.application.instance_id"</span>);<span class="hljs-keyword">if</span> (StringUtils.hasText(vcapInstanceId)) &#123;<span class="hljs-keyword">return</span> vcapInstanceId;&#125;String hostname = <span class="hljs-keyword">null</span>;<span class="hljs-keyword">if</span> (includeHostname) &#123;hostname = resolver.getProperty(<span class="hljs-string">"spring.cloud.client.hostname"</span>);&#125;String appName = resolver.getProperty(<span class="hljs-string">"spring.application.name"</span>);String namePart = combineParts(hostname, SEPARATOR, appName);String indexPart = resolver.getProperty(<span class="hljs-string">"spring.application.instance_id"</span>,resolver.getProperty(<span class="hljs-string">"server.port"</span>));<span class="hljs-keyword">return</span> combineParts(namePart, SEPARATOR, indexPart);&#125;</code></pre><blockquote><p>即 <code>${spring.cloud.client.hostname}:${spring.application.name}:${spring.application.instance_id}</code></p></blockquote><h3 id="3、端点配置"><a href="#3、端点配置" class="headerlink" title="3、端点配置"></a>3、端点配置</h3><ul><li><p><code>homePageUrl、statusPageUrl、healthCheckUrl</code>，即<code>spring-boot-actuator</code>模块提供的<code>/info</code>和<code>/health</code>端点</p></li><li><p>当应用设置了context-path时，端点也需要加上该前缀</p></li></ul><pre><code class="hljs ini"><span class="hljs-attr">xxx.context-path</span>=/orange<span class="hljs-attr">eureka.instance.statusPageUrlPath</span>=<span class="hljs-variable">$&#123;xxx.context-path&#125;</span>/info<span class="hljs-attr">eureka.instance.healthCheckUrlPath</span>=<span class="hljs-variable">$&#123;xxx.context-path&#125;</span>/health</code></pre><ul><li>或者为了安全考虑，修改端点的原始路径</li></ul><pre><code class="hljs ini"><span class="hljs-attr">endpoints.info.path</span>=/orangeInfo<span class="hljs-attr">endpoints.health.path</span>=/orangeHealth<span class="hljs-attr">eureka.instance.statusPageUrlPath</span>=<span class="hljs-variable">$&#123;endpoints.info.path&#125;</span><span class="hljs-attr">eureka.instance.healthCheckUrlPath</span>=<span class="hljs-variable">$&#123;endpoints.health.path&#125;</span></code></pre><h3 id="4、健康检查"><a href="#4、健康检查" class="headerlink" title="4、健康检查"></a>4、健康检查</h3><ul><li>客户端默认的心跳方式可以有效的检查客户端进程是否运行，但是无法保证客户端能否正常提供服务</li><li>可以把客户端的健康检查交给actuator</li></ul><pre><code class="hljs yaml"><span class="hljs-comment"># 在pom中引入Spring-boot-starter-actuator</span><span class="hljs-comment"># 增加参数配置：eureka.client.healthcheck.enabled=true</span></code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;一、两种方式禁用服务注册&quot;&gt;&lt;a href=&quot;#一、两种方式禁用服务注册&quot; class=&quot;headerlink&quot; title=&quot;一、两种方式禁用服务注册&quot;&gt;&lt;/a&gt;一、两种方式禁用服务注册&lt;/h2&gt;&lt;h3 id=&quot;1、-EnableDiscoveryClient-
      
    
    </summary>
    
    
      <category term="springCloud" scheme="http://yoursite.com/categories/springCloud/"/>
    
    
      <category term="eureka" scheme="http://yoursite.com/tags/eureka/"/>
    
  </entry>
  
  <entry>
    <title>eureka组件</title>
    <link href="http://yoursite.com/2020/06/09/eureka%E7%BB%84%E4%BB%B6/"/>
    <id>http://yoursite.com/2020/06/09/eureka%E7%BB%84%E4%BB%B6/</id>
    <published>2020-06-09T12:50:00.000Z</published>
    <updated>2020-06-13T15:17:20.004Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、EnableDiscoveryClient与EnableEurekaClient的区别"><a href="#一、EnableDiscoveryClient与EnableEurekaClient的区别" class="headerlink" title="一、EnableDiscoveryClient与EnableEurekaClient的区别"></a>一、EnableDiscoveryClient与EnableEurekaClient的区别</h2><p>Spring Cloud版本：Angle -&gt; Brixton -&gt; Camden -&gt; Dalston -&gt; Edgware -&gt; Finchley-&gt;Greenwich-&gt;Hoxton</p><blockquote><ol><li>Dalston或更早期的版本,为了启用服务注册发现功能。需要在主启动类上增加<code>@EnableDiscoveryClient</code>或者<code>@EnableEurekaClient</code>注解。</li><li><code>@EnableEurekaClient</code>内部使用了<code>@EnableDiscoveryClient</code>注解，因此如果要使用eureka的注册发现服务，两者功能是一样的。</li><li>EnableDiscoveryClient注解在spring.factories配置中通过配置项EurekaDiscoveryClientConfiguration来开启服务注册发现功能。</li></ol></blockquote><ul><li>@EnableDiscoveryClient注解是基于spring-cloud-commons依赖，并且在classpath中实现。</li><li>@EnableEurekaClient注解是基于spring-cloud-netflix依赖，只能为eureka作用。</li><li>@EnableEurekaClient只适用于Eureka作为注册中心，@EnableDiscoveryClient 可以是其他注册中心。</li></ul><h2 id="二、-EnableDiscoveryClient注解现在也没用了（Dalston之后的版本中（不含Dalston））"><a href="#二、-EnableDiscoveryClient注解现在也没用了（Dalston之后的版本中（不含Dalston））" class="headerlink" title="二、 @EnableDiscoveryClient注解现在也没用了（Dalston之后的版本中（不含Dalston））"></a>二、 @EnableDiscoveryClient注解现在也没用了（Dalston之后的版本中（不含Dalston））</h2><p>只要依赖了以spring-cloud-starter-netflix为前缀的库(例如spring-cloud-starter-netflix-eureka-client)，就启用了服务注册发现功能。</p><p>使用配置项<code>spring.cloud.service-registry.auto-registration.enabled=false</code>即可禁止服务注册发现功能。</p><p>spring容器在查询spring.factories的过程中，如果找到了EnableDiscoveryClient的配置，就会实例化该配置对应的服务注册发现：例如eureka、consul、zookeeper等。</p><p>打开工程spring-cloud-netflix-eureka-client.jar，去看src\main\resources\META-INF目录下的spring.factories文件，发现在springboot的自动配置项中，出现了一个关键配置EurekaDiscoveryClientConfiguration，如下：</p><pre><code class="hljs yaml"><span class="hljs-string">org.springframework.boot.autoconfigure.EnableAutoConfiguration=\</span><span class="hljs-string">org.springframework.cloud.netflix.eureka.config.EurekaClientConfigServerAutoConfiguration,\</span><span class="hljs-string">org.springframework.cloud.netflix.eureka.config.DiscoveryClientOptionalArgsConfiguration,\</span><span class="hljs-string">org.springframework.cloud.netflix.eureka.EurekaClientAutoConfiguration,\</span><span class="hljs-string">org.springframework.cloud.netflix.ribbon.eureka.RibbonEurekaAutoConfiguration,\</span><span class="hljs-string">org.springframework.cloud.netflix.eureka.EurekaDiscoveryClientConfiguration,\</span><span class="hljs-string">org.springframework.cloud.netflix.eureka.reactive.EurekaReactiveDiscoveryClientConfiguration,\</span><span class="hljs-string">org.springframework.cloud.netflix.eureka.loadbalancer.LoadBalancerEurekaAutoConfiguration</span><span class="hljs-string">org.springframework.cloud.bootstrap.BootstrapConfiguration=\</span><span class="hljs-string">org.springframework.cloud.netflix.eureka.config.EurekaConfigServerBootstrapConfiguration</span></code></pre><blockquote><ol><li><p>在spring.factories配置中，配置类EurekaDiscoveryClientConfiguration被配置到springboot的自动配置注解中，与EnableDiscoveryClient注解没有关系了,也就是说只要开启了springboot的自动配置，服务注册发现功能就会启用。</p></li><li><p>EnableEurekaClient源码中没有使用注解EnableDiscoveryClient，此时EnableEurekaClient已经没用了。</p></li></ol></blockquote><h2 id="三、Eureka两个组件：Eureka-Server和Eureka-Client。"><a href="#三、Eureka两个组件：Eureka-Server和Eureka-Client。" class="headerlink" title="三、Eureka两个组件：Eureka Server和Eureka Client。"></a>三、Eureka两个组件：Eureka Server和Eureka Client。</h2><p><strong>Eureka Server</strong></p><ul><li>Eureka Server 提供服务发现能力，各个微服务启动时，会向Eureka Server注册自己的信息（例如IP、端口、微服务名称等），Eureka Server会存储这些信息。</li><li>Eureka Server作为一个独立的部署单元，以REST API的形式为服务实例提供了注册、管理和查询等操作。同时，Eureka Server也为我们提供了可视化的监控页面，可以直观地看到各个Eureka Server当前的运行状态和所有已注册服务的情况。</li></ul><p><strong>Eureka Client</strong></p><ul><li><p>Erueka Client是一个java客户端，用于简化与Eureka的交互。</p></li><li><p>微服务启动后，会周期性（默认30s）地向Eureka Server发送心跳以续约自己的“ 租期 ”。</p></li><li><p>如果Eureka server在一定的时间内没有接收到某个微服务实例的心跳，Eureka Server将注销该实例（默认90s）。</p></li><li><p>默认情况下，Eureka Server同时也是Eureka Client。 多个Eureka Server 实例互相之间通过复制的方式来实现服务注册表中数据的同步。</p></li><li><p>Eureka Client 会缓存服务注册表中的信息，这种方式有一定的优势——首先，无须每次请求都查询Eureka Server，从而降低了Eureka Server的压力；其次，即使Eureka Server所有节点都宕掉，服务消费者依然可以使用缓存中的信息找到服务提供者并完成调用。 综上，Eureka通过心跳检查、客户端缓存等机制，提高了系统的灵活性、可伸缩性和可用性。</p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;一、EnableDiscoveryClient与EnableEurekaClient的区别&quot;&gt;&lt;a href=&quot;#一、EnableDiscoveryClient与EnableEurekaClient的区别&quot; class=&quot;headerlink&quot; title=&quot;一、
      
    
    </summary>
    
    
      <category term="springCloud" scheme="http://yoursite.com/categories/springCloud/"/>
    
    
      <category term="eureka" scheme="http://yoursite.com/tags/eureka/"/>
    
  </entry>
  
  <entry>
    <title>RestTemplate使用</title>
    <link href="http://yoursite.com/2020/06/08/RestTemplate%E4%BD%BF%E7%94%A8/"/>
    <id>http://yoursite.com/2020/06/08/RestTemplate%E4%BD%BF%E7%94%A8/</id>
    <published>2020-06-08T13:05:44.000Z</published>
    <updated>2020-06-08T13:57:05.423Z</updated>
    
    <content type="html"><![CDATA[<h1 id="restTemplate详解"><a href="#restTemplate详解" class="headerlink" title="restTemplate详解"></a>restTemplate详解</h1><ul><li>该对象会使用ribbon的自动化配置，同时通过@LoadBalanced注解修饰还能开启客户端负载均衡</li></ul><h2 id="一、GET请求"><a href="#一、GET请求" class="headerlink" title="一、GET请求"></a>一、GET请求</h2><h3 id="1-1-getForEntity"><a href="#1-1-getForEntity" class="headerlink" title="1.1 getForEntity"></a>1.1 getForEntity</h3><ul><li>该方法返回的是ResponseEntity，是spring对HTTP响应的封装。</li></ul><blockquote><p>主要存储了HTTP的几个重要元素，如HttpStatus状态码。在HttpEntity中还存储着HttpHeaders以及范型类型的请求体对象。</p></blockquote><p><strong>三种常见的重载方式</strong></p><pre><code class="hljs java">getForEntity(String url, Class&lt;T&gt; responseType, Object... uriVariables) <span class="hljs-comment">// 如 restTemplate.getForEntity("http://MYCLOUD-PROVIDER/user?name=&#123;1&#125;", String.class, "orange");</span></code></pre><ul><li>url中使用占位符的方式进行参数绑定。</li><li>第二个参数为返回值的包装类型。</li></ul><hr><pre><code class="hljs java">RestTemplate restTemplate = <span class="hljs-keyword">new</span> RestTemplate();Map&lt;String, String&gt; params = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();params.put(<span class="hljs-string">"key"</span>, <span class="hljs-string">"orange"</span>);restTemplate.getForEntity(<span class="hljs-string">"http://MYCLOUD-PROVIDER/user?name=&#123;key&#125;"</span>, String<span class="hljs-class">.<span class="hljs-keyword">class</span>, <span class="hljs-title">params</span>)</span>;</code></pre><ul><li>参数绑定的方式稍有不同。</li></ul><hr><pre><code class="hljs java">RestTemplate restTemplate = <span class="hljs-keyword">new</span> RestTemplate();UriComponents uriComponents = UriComponentsBuilder  .fromUriString(<span class="hljs-string">"http://MYCLOUD-PROVIDER/user?name=&#123;key&#125;"</span>)  .build()  .expand(<span class="hljs-string">"orange"</span>)  .encode();URI uri = uriComponents.toUri();ResponseEntity&lt;String&gt; forEntity = restTemplate.getForEntity(uri, String<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;</code></pre><h3 id="1-2-getForObject"><a href="#1-2-getForObject" class="headerlink" title="1.2 getForObject"></a>1.2 getForObject</h3><ul><li>请求方式基本同getForEntity，可以理解是对其的进一步封装。</li><li>它通过HttpMessageConverterExtractor对body进行转换，实现请求直接返回包装好的对象内容。</li></ul><pre><code class="hljs java">restTemplate.getForObject(url, Orange<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;</code></pre><ul><li>当body是一个Orange对象时，可直接包装。</li></ul><blockquote><p>当不需要关注响应body之外的内容时，建议使用该方式，可以少一个从response中获取body的步骤。</p></blockquote><h2 id="二、POST请求"><a href="#二、POST请求" class="headerlink" title="二、POST请求"></a>二、POST请求</h2><pre><code class="hljs java">postForEntity(String url, <span class="hljs-meta">@Nullable</span> Object request, Class&lt;T&gt; responseType, Object... uriVariables)</code></pre><ul><li>基本用法与get类似，这里需要注意的是新增加的request参数。</li><li>request可以是一个普通对象，也可以是一个HttpEntity对象。</li><li>request普通对象会被隐式转换成HttpEntity对象。</li><li>这个request不仅包含了body内容，还包含了header内容。</li><li>第四个参数uriVariables用于对url中参数绑定。</li></ul><h2 id="三、PUT请求"><a href="#三、PUT请求" class="headerlink" title="三、PUT请求"></a>三、PUT请求</h2><pre><code class="hljs java">put(String url, <span class="hljs-meta">@Nullable</span> Object request, Object... uriVariables)</code></pre><h2 id="四、DELETE请求"><a href="#四、DELETE请求" class="headerlink" title="四、DELETE请求"></a>四、DELETE请求</h2><pre><code class="hljs java">delete(String url, Object... uriVariables)</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;restTemplate详解&quot;&gt;&lt;a href=&quot;#restTemplate详解&quot; class=&quot;headerlink&quot; title=&quot;restTemplate详解&quot;&gt;&lt;/a&gt;restTemplate详解&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;该对象会使用ribbon的自动化
      
    
    </summary>
    
    
      <category term="springCloud" scheme="http://yoursite.com/categories/springCloud/"/>
    
    
      <category term="restTemplate" scheme="http://yoursite.com/tags/restTemplate/"/>
    
  </entry>
  
  <entry>
    <title>ribbon使用</title>
    <link href="http://yoursite.com/2020/06/08/ribbon%E4%BD%BF%E7%94%A8/"/>
    <id>http://yoursite.com/2020/06/08/ribbon%E4%BD%BF%E7%94%A8/</id>
    <published>2020-06-08T12:17:27.000Z</published>
    <updated>2020-06-14T14:50:00.572Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、什么是ribbon"><a href="#一、什么是ribbon" class="headerlink" title="一、什么是ribbon"></a>一、什么是ribbon</h2><ul><li>Spring cloud ribbon是一个基于HTTP和TCP的客户端负载均衡工具，它基于netflix ribbon实现。</li><li>将面向服务的rest模版请求自动转换成客户端负载均衡的服务调用。</li><li>是一个工具类框架，例如API网关的请求转发、Feign的底层都是基于ribbon的。</li></ul><h2 id="二、客户端负载均衡"><a href="#二、客户端负载均衡" class="headerlink" title="二、客户端负载均衡"></a>二、客户端负载均衡</h2><h3 id="1、基础理论"><a href="#1、基础理论" class="headerlink" title="1、基础理论"></a>1、基础理论</h3><ul><li>负载均衡是系统高可用、缓解网络压力、处理能力扩容的重要手段之一。</li></ul><h4 id="1-1-服务端负载均衡"><a href="#1-1-服务端负载均衡" class="headerlink" title="1.1 服务端负载均衡"></a>1.1 服务端负载均衡</h4><ul><li>我们通常所说的负载均衡都是服务端负载均衡，硬件层面如F5，软件层面如nginx。</li><li>硬件负载均衡的设备或者软件负载均衡的软件，都会维护一个可用的服务清单，并通过心跳的方式来剔除故障的服务端节点。</li><li>当客户端发送请求到负载均衡设备时，该设备按照一定算法（轮询、权重、流量等）从服务端清单中取出一个地址，然后转发请求。</li></ul><h4 id="1-2-客户端负载均衡"><a href="#1-2-客户端负载均衡" class="headerlink" title="1.2 客户端负载均衡"></a>1.2 客户端负载均衡</h4><ul><li>在客户端负载均衡中，所有的客户端节点都维护着自己的服务端清单，并通过心跳维护清单的健康性。</li><li>即客户端负载和服务端负载最大的不同点在于清单所储存的位置。</li></ul><h3 id="2、使用方式"><a href="#2、使用方式" class="headerlink" title="2、使用方式"></a>2、使用方式</h3><ul><li>服务提供者启动多个实例并注册到一个或多个相关联的注册中心</li><li>服务消费者直接调用被@LoadBalanced注解修饰的RestTemplate进行服务调用。</li></ul><p><strong>pom文件</strong>中需要引入关于Ribbon的包，同时consumer也是一个Eureka Client要去拉 Eureka Server的配置，所以需要Eureka client的包。</p><pre><code class="hljs java">&lt;dependency&gt;    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;    &lt;artifactId&gt;spring-cloud-starter-netflix-ribbon&lt;/artifactId&gt;    &lt;version&gt;2.2.3.RELEASE&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt;    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;    &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt;    &lt;version&gt;2.2.3.RELEASE&lt;/version&gt;&lt;/dependency&gt;</code></pre><p>java中配置<strong>负载均衡策略</strong>和<strong>@LoadBalanced</strong>修饰的<strong>RestTemplate</strong></p><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RestTemplateConfig</span> </span>&#123;  <span class="hljs-comment">// 负载均衡策略，定义了一个随机方式的服务调用方式，即随即调用某个服务的提供者</span>  <span class="hljs-meta">@Bean</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> IRule <span class="hljs-title">ribbonRule</span><span class="hljs-params">()</span></span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> RandomRule();    &#125;<span class="hljs-comment">// 定义一个负载均衡的 RestTemplate，该注解配合负载均衡策略一起使用， RestTemplate 发出的请求才能生效。</span>    <span class="hljs-meta">@Bean</span>    <span class="hljs-meta">@LoadBalanced</span>    <span class="hljs-function">RestTemplate <span class="hljs-title">restTemplate</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> RestTemplate();    &#125;&#125;</code></pre><p>接下来就可以进行调用了</p><pre><code class="hljs java"><span class="hljs-comment">// 根据服务名去访问，需要将restTemplate注解为@LoadBalanced才会生效</span><span class="hljs-keyword">private</span> String service = <span class="hljs-string">"http://MYCLOUD-PROVIDER"</span>;<span class="hljs-meta">@RequestMapping</span>(<span class="hljs-string">"/consumer/corps/&#123;id&#125;"</span>)<span class="hljs-function">Corp <span class="hljs-title">getCorp</span><span class="hljs-params">(@PathVariable(<span class="hljs-string">"id"</span>)</span> String id) </span>&#123;String url = service + <span class="hljs-string">"/corps/"</span> + id;<span class="hljs-keyword">return</span> restTemplate.getForObject(url, Corp<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;&#125;</code></pre><h2 id="3、自动装配方式解读"><a href="#3、自动装配方式解读" class="headerlink" title="3、自动装配方式解读"></a>3、自动装配方式解读</h2><p>在springCloud实现的服务治理框架中，默认对ribbon自动化整合配置。如eureka中<code>spring.factories</code>:</p><pre><code class="hljs yaml"><span class="hljs-string">org.springframework.boot.autoconfigure.EnableAutoConfiguration=\</span><span class="hljs-string">···</span><span class="hljs-string">org.springframework.cloud.netflix.eureka.EurekaClientAutoConfiguration,\</span><span class="hljs-comment"># 自动整合ribbon相关配置，通过这个类来了解它的配置详情</span><span class="hljs-string">org.springframework.cloud.netflix.ribbon.eureka.RibbonEurekaAutoConfiguration,\</span><span class="hljs-string">org.springframework.cloud.netflix.eureka.EurekaDiscoveryClientConfiguration,\</span><span class="hljs-string">···</span></code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;一、什么是ribbon&quot;&gt;&lt;a href=&quot;#一、什么是ribbon&quot; class=&quot;headerlink&quot; title=&quot;一、什么是ribbon&quot;&gt;&lt;/a&gt;一、什么是ribbon&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;Spring cloud ribbon是一个基于HTTP
      
    
    </summary>
    
    
      <category term="springCloud" scheme="http://yoursite.com/categories/springCloud/"/>
    
    
      <category term="ribbon" scheme="http://yoursite.com/tags/ribbon/"/>
    
  </entry>
  
  <entry>
    <title>eureka使用</title>
    <link href="http://yoursite.com/2020/06/07/eureka%E4%BD%BF%E7%94%A8/"/>
    <id>http://yoursite.com/2020/06/07/eureka%E4%BD%BF%E7%94%A8/</id>
    <published>2020-06-07T15:20:49.000Z</published>
    <updated>2020-06-09T15:29:48.178Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、eureka是什么"><a href="#一、eureka是什么" class="headerlink" title="一、eureka是什么"></a>一、eureka是什么</h2><ul><li>服务治理可以说是微服务架构中核心的模块，它主要用来实现各个微服务实例之间的自动化注册与发现。</li></ul><p><strong>1、服务注册：</strong></p><p>每个服务单元将自己的主机号、版本号、通信协议等告知注册中心，注册中心维护服务清单，并通过心跳的方式监测清单中的服务是否可用，并剔除不可用的服务。</p><p><strong>2、服务发现：</strong></p><p>各服务单元通过服务名进行相互调用。</p><p><strong>3、eureka服务端：</strong></p><p>即服务注册中心，提供服务治理，即服务注册与发现的功能。</p><blockquote><p>若eureka以集群方式部署，当集群中有分片出现故障时，eureka进入自我保护模式。它允许再分片故障期间继续提供服务注册与发现，等故障恢复后，其他分片会把它们的状态再次同步回来。</p></blockquote><blockquote><p>不同服务端通过异步的方式相互复制各自的状态，这意味着在任意时间点，每个实例关于所有服务的状态是有细微差异的。也就是我们通常所说的AP原则。</p></blockquote><p><strong>4、eureka客户端</strong></p><p>向注册中心注册自身提供的服务，并周期性的发送心跳来更新服务租约。</p><p>将服务端已注册的服务信息缓存到本地，并周期性的刷新。</p><h2 id="二、单机配置方式"><a href="#二、单机配置方式" class="headerlink" title="二、单机配置方式"></a>二、单机配置方式</h2><h3 id="1、服务端"><a href="#1、服务端" class="headerlink" title="1、服务端"></a>1、服务端</h3><h4 id="1）pom中引入："><a href="#1）pom中引入：" class="headerlink" title="1）pom中引入："></a>1）pom中引入：</h4><pre><code class="hljs java">&lt;dependencies&gt;  &lt;dependency&gt;  &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;  &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-server&lt;/artifactId&gt;  &lt;version&gt;2.2.3.RELEASE&lt;/version&gt;  &lt;/dependency&gt;&lt;/dependencies&gt;</code></pre><h4 id="2）配置文件："><a href="#2）配置文件：" class="headerlink" title="2）配置文件："></a>2）配置文件：</h4><pre><code class="hljs yaml"><span class="hljs-attr">server:</span>  <span class="hljs-attr">port:</span> <span class="hljs-number">8003</span><span class="hljs-attr">eureka:</span>  <span class="hljs-attr">instance:</span>    <span class="hljs-attr">hostname:</span> <span class="hljs-string">localhost</span> <span class="hljs-comment"># eureka服务端的实例名字</span>  <span class="hljs-attr">client:</span>    <span class="hljs-attr">service-url:</span>      <span class="hljs-attr">defaultZone:</span> <span class="hljs-string">http://$&#123;eureka.instance.hostname&#125;:$&#123;server.port&#125;/eureka/</span>    <span class="hljs-attr">register-with-eureka:</span> <span class="hljs-literal">false</span> <span class="hljs-comment"># 是否向注册中心注册自己，默认true，server应设置为false</span>    <span class="hljs-attr">fetch-registry:</span> <span class="hljs-literal">false</span> <span class="hljs-comment"># 服务端本身就是维护服务实例的，所以并不需要去检索服务，默认true，server应设置为false</span></code></pre><h4 id="3）启动类"><a href="#3）启动类" class="headerlink" title="3）启动类:"></a>3）启动类:</h4><pre><code class="hljs java"><span class="hljs-meta">@SpringBootApplication</span><span class="hljs-meta">@EnableEurekaServer</span> <span class="hljs-comment">//开启Eureka服务端，接受其它微服务注册进来</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">EurekaServer8003</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        SpringApplication.run(EurekaServer8003<span class="hljs-class">.<span class="hljs-keyword">class</span>, <span class="hljs-title">args</span>)</span>;    &#125;&#125;</code></pre><h3 id="2、客户端"><a href="#2、客户端" class="headerlink" title="2、客户端"></a>2、客户端</h3><h4 id="1）pom中引入"><a href="#1）pom中引入" class="headerlink" title="1）pom中引入"></a>1）pom中引入</h4><pre><code class="hljs java">&lt;dependency&gt;&lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;&lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt;&lt;version&gt;2.2.3.RELEASE&lt;/version&gt;&lt;/dependency&gt;</code></pre><h4 id="2）配置文件"><a href="#2）配置文件" class="headerlink" title="2）配置文件"></a>2）配置文件</h4><pre><code class="hljs yaml"><span class="hljs-attr">spring:</span>  <span class="hljs-attr">application:</span>    <span class="hljs-attr">name:</span> <span class="hljs-string">mycloud-provider</span> <span class="hljs-comment"># eureka页面 application显示的名称。EurekaServer中服务名默认转成大写的。</span><span class="hljs-attr">eureka:</span>  <span class="hljs-attr">client:</span>    <span class="hljs-attr">service-url:</span>      <span class="hljs-attr">defaultZone:</span> <span class="hljs-string">http://localhost:8003/eureka/</span>  <span class="hljs-attr">instance:</span>    <span class="hljs-attr">instance-id:</span> <span class="hljs-string">$&#123;spring.application.name&#125;:$&#123;server.port&#125;</span> <span class="hljs-comment"># eureka页面status显示的内容</span></code></pre><h4 id="3）启动类-1"><a href="#3）启动类-1" class="headerlink" title="3）启动类"></a>3）启动类</h4><pre><code class="hljs java"><span class="hljs-meta">@SpringBootApplication</span><span class="hljs-comment">// 可不加该配置，Dalston之后的版本中（不含Dalston），只要开启了springboot的自动配置，服务注册发现功能就会启用</span><span class="hljs-comment">// 使用配置项`spring.cloud.service-registry.auto-registration.enabled=false`即可禁止服务注册发现功能。</span><span class="hljs-comment">// eureka.client.register-with-eureka: false 也可禁止服务注册功能。</span><span class="hljs-comment">// @EnableEurekaClient </span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CorpProvider8001</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        SpringApplication.run(CorpProvider8001<span class="hljs-class">.<span class="hljs-keyword">class</span>, <span class="hljs-title">args</span>)</span>;    &#125;&#125;</code></pre><blockquote><p>如果不想用主机名作为自定义注册中心的地址，也可以使用IP的形式。在配置文件中配置eureka.instance.prefer-ip-address=true，改值默认为false。</p></blockquote><h3 id="三、info信息完善"><a href="#三、info信息完善" class="headerlink" title="三、info信息完善"></a>三、info信息完善</h3><h4 id="1）引入依赖"><a href="#1）引入依赖" class="headerlink" title="1）引入依赖"></a>1）引入依赖</h4><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-actuator<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre><h4 id="2）yml中配置"><a href="#2）yml中配置" class="headerlink" title="2）yml中配置"></a>2）yml中配置</h4><pre><code class="hljs yaml"><span class="hljs-attr">info:</span> <span class="hljs-comment"># eureka页面status点击跳转监控页面 显示的内容</span>  <span class="hljs-attr">app.name:</span> <span class="hljs-string">$&#123;spring.application.name&#125;</span>  <span class="hljs-attr">company.name:</span> <span class="hljs-string">www.orange.com</span>  <span class="hljs-attr">build.artifactId:</span> <span class="hljs-string">mycloud-provider</span>  <span class="hljs-attr">build.version:</span> <span class="hljs-number">1.0</span></code></pre><h3 id="四、高可用集群配置方式"><a href="#四、高可用集群配置方式" class="headerlink" title="四、高可用集群配置方式"></a>四、高可用集群配置方式</h3><p>eureka server的高可用实际上就是将自己作为服务向其他注册中心注册自己。</p><h4 id="1）创建server1"><a href="#1）创建server1" class="headerlink" title="1）创建server1"></a>1）创建server1</h4><pre><code class="hljs yaml"><span class="hljs-attr">spring:</span>  <span class="hljs-attr">application:</span>    <span class="hljs-attr">name:</span> <span class="hljs-string">eureka-server</span><span class="hljs-attr">server:</span>  <span class="hljs-attr">port:</span> <span class="hljs-number">8003</span><span class="hljs-attr">eureka:</span>  <span class="hljs-attr">instance:</span>    <span class="hljs-attr">hostname:</span> <span class="hljs-string">server-1</span>  <span class="hljs-attr">client:</span>    <span class="hljs-attr">service-url:</span>      <span class="hljs-attr">defaultZone:</span> <span class="hljs-string">http://server-2:8004/eureka/</span></code></pre><h4 id="2-创建server2"><a href="#2-创建server2" class="headerlink" title="2) 创建server2"></a>2) 创建server2</h4><pre><code class="hljs yaml"><span class="hljs-attr">spring:</span>  <span class="hljs-attr">application:</span>    <span class="hljs-attr">name:</span> <span class="hljs-string">eureka-server</span><span class="hljs-attr">server:</span>  <span class="hljs-attr">port:</span> <span class="hljs-number">8004</span><span class="hljs-attr">eureka:</span>  <span class="hljs-attr">instance:</span>    <span class="hljs-attr">hostname:</span> <span class="hljs-string">server-2</span>  <span class="hljs-attr">client:</span>    <span class="hljs-attr">service-url:</span>      <span class="hljs-attr">defaultZone:</span> <span class="hljs-string">http://server-1:8003/eureka/</span></code></pre><h4 id="3）客户端配置"><a href="#3）客户端配置" class="headerlink" title="3）客户端配置"></a>3）客户端配置</h4><pre><code class="hljs yaml"><span class="hljs-attr">spring:</span>  <span class="hljs-attr">application:</span>    <span class="hljs-attr">name:</span> <span class="hljs-string">client</span><span class="hljs-attr">eureka:</span>  <span class="hljs-attr">client:</span>    <span class="hljs-attr">service-url:</span>      <span class="hljs-attr">defaultZone:</span> <span class="hljs-string">http://server-1:8003/eureka/,http://server-2:8004/eureka/</span> <span class="hljs-comment"># 分别向两个服务端注入</span></code></pre><h3 id="五、基础架构"><a href="#五、基础架构" class="headerlink" title="五、基础架构"></a>五、基础架构</h3><p>服务治理的3个核心要素：服务提供者、服务消费者、服务注册中心。</p><blockquote><p>很多时候，客户端既是服务提供者又是服务消费者</p></blockquote><h4 id="1）服务提供者"><a href="#1）服务提供者" class="headerlink" title="1）服务提供者"></a>1）服务提供者</h4><p><strong>服务注册：</strong></p><p>服务提供者在启动的时候，通过rest请求将自己注册到eureka server，同时附带一些元数据信息。eureka server将它储存在一个双层map中，第一层key是服务名，第二层key是实例名。</p><blockquote><p>在服务注册时，需确认一下eureka.client.register-with-eureka=true参数是否正确。改值默认为true，若设置为false将不会注册。</p></blockquote><p><strong>服务同步：</strong></p><p>服务提供者的服务信息可以通过注册中心集群中任意一个获取到。</p><p><strong>服务续约renew</strong></p><p>服务提供者维持一个心跳用来持续告诉eureka server，防止被server从服务列表清除。</p><pre><code class="hljs yaml"><span class="hljs-comment"># 续约任务的调用隔离时间，默认30s</span><span class="hljs-string">eureka.instance.lease-renewal-interval-in-seconds=30</span><span class="hljs-comment"># 服务失效时间，默认90s</span><span class="hljs-string">eureka.instance.lease-expiration-duration-in-seconds=30</span></code></pre><h4 id="2）服务消费者"><a href="#2）服务消费者" class="headerlink" title="2）服务消费者"></a>2）服务消费者</h4><p><strong>获取服务：</strong></p><p>客户端通过rest请求，访问获取服务列表，eureka server会维护一份只读的服务清单返回给客户端</p><pre><code class="hljs yaml"><span class="hljs-comment"># 是否需要获取服务列表，默认为true，客户端需要开启</span><span class="hljs-string">eureka.client.fetch-registry=true</span><span class="hljs-comment"># 缓存清单的更新时间，默认30s</span><span class="hljs-string">eureka.client.registry-fetch-interval-seconds=30</span></code></pre><p><strong>服务调用：</strong></p><p>服务消费者在获取到服务清单到，通过服务名根据一定的策略选择一个服务实例进行调用。</p><p><strong>服务下线：</strong></p><p>客户端正常关闭时，会触发一个rest请求给server，server接收到该请求后，将该服务状态置为下线DOWN，并把该下线事件传播出去。</p><h4 id="3）服务注册中心"><a href="#3）服务注册中心" class="headerlink" title="3）服务注册中心"></a>3）服务注册中心</h4><p><strong>失效剔除：</strong></p><p>server在启动的时候会创建一个定时任务，默认每隔60s将服务清单中超时（默认90s）没有续约的服务剔除。</p><p><strong>自我保护：</strong></p><p>默认在15分钟内，若心跳失败的比例低于85%，server会将当前的服务实例清单保护起来，让这些实例不会过期。但是假设保护期内服务异常，客户端拿到失效的实例，就会出现调用失败的情况，所以客户端需要有容错机制。如请求重试、断路器机制。</p><pre><code class="hljs ini"><span class="hljs-comment"># 关闭保护机制</span><span class="hljs-attr">eureka.server.enable-self-preservation</span>=<span class="hljs-literal">false</span></code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;一、eureka是什么&quot;&gt;&lt;a href=&quot;#一、eureka是什么&quot; class=&quot;headerlink&quot; title=&quot;一、eureka是什么&quot;&gt;&lt;/a&gt;一、eureka是什么&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;服务治理可以说是微服务架构中核心的模块，它主要用来实现各
      
    
    </summary>
    
    
      <category term="springCloud" scheme="http://yoursite.com/categories/springCloud/"/>
    
    
      <category term="eureka" scheme="http://yoursite.com/tags/eureka/"/>
    
  </entry>
  
  <entry>
    <title>【并发】3大JUC工具类</title>
    <link href="http://yoursite.com/2020/06/07/%E3%80%90%E5%B9%B6%E5%8F%91%E3%80%913%E5%A4%A7JUC%E5%B7%A5%E5%85%B7%E7%B1%BB/"/>
    <id>http://yoursite.com/2020/06/07/%E3%80%90%E5%B9%B6%E5%8F%91%E3%80%913%E5%A4%A7JUC%E5%B7%A5%E5%85%B7%E7%B1%BB/</id>
    <published>2020-06-07T07:40:08.000Z</published>
    <updated>2020-06-07T10:33:45.445Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、减法计数器countDownLatch"><a href="#一、减法计数器countDownLatch" class="headerlink" title="一、减法计数器countDownLatch"></a>一、减法计数器countDownLatch</h2><p>CountDownLatch用于监听某些初始化操作，等待初始化执行完毕，通知主线程继续工作，允许一个或者多个线程等待其他线程完成操作。</p><p>通俗的讲就是<strong>实现线程等待</strong>，主线程<code>countDown.await();</code>进行阻塞，其他线程<code>countDown.countDown();</code>进行计数器-1操作，当计数器归零后，主线程唤醒继续操作。</p><blockquote><p> 要实现线程等待还有一个方法就是jion方法。Join用于让当前执行线程等待“Join线程”执行结束，实现原理是，不停的检查Join线程是否存活，如果存活则让当前线程永远等待下去，如果Join线程终止，则调用this.notifyAll方法唤醒等待的线程。</p></blockquote><blockquote><p>CountDownLatch其实也是来做这件事的，而且比Join更强大，使用起来也很轻便。</p></blockquote><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyCountDownLatch</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        CountDownLatch countDownLatch = <span class="hljs-keyword">new</span> CountDownLatch(<span class="hljs-number">2</span>);<span class="hljs-comment">// 线程a在执行后，经过await进行阻塞，当其他线程将countDownLatch减为0后，a继续执行</span>        <span class="hljs-keyword">new</span> Thread(()-&gt;&#123;            System.out.println(Thread.currentThread().getName() + <span class="hljs-string">"开始执行"</span>);            <span class="hljs-keyword">try</span> &#123;                countDownLatch.await();            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;                e.printStackTrace();            &#125;            System.out.println(Thread.currentThread().getName() + <span class="hljs-string">"执行完成"</span>);        &#125;, <span class="hljs-string">"a"</span>).start();        <span class="hljs-keyword">new</span> Thread(()-&gt;&#123;            System.out.println(Thread.currentThread().getName() + <span class="hljs-string">"开始执行"</span>);            countDownLatch.countDown();            System.out.println(Thread.currentThread().getName() + <span class="hljs-string">"执行完成"</span>);        &#125;, <span class="hljs-string">"b"</span>).start();        <span class="hljs-keyword">new</span> Thread(()-&gt;&#123;            System.out.println(Thread.currentThread().getName() + <span class="hljs-string">"开始执行"</span>);            countDownLatch.countDown();            System.out.println(Thread.currentThread().getName() + <span class="hljs-string">"执行完成"</span>);        &#125;, <span class="hljs-string">"c"</span>).start();    &#125;&#125;</code></pre><blockquote><p>CountDownLatch是通过一个计数器来实现的，当我们在new 一个CountDownLatch对象的时候需要带入该计数器值，该值就表示了线程的数量。每当一个线程完成自己的任务后，计数器的值就会减1。当计数器的值变为0时，就表示所有的线程均已经完成了任务，然后就可以恢复等待的线程继续执行了。</p></blockquote><h2 id="二、加法计数器Cyclicbarrier"><a href="#二、加法计数器Cyclicbarrier" class="headerlink" title="二、加法计数器Cyclicbarrier"></a>二、加法计数器Cyclicbarrier</h2><p>Cyclicbarrier指的是可循环使用的屏障，主要是让一组线程到达一个屏障之后被阻塞，当最后一个线程到达时，屏障才会开门，所有被屏障拦截的线程才会继续干活。</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyCyclicBarrier</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<span class="hljs-comment">//        CyclicBarrier cyclicBarrier = new CyclicBarrier(5);</span>        <span class="hljs-comment">// 线程都ready后，会先执行该 barrierAction ，再执行各子线程的下一步任务</span>        CyclicBarrier cyclicBarrier = <span class="hljs-keyword">new</span> CyclicBarrier(<span class="hljs-number">5</span>, ()-&gt; System.out.println(<span class="hljs-string">"all is ready"</span>));        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++) &#123;            <span class="hljs-keyword">new</span> Thread(()-&gt;&#123;                System.out.println(Thread.currentThread().getName()+<span class="hljs-string">" is ready"</span>);<span class="hljs-comment">//                int numberWaiting = cyclicBarrier.getNumberWaiting();</span>                <span class="hljs-keyword">try</span> &#123;                    cyclicBarrier.await();                &#125; <span class="hljs-keyword">catch</span> (InterruptedException | BrokenBarrierException e) &#123;                    e.printStackTrace();                &#125;                System.out.println(Thread.currentThread().getName()+<span class="hljs-string">" is going"</span>);            &#125;, <span class="hljs-string">"线程"</span>+i).start();        &#125;        System.out.println(<span class="hljs-string">"this is main"</span>);    &#125;&#125;</code></pre><h3 id="1、区别"><a href="#1、区别" class="headerlink" title="1、区别"></a>1、区别</h3><ul><li>CountDownLatch的计数器只能使用一次。而CyclicBarrier的计数器可以使用reset() 方法重置。</li><li>CountDownLatch的作用是允许1或N个线程等待其他线程完成执行；而CyclicBarrier则是允许N个线程相互等待。</li><li>CountDownLatch的计数器无法被重置；CyclicBarrier的计数器可以被重置后使用，因此它被称为是循环的barrier。</li></ul><h3 id="2、使用场景"><a href="#2、使用场景" class="headerlink" title="2、使用场景"></a>2、使用场景</h3><ul><li>确保某个计算在其需要的所有的资源都被初始化之后才继续执行。</li><li>确保某个服务在其依赖的所有其他服务都已经启动之后才启动。</li><li>等待直到某个操作所有参与者都准备就绪再继续执行。</li></ul><p><a href="https://www.javazhiyin.com/14737.html" target="_blank" rel="noopener">J.U.C之并发工具类：CyclicBarrier</a></p><p><a href="https://www.javazhiyin.com/14681.html" target="_blank" rel="noopener">J.U.C之并发工具类：CountDownLatch</a></p><h2 id="三、信号量semaphore"><a href="#三、信号量semaphore" class="headerlink" title="三、信号量semaphore"></a>三、信号量semaphore</h2><ul><li>信号量维护了一个许可集，线程通过acquire()获得许可，在达到许可上限时，会阻塞其他acquire()的线程。已获得许可的线程进行 release() 后，被阻塞的线程才可获得许可。</li><li>信号量，一般用于限流，或者限制访问某些资源的线程数目。</li><li>Semaphore默认选择非公平锁。可通过构造函数传入true，声明为公平锁。</li><li>当信号量Semaphore = 1 时，它可以当作互斥锁使用。其中0、1就相当于它的状态，当=1时表示其他线程可以获取，当=0时，排他，即其他线程必须要等待。</li></ul><pre><code class="hljs livescript">public <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MySemaphore</span> &#123;</span>    public static <span class="hljs-literal">void</span> main(String[] args) &#123;        Semaphore semaphore = <span class="hljs-keyword">new</span> Semaphore(<span class="hljs-number">3</span>);        <span class="hljs-keyword">for</span> (int i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;            <span class="hljs-keyword">new</span> Thread<span class="hljs-function"><span class="hljs-params">(()-&gt;&#123;</span></span><span class="hljs-function"><span class="hljs-params">                <span class="hljs-keyword">try</span> &#123;</span></span><span class="hljs-function"><span class="hljs-params">                    semaphore.acquire();</span></span><span class="hljs-function"><span class="hljs-params">                    System.out.println(Thread.currentThread().getName()+<span class="hljs-string">"进行占位"</span>);</span></span><span class="hljs-function"><span class="hljs-params">                    TimeUnit.SECONDS.sleep(<span class="hljs-number">1</span>);</span></span><span class="hljs-function"><span class="hljs-params">                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;</span></span><span class="hljs-function"><span class="hljs-params">                    e.printStackTrace();</span></span><span class="hljs-function"><span class="hljs-params">                &#125; <span class="hljs-keyword">finally</span> &#123;</span></span><span class="hljs-function"><span class="hljs-params">                    semaphore.release();</span></span><span class="hljs-function"><span class="hljs-params">                    System.out.println(Thread.currentThread().getName()+<span class="hljs-string">"释放位置"</span>);</span></span><span class="hljs-function"><span class="hljs-params">                &#125;</span></span><span class="hljs-function"><span class="hljs-params">            &#125;, <span class="hljs-string">"thread-"</span>+i)</span>.<span class="hljs-title">start</span><span class="hljs-params">()</span>;</span><span class="hljs-function">        &#125;</span><span class="hljs-function"></span><span class="hljs-function">    &#125;</span><span class="hljs-function">&#125;</span></code></pre><p><a href="https://www.javazhiyin.com/14648.html" target="_blank" rel="noopener">J.U.C之并发工具类：Semaphore</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;一、减法计数器countDownLatch&quot;&gt;&lt;a href=&quot;#一、减法计数器countDownLatch&quot; class=&quot;headerlink&quot; title=&quot;一、减法计数器countDownLatch&quot;&gt;&lt;/a&gt;一、减法计数器countDownLatch&lt;/
      
    
    </summary>
    
    
      <category term="java" scheme="http://yoursite.com/categories/java/"/>
    
    
      <category term="thread" scheme="http://yoursite.com/tags/thread/"/>
    
  </entry>
  
  <entry>
    <title>【并发】阻塞队列（BlockingQueue）</title>
    <link href="http://yoursite.com/2020/06/07/%E3%80%90%E5%B9%B6%E5%8F%91%E3%80%91%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97/"/>
    <id>http://yoursite.com/2020/06/07/%E3%80%90%E5%B9%B6%E5%8F%91%E3%80%91%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97/</id>
    <published>2020-06-07T01:43:26.000Z</published>
    <updated>2020-06-07T07:41:03.947Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、什么是阻塞队列"><a href="#一、什么是阻塞队列" class="headerlink" title="一、什么是阻塞队列"></a>一、什么是阻塞队列</h2><p>阻塞队列是一种特殊的支持阻塞的插入和移除的特殊容器。</p><p>阻塞插入：</p><ul><li>当队列满时，向队列中插入元素的线程会被阻塞，直到队列中有元素被移除。</li><li>即队列不满时，才能插入元素，否则阻塞。</li></ul><p>阻塞移除：</p><ul><li>当队列为空时，从队列中移除数据的线程会被阻塞，直到队列中有新的元素被添加。</li><li>即队列不为空时，才能取出元素，否则阻塞。</li></ul><h2 id="二、常见方法"><a href="#二、常见方法" class="headerlink" title="二、常见方法"></a>二、常见方法</h2><table><thead><tr><th>方法</th><th>备注</th></tr></thead><tbody><tr><td>add/remove</td><td>增删元素，失败抛出异常</td></tr><tr><td>offer/poll</td><td>增删元素，可设置等待时间，失败或超时返回false</td></tr><tr><td>put/take</td><td>增删元素，一直等待</td></tr></tbody></table><h2 id="三、常见阻塞队列"><a href="#三、常见阻塞队列" class="headerlink" title="三、常见阻塞队列"></a>三、常见阻塞队列</h2><p><code>BlockingQueue</code>是一个接口，主要有下面7种实现类：</p><table><thead><tr><th>实现</th><th>备注</th></tr></thead><tbody><tr><td>ArrayBlockingQueue</td><td>基于数组的阻塞队列实现，在其内部，维护了一个定长数组，以便缓存队列中的数据对象；<br>其内部没实现读写分离，也就意味着生产和消费不能完全并行；<br>长度是需要自己定义的，可以指定先进先出或者先进后出，也被称为“有界队列”</td></tr><tr><td>LinkedBlockingQueue</td><td>基于链表的阻塞队列，其内部维持着一个数据缓冲队列（该队列由一个链表构成）；<br>LinkedBlockingQueue之所以能够高效的处理并发数据，是因为其内部实现采用分离锁（读写分离两个锁），从而实现生产者和消费者操作完全并发执行，也是一个“无界队列”</td></tr><tr><td>PriorityBlockingQueue</td><td>基于优先级的阻塞队列（优先级的判断通过构造函数传入的Compator（比较器）对象决定，也就是说传入队列的对象必须实现Comparable接口），<br>在实现PriorityBlockingQueue时，内部控制线程同步的锁采用的是公平锁，是一个“无界队列”<br>PriorityBlockingQueue调用take后需要重新排序，调一次重新排一次</td></tr><tr><td>DelayQueue</td><td>带有延迟时间的无界阻塞Queue，其中的元素只有当指定的延迟时间到了，才能够从队列中获取该元素。<br>DelayQueue中的元素必须实现Delayed接口，DelayQueue是一个没有大小限制的队列，<br>应用场景比较多，比如对缓存超时的数据进行移除，任务超时处理，空间连接的关闭等等</td></tr><tr><td>SynchronousQueue</td><td>不存储任何元素的队列，生产者产生的数据直接会被消费者获取并消费，<br>即每一个put操作必须等待一个take操作，否则不能继续添加元素，<br>或者可以理解为是只能存储一个元素的队列，存一个就满了，该元素必须被移除掉，才能继续添加</td></tr><tr><td>LinkedTransferQueue</td><td>一个由链表结构组成的无界阻塞传输队列，主要体现在LinkedTransferQueue多2个方法<br>transfer(E)：如果当前有消费者正在等待消费，则生产者直接把元素传输给消费者，如果当前没有消费者正在等待消费，则生产者将元素存放在队列的tail节点上，并等到该元素被消费才返回（采用自旋等待）；<br>tryTransfer(E,long,TimeUnit)：将元素立刻给消费者，如果没有消费者就等待指定时间。时间到时，如果还没有消费者则失败返回false；</td></tr><tr><td>LinkedBlockingDeque</td><td>由链表结构组成的双向阻塞队列，即可以从队列的两端插入和移出元素</td></tr></tbody></table><h2 id="四、阻塞队列的底层实现"><a href="#四、阻塞队列的底层实现" class="headerlink" title="四、阻塞队列的底层实现"></a>四、阻塞队列的底层实现</h2><p>阻塞队列的底层是<strong>等待通知机制</strong>来实现的：</p><p>当生产者往一个满队列中添加元素时，生产者会被阻塞；等消费者从该队列中消费了一个元素后，会通知阻塞的插入操作的生产者线程，可以继续执行添加操作。</p><p>当消费者从一个空队列中移除元素时，消费者会被阻塞；等生产者向队列中增加了一个元素后，会通知阻塞的移除操作的消费者线程，可以继续执行移除操作。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;一、什么是阻塞队列&quot;&gt;&lt;a href=&quot;#一、什么是阻塞队列&quot; class=&quot;headerlink&quot; title=&quot;一、什么是阻塞队列&quot;&gt;&lt;/a&gt;一、什么是阻塞队列&lt;/h2&gt;&lt;p&gt;阻塞队列是一种特殊的支持阻塞的插入和移除的特殊容器。&lt;/p&gt;
&lt;p&gt;阻塞插入：&lt;/p
      
    
    </summary>
    
    
      <category term="java" scheme="http://yoursite.com/categories/java/"/>
    
    
      <category term="thread blockingQueue" scheme="http://yoursite.com/tags/thread-blockingQueue/"/>
    
  </entry>
  
  <entry>
    <title>【并发】生产者消费者</title>
    <link href="http://yoursite.com/2020/06/05/%E3%80%90%E5%B9%B6%E5%8F%91%E3%80%91%E7%94%9F%E4%BA%A7%E8%80%85%E6%B6%88%E8%B4%B9%E8%80%85/"/>
    <id>http://yoursite.com/2020/06/05/%E3%80%90%E5%B9%B6%E5%8F%91%E3%80%91%E7%94%9F%E4%BA%A7%E8%80%85%E6%B6%88%E8%B4%B9%E8%80%85/</id>
    <published>2020-06-05T13:44:03.000Z</published>
    <updated>2020-06-07T07:40:54.141Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、生产者消费者"><a href="#一、生产者消费者" class="headerlink" title="一、生产者消费者"></a>一、生产者消费者</h2><p>生产者和消费者在同一时间段内共用同一段存储空间，生产者put数据，消费者take数据</p><p>阻塞队列就相当于一个缓冲区，平衡了生产者和消费者的处理能力，将他们解耦。</p><h2 id="二、四种实现生产者消费者模型"><a href="#二、四种实现生产者消费者模型" class="headerlink" title="二、四种实现生产者消费者模型"></a>二、四种实现生产者消费者模型</h2><h3 id="1、Object的wait-notify-方法"><a href="#1、Object的wait-notify-方法" class="headerlink" title="1、Object的wait() / notify()方法"></a>1、Object的wait() / notify()方法</h3><p>wait/notify 是Object的方法，因此我们可以给任何对象实现同步机制。</p><p>wait：当缓冲区满时，生产者/消费者放弃锁，让度cpu，使自己处于等待状态。</p><p>notify：当生产者/消费者 生产/消费 时，放弃锁，向其他线程发出可执行的通知，使自己处于等待状态。</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ProducerConsumer</span> </span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> CAPACITY = <span class="hljs-number">5</span>;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Queue&lt;Integer&gt; queue = <span class="hljs-keyword">new</span> LinkedList&lt;Integer&gt;();    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        <span class="hljs-comment">// 模拟生产者</span>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">3</span>; i++) &#123;            <span class="hljs-keyword">new</span> Thread(()-&gt; produce(),<span class="hljs-string">"procuder-"</span>+ i).start();        &#125;        <span class="hljs-comment">// 模拟消费者</span>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++) &#123;            <span class="hljs-keyword">new</span> Thread(()-&gt; consume(),<span class="hljs-string">"consumer-"</span>+ i).start();        &#125;        <span class="hljs-comment">// 主线程睡眠，便于看效果</span>        <span class="hljs-keyword">try</span> &#123;            TimeUnit.SECONDS.sleep(<span class="hljs-number">2</span>);        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;            e.printStackTrace();        &#125;        System.exit(<span class="hljs-number">0</span>);    &#125;    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">consume</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>) &#123;            <span class="hljs-keyword">synchronized</span> (queue) &#123;                <span class="hljs-keyword">while</span> (queue.isEmpty()) &#123;                    <span class="hljs-keyword">try</span> &#123;                        <span class="hljs-comment">// 空队列，则不能消费</span>                        System.out.println(Thread.currentThread().getName() + <span class="hljs-string">" 等待生产"</span>);                        queue.wait();                    &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;                        e.printStackTrace();                    &#125;                &#125;                <span class="hljs-comment">// 队列不为空，则正常消费</span>                Integer poll = queue.poll();                System.out.println(Thread.currentThread().getName() + <span class="hljs-string">" 消费了"</span> + poll);                queue.notifyAll();                <span class="hljs-comment">// 线程睡眠，便于看效果</span>                <span class="hljs-keyword">try</span> &#123;                    TimeUnit.MILLISECONDS.sleep(<span class="hljs-number">100</span>);                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;                    e.printStackTrace();                &#125;            &#125;        &#125;    &#125;    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">produce</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">int</span> k = <span class="hljs-number">0</span>;        <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>) &#123;            <span class="hljs-keyword">synchronized</span> (queue) &#123;                <span class="hljs-keyword">while</span> (queue.size() == CAPACITY) &#123;                    <span class="hljs-keyword">try</span> &#123;                        <span class="hljs-comment">// 满了则wait</span>                        System.out.println(Thread.currentThread().getName() + <span class="hljs-string">" 等待消费"</span>);                        queue.wait();                    &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;                        e.printStackTrace();                    &#125;                &#125;                <span class="hljs-comment">// 没满则往queue中添加元素</span>                System.out.println(Thread.currentThread().getName() + <span class="hljs-string">" 生产了"</span> + k);                queue.offer(k++);                queue.notifyAll();                <span class="hljs-comment">// 线程睡眠，便于看效果</span>                <span class="hljs-keyword">try</span> &#123;                    TimeUnit.MILLISECONDS.sleep(<span class="hljs-number">100</span>);                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;                    e.printStackTrace();                &#125;            &#125;        &#125;    &#125;&#125;</code></pre><blockquote><p>使用while进行size=queueSize、isEmpty的判断，使用if会造成虚假唤醒。</p></blockquote><h3 id="2、Lock中condition的await-signal-方法"><a href="#2、Lock中condition的await-signal-方法" class="headerlink" title="2、Lock中condition的await()/signal()方法"></a>2、Lock中condition的await()/signal()方法</h3><p>通过在lock对象上调用newCondition()，将变量和锁对象进行绑定，进而控制并发资源的安全。</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LockCondition</span> </span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> CAPACITY = <span class="hljs-number">5</span>;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> ReentrantLock lock = <span class="hljs-keyword">new</span> ReentrantLock();    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Condition fullCondition = lock.newCondition();    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Condition emptyCondition = lock.newCondition();    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Queue&lt;Integer&gt; queue = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">3</span>; i++) &#123;            <span class="hljs-keyword">new</span> Thread(() -&gt; produce(), <span class="hljs-string">"product-"</span> + i).start();        &#125;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">3</span>; i++) &#123;            <span class="hljs-keyword">new</span> Thread(() -&gt; consume(), <span class="hljs-string">"consumer-"</span> + i).start();        &#125;        <span class="hljs-comment">// 主线程睡眠，便于看效果</span>        <span class="hljs-keyword">try</span> &#123;            TimeUnit.SECONDS.sleep(<span class="hljs-number">2</span>);        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;            e.printStackTrace();        &#125;        System.exit(<span class="hljs-number">0</span>);    &#125;    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">consume</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>) &#123;            <span class="hljs-keyword">if</span> (lock.tryLock()) &#123;                <span class="hljs-keyword">try</span> &#123;                    <span class="hljs-keyword">while</span> (queue.isEmpty()) &#123;                        <span class="hljs-comment">// 队列为空，释放锁，通知生产者去生产</span>                        System.out.println(Thread.currentThread().getName() + <span class="hljs-string">" 队列为空，等待生产"</span>);                        emptyCondition.await();                    &#125;                    Integer poll = queue.poll();                    System.out.println(Thread.currentThread().getName() + <span class="hljs-string">" 消费了 "</span> + poll);                    <span class="hljs-comment">//唤醒其他所有生产者、消费者</span>                    fullCondition.signalAll();                    emptyCondition.signalAll();                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;                    e.printStackTrace();                &#125; <span class="hljs-keyword">finally</span> &#123;                    <span class="hljs-keyword">if</span> (lock.isHeldByCurrentThread()) &#123;                        lock.unlock();                    &#125;                &#125;            &#125;            <span class="hljs-comment">// 线程睡眠，便于看效果</span>            <span class="hljs-keyword">try</span> &#123;                TimeUnit.MILLISECONDS.sleep(<span class="hljs-keyword">new</span> Random().nextInt(<span class="hljs-number">100</span>));            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;                e.printStackTrace();            &#125;        &#125;    &#125;    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">produce</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>) &#123;            <span class="hljs-keyword">int</span> k = <span class="hljs-number">0</span>;            <span class="hljs-keyword">if</span> (lock.tryLock()) &#123;                <span class="hljs-keyword">try</span> &#123;                    <span class="hljs-keyword">while</span> (queue.size() == CAPACITY) &#123;                        <span class="hljs-comment">// 队列满了，释放锁，通知消费者去消费</span>                        System.out.println(Thread.currentThread().getName() + <span class="hljs-string">" 队列满了，等待消费"</span>);                        fullCondition.await();                    &#125;                    System.out.println(Thread.currentThread().getName() + <span class="hljs-string">" 生产了"</span> + k);                    queue.offer(k++);                    <span class="hljs-comment">//唤醒其他所有生产者、消费者</span>                    emptyCondition.signalAll();                    fullCondition.signalAll();                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;                    e.printStackTrace();                &#125; <span class="hljs-keyword">finally</span> &#123;                    <span class="hljs-keyword">if</span> (lock.isHeldByCurrentThread()) &#123;                        lock.unlock();                    &#125;                &#125;            &#125;            <span class="hljs-comment">// 线程睡眠，便于看效果</span>            <span class="hljs-keyword">try</span> &#123;                TimeUnit.MILLISECONDS.sleep(<span class="hljs-keyword">new</span> Random().nextInt(<span class="hljs-number">100</span>));            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;                e.printStackTrace();            &#125;        &#125;    &#125;&#125;</code></pre><blockquote><p><strong>await和signal需组合使用</strong>。在案例中阻塞时用了await，但是唤醒时用的notify，导致运行过程中一直报错<code>IllegalMonitorStateException</code></p></blockquote><h3 id="3、使用blockQueue阻塞队列方法"><a href="#3、使用blockQueue阻塞队列方法" class="headerlink" title="3、使用blockQueue阻塞队列方法"></a>3、使用blockQueue阻塞队列方法</h3><p>jdk对2方式的一种封装，可直接使用。</p><p>在juc下，有ArrayBlockingQueue、LinkedBlockingQueue、SynchronousQueue、PriorityBlockingQueue四种实现。</p><p>实现生产者-消费者模型使用 ArrayBlockingQueue或者 LinkedBlockingQueue即可。</p><pre><code class="hljs livescript">public <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyBlockingQueue</span> &#123;</span>    private static final int CAPICITY = <span class="hljs-number">3</span>;    private static final int MAX = <span class="hljs-number">30</span>;    private static final LinkedBlockingQueue&lt;Integer&gt; queue = <span class="hljs-keyword">new</span> LinkedBlockingQueue&lt;&gt;(CAPICITY);    public static <span class="hljs-literal">void</span> main(String[] args) &#123;        <span class="hljs-keyword">for</span> (int i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">3</span>; i++) &#123;            <span class="hljs-keyword">new</span> Thread<span class="hljs-function"><span class="hljs-params">(() -&gt; produce(), <span class="hljs-string">"product-"</span> + i)</span>.<span class="hljs-title">start</span><span class="hljs-params">()</span>;</span><span class="hljs-function">        &#125;</span><span class="hljs-function"></span><span class="hljs-function">        <span class="hljs-title">for</span> <span class="hljs-params">(int i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">3</span>; i++)</span> &#123;</span><span class="hljs-function">            <span class="hljs-title">new</span> <span class="hljs-title">Thread</span><span class="hljs-params">(() -&gt; consume(), <span class="hljs-string">"consumer-"</span> + i)</span>.<span class="hljs-title">start</span><span class="hljs-params">()</span>;</span><span class="hljs-function">        &#125;</span><span class="hljs-function"></span><span class="hljs-function">        // 主线程睡眠，便于看效果</span><span class="hljs-function">        <span class="hljs-title">try</span> &#123;</span><span class="hljs-function">            <span class="hljs-title">TimeUnit</span>.<span class="hljs-title">SECONDS</span>.<span class="hljs-title">sleep</span><span class="hljs-params">(<span class="hljs-number">2</span>)</span>;</span><span class="hljs-function">        &#125; <span class="hljs-title">catch</span> <span class="hljs-params">(InterruptedException e)</span> &#123;</span><span class="hljs-function">            <span class="hljs-title">e</span>.<span class="hljs-title">printStackTrace</span><span class="hljs-params">()</span>;</span><span class="hljs-function">        &#125;</span><span class="hljs-function"></span><span class="hljs-function">        <span class="hljs-title">System</span>.<span class="hljs-title">exit</span><span class="hljs-params">(<span class="hljs-number">0</span>)</span>;</span><span class="hljs-function">    &#125;</span><span class="hljs-function"></span><span class="hljs-function">    <span class="hljs-title">static</span> <span class="hljs-title">void</span> <span class="hljs-title">produce</span><span class="hljs-params">()</span> &#123;</span><span class="hljs-function">        <span class="hljs-title">int</span> <span class="hljs-title">k</span> = 0;</span><span class="hljs-function">        <span class="hljs-title">while</span> <span class="hljs-params">(k &lt; MAX)</span> &#123;</span><span class="hljs-function">            <span class="hljs-title">try</span> &#123;</span><span class="hljs-function">                <span class="hljs-title">System</span>.<span class="hljs-title">out</span>.<span class="hljs-title">println</span><span class="hljs-params">(Thread.currentThread().getName() + <span class="hljs-string">" 生产了"</span> + k)</span>;</span><span class="hljs-function">                <span class="hljs-title">queue</span>.<span class="hljs-title">put</span><span class="hljs-params">(k++)</span>;</span><span class="hljs-function">            &#125; <span class="hljs-title">catch</span> <span class="hljs-params">(InterruptedException e)</span> &#123;</span><span class="hljs-function">                <span class="hljs-title">e</span>.<span class="hljs-title">printStackTrace</span><span class="hljs-params">()</span>;</span><span class="hljs-function">            &#125;</span><span class="hljs-function"></span><span class="hljs-function">            // 线程睡眠，便于看效果</span><span class="hljs-function">            <span class="hljs-title">try</span> &#123;</span><span class="hljs-function">                <span class="hljs-title">TimeUnit</span>.<span class="hljs-title">MILLISECONDS</span>.<span class="hljs-title">sleep</span><span class="hljs-params">(<span class="hljs-keyword">new</span> Random().nextInt(<span class="hljs-number">100</span>))</span>;</span><span class="hljs-function">            &#125; <span class="hljs-title">catch</span> <span class="hljs-params">(InterruptedException e)</span> &#123;</span><span class="hljs-function">                <span class="hljs-title">e</span>.<span class="hljs-title">printStackTrace</span><span class="hljs-params">()</span>;</span><span class="hljs-function">            &#125;</span><span class="hljs-function">        &#125;</span><span class="hljs-function">    &#125;</span><span class="hljs-function"></span><span class="hljs-function">    <span class="hljs-title">static</span> <span class="hljs-title">void</span> <span class="hljs-title">consume</span><span class="hljs-params">()</span> &#123;</span><span class="hljs-function">        <span class="hljs-title">while</span> <span class="hljs-params">(<span class="hljs-literal">true</span>)</span> &#123;</span><span class="hljs-function">            <span class="hljs-title">try</span> &#123;</span><span class="hljs-function">                <span class="hljs-title">Integer</span> <span class="hljs-title">take</span> = <span class="hljs-title">queue</span>.<span class="hljs-title">take</span><span class="hljs-params">()</span>;</span><span class="hljs-function">                <span class="hljs-title">System</span>.<span class="hljs-title">out</span>.<span class="hljs-title">println</span><span class="hljs-params">(Thread.currentThread().getName() + <span class="hljs-string">"消费了"</span> + take)</span>;</span><span class="hljs-function">            &#125; <span class="hljs-title">catch</span> <span class="hljs-params">(InterruptedException e)</span> &#123;</span><span class="hljs-function">                <span class="hljs-title">e</span>.<span class="hljs-title">printStackTrace</span><span class="hljs-params">()</span>;</span><span class="hljs-function">            &#125;</span><span class="hljs-function"></span><span class="hljs-function">            // 线程睡眠，便于看效果</span><span class="hljs-function">            <span class="hljs-title">try</span> &#123;</span><span class="hljs-function">                <span class="hljs-title">TimeUnit</span>.<span class="hljs-title">MILLISECONDS</span>.<span class="hljs-title">sleep</span><span class="hljs-params">(<span class="hljs-keyword">new</span> Random().nextInt(<span class="hljs-number">100</span>))</span>;</span><span class="hljs-function">            &#125; <span class="hljs-title">catch</span> <span class="hljs-params">(InterruptedException e)</span> &#123;</span><span class="hljs-function">                <span class="hljs-title">e</span>.<span class="hljs-title">printStackTrace</span><span class="hljs-params">()</span>;</span><span class="hljs-function">            &#125;</span><span class="hljs-function"></span><span class="hljs-function">        &#125;</span><span class="hljs-function">    &#125;</span><span class="hljs-function"></span><span class="hljs-function">&#125;</span></code></pre><blockquote><p><code>put()</code>方法：类似于我们上面的生产者线程，容量达到最大时，自动阻塞。</p></blockquote><blockquote><p><code>take()</code>方法：类似于我们上面的消费者线程，容量为0时，自动阻塞。</p></blockquote><h2 id="4、PipedInputStream-PipedOutputStream"><a href="#4、PipedInputStream-PipedOutputStream" class="headerlink" title="4、PipedInputStream / PipedOutputStream"></a>4、<strong>PipedInputStream</strong> / PipedOutputStream</h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;一、生产者消费者&quot;&gt;&lt;a href=&quot;#一、生产者消费者&quot; class=&quot;headerlink&quot; title=&quot;一、生产者消费者&quot;&gt;&lt;/a&gt;一、生产者消费者&lt;/h2&gt;&lt;p&gt;生产者和消费者在同一时间段内共用同一段存储空间，生产者put数据，消费者take数据&lt;/p&gt;
      
    
    </summary>
    
    
      <category term="java" scheme="http://yoursite.com/categories/java/"/>
    
    
      <category term="thread queue" scheme="http://yoursite.com/tags/thread-queue/"/>
    
  </entry>
  
  <entry>
    <title>springboot自定义starter</title>
    <link href="http://yoursite.com/2020/06/03/springboot%E8%87%AA%E5%AE%9A%E4%B9%89starter/"/>
    <id>http://yoursite.com/2020/06/03/springboot%E8%87%AA%E5%AE%9A%E4%B9%89starter/</id>
    <published>2020-06-03T14:46:40.000Z</published>
    <updated>2020-06-03T15:02:44.539Z</updated>
    
    <content type="html"><![CDATA[<h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>按照约定，官方的为spring-boot-xxx-starter ，非官方的为 xxx-spring-boot-starter</p><h2 id="一、Spring-Boot-starter机制"><a href="#一、Spring-Boot-starter机制" class="headerlink" title="一、Spring Boot starter机制"></a>一、Spring Boot starter机制</h2><ul><li><p>Spring Boot中的starter是一种非常重要的机制，应用者只需要在maven中引入starter依赖，Spring Boot就能自动扫描到要加载的信息并启动相应的默认配置。</p></li><li><p>starter让我们摆脱了各种依赖库的处理，需要配置各种信息的困扰。</p></li><li><p>Spring Boot会自动通过classpath路径下的类发现需要的Bean，并注册进IOC容器。</p></li><li><p>Spring Boot提供了针对日常企业应用研发各种场景的spring-boot-starter依赖模块。所有这些依赖模块都遵循着约定成俗的默认配置，并允许我们调整这些配置，即遵循“约定大于配置”的理念。</p></li></ul><h2 id="二、自定义starter的条件"><a href="#二、自定义starter的条件" class="headerlink" title="二、自定义starter的条件"></a>二、自定义starter的条件</h2><p>如果想自定义Starter，首选需要实现自动化配置，而要实现自动化配置需要满足以下两个条件：</p><ol><li>能够自动配置项目所需要的配置信息，也就是自动加载依赖环境；</li><li>能够根据项目提供的信息自动生成Bean，并且注册到Bean管理容器中；</li></ol><h2 id="三、自定义starter代码部分"><a href="#三、自定义starter代码部分" class="headerlink" title="三、自定义starter代码部分"></a>三、自定义starter代码部分</h2><h3 id="1、pom文件"><a href="#1、pom文件" class="headerlink" title="1、pom文件"></a>1、pom文件</h3><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">project</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">"http://maven.apache.org/POM/4.0.0"</span></span><span class="hljs-tag">         <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">"http://www.w3.org/2001/XMLSchema-instance"</span></span><span class="hljs-tag">         <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">modelVersion</span>&gt;</span>4.0.0<span class="hljs-tag">&lt;/<span class="hljs-name">modelVersion</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.ztf<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>orange-spring-boot-starter<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.0-SNAPSHOT<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span>        <span class="hljs-comment">&lt;!-- https://mvnrepository.com/artifact/org.springframework.boot/spring-boot-autoconfigure --&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-autoconfigure<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.3.0.RELEASE<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-configuration-processor<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.3.0.RELEASE<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>            <span class="hljs-comment">&lt;!--该依赖只能在本项目中传递，不会传递到引用该项目的父项目中，父项目有需要需主动引用该依赖。--&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">optional</span>&gt;</span>true<span class="hljs-tag">&lt;/<span class="hljs-name">optional</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.projectlombok<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>lombok<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.18.6<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">optional</span>&gt;</span>true<span class="hljs-tag">&lt;/<span class="hljs-name">optional</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">project</span>&gt;</span></code></pre><h3 id="2、定义XxxProperties-属性配置类，"><a href="#2、定义XxxProperties-属性配置类，" class="headerlink" title="2、定义XxxProperties 属性配置类，"></a>2、定义XxxProperties 属性配置类，</h3><ul><li>设置属性前缀，用于在application.properties中配置。</li></ul><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.ztf;<span class="hljs-keyword">import</span> lombok.Data;<span class="hljs-keyword">import</span> org.springframework.boot.context.properties.ConfigurationProperties;<span class="hljs-meta">@ConfigurationProperties</span>(prefix = <span class="hljs-string">"local.orange"</span>)<span class="hljs-meta">@Data</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyProperties</span> </span>&#123;    <span class="hljs-keyword">private</span> String id;    <span class="hljs-keyword">private</span> String name;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> age;&#125;</code></pre><h3 id="3、定义XxxService逻辑操作类"><a href="#3、定义XxxService逻辑操作类" class="headerlink" title="3、定义XxxService逻辑操作类"></a>3、定义XxxService逻辑操作类</h3><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.ztf;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyService</span> </span>&#123;    MyProperties myProperties;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setMyProperties</span><span class="hljs-params">(MyProperties myProperties)</span> </span>&#123;        <span class="hljs-keyword">this</span>.myProperties = myProperties;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">MyService</span><span class="hljs-params">(MyProperties myProperties)</span> </span>&#123;        <span class="hljs-keyword">this</span>.myProperties = myProperties;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">helloWorld</span><span class="hljs-params">()</span> </span>&#123;        System.out.println(<span class="hljs-string">"hi, 我叫: "</span> + myProperties.getName() +                <span class="hljs-string">", id:"</span> + myProperties.getId() + <span class="hljs-string">"岁"</span>                + <span class="hljs-string">", 年龄: "</span> + myProperties.getAge());    &#125;&#125;</code></pre><h3 id="4、定义XxxAutoConfiguration自动配置类"><a href="#4、定义XxxAutoConfiguration自动配置类" class="headerlink" title="4、定义XxxAutoConfiguration自动配置类"></a>4、定义XxxAutoConfiguration自动配置类</h3><ul><li>用于完成Bean创建等工作。</li></ul><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.ztf;<span class="hljs-keyword">import</span> org.springframework.beans.factory.annotation.Autowired;<span class="hljs-keyword">import</span> org.springframework.boot.autoconfigure.condition.ConditionalOnClass;<span class="hljs-keyword">import</span> org.springframework.boot.autoconfigure.condition.ConditionalOnMissingBean;<span class="hljs-keyword">import</span> org.springframework.boot.autoconfigure.condition.ConditionalOnProperty;<span class="hljs-keyword">import</span> org.springframework.boot.context.properties.EnableConfigurationProperties;<span class="hljs-keyword">import</span> org.springframework.context.annotation.Bean;<span class="hljs-keyword">import</span> org.springframework.context.annotation.Configuration;<span class="hljs-meta">@Configuration</span><span class="hljs-meta">@EnableConfigurationProperties</span>(MyProperties<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span><span class="hljs-class">@<span class="hljs-title">ConditionalOnClass</span>(<span class="hljs-title">MyService</span>.<span class="hljs-title">class</span>)</span><span class="hljs-class">@<span class="hljs-title">ConditionalOnProperty</span>(<span class="hljs-title">prefix</span> </span>= <span class="hljs-string">"local.orange"</span>, value = <span class="hljs-string">"enabled"</span>, matchIfMissing = <span class="hljs-keyword">true</span>)<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyServiceAutoConfiguration</span> </span>&#123;    <span class="hljs-meta">@Autowired</span>    MyProperties myProperties;    <span class="hljs-meta">@Bean</span>    <span class="hljs-meta">@ConditionalOnMissingBean</span>(MyService<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span><span class="hljs-class">    <span class="hljs-title">public</span> <span class="hljs-title">MyService</span> <span class="hljs-title">myService</span>() </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> MyService(myProperties);    &#125;&#125;</code></pre><h3 id="5、在spring-factories中声明"><a href="#5、在spring-factories中声明" class="headerlink" title="5、在spring.factories中声明"></a>5、在spring.factories中声明</h3><ul><li><p>在resources下创建目录META-INF，在 META-INF 目录下创建 spring.factories，在SpringBoot启动时会根据此文件来加载项目的自动化配置类。</p></li><li><p>spring.factories内容如下：</p></li></ul><pre><code class="hljs java">org.springframework.boot.autoconfigure.EnableAutoConfiguration=com.ztf.MyServiceAutoConfiguration</code></pre><h2 id="四、自定义starter使用"><a href="#四、自定义starter使用" class="headerlink" title="四、自定义starter使用"></a>四、自定义starter使用</h2><h3 id="1、pom中引用自定义starter的jar"><a href="#1、pom中引用自定义starter的jar" class="headerlink" title="1、pom中引用自定义starter的jar"></a>1、pom中引用自定义starter的jar</h3><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.ztf<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>orange-spring-boot-starter<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.0-SNAPSHOT<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre><h3 id="2、yml配置文件中声明参数"><a href="#2、yml配置文件中声明参数" class="headerlink" title="2、yml配置文件中声明参数"></a>2、yml配置文件中声明参数</h3><pre><code class="hljs yaml"><span class="hljs-comment">## 自定义的一个starter</span><span class="hljs-attr">local:</span>  <span class="hljs-attr">orange:</span>    <span class="hljs-attr">id:</span> <span class="hljs-number">007</span>    <span class="hljs-attr">name:</span> <span class="hljs-string">myorange</span>    <span class="hljs-attr">age:</span> <span class="hljs-number">18</span></code></pre><h3 id="3、项目中使用"><a href="#3、项目中使用" class="headerlink" title="3、项目中使用"></a>3、项目中使用</h3><pre><code class="hljs java"><span class="hljs-meta">@Autowired</span>MyService myService;<span class="hljs-meta">@GetMapping</span>(<span class="hljs-string">"/test"</span>)<span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">testMyStarter</span><span class="hljs-params">()</span> </span>&#123;  myService.helloWorld();  <span class="hljs-keyword">return</span> <span class="hljs-string">"ok"</span>;&#125;</code></pre><h2 id="六、总结"><a href="#六、总结" class="headerlink" title="六、总结"></a>六、总结</h2><ol><li>Spring Boot在启动时扫描项目所依赖的JAR包，寻找包含spring.factories文件的JAR包，</li><li>然后读取spring.factories文件获取配置的自动配置类AutoConfiguration，</li><li>然后将自动配置类下满足条件(@ConditionalOnXxx)的@Bean放入到Spring容器中(Spring Context)</li><li>这样使用者就可以直接用来注入，因为该类已经在容器中了</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;写在前面&quot;&gt;&lt;a href=&quot;#写在前面&quot; class=&quot;headerlink&quot; title=&quot;写在前面&quot;&gt;&lt;/a&gt;写在前面&lt;/h2&gt;&lt;p&gt;按照约定，官方的为spring-boot-xxx-starter ，非官方的为 xxx-spring-boot-starte
      
    
    </summary>
    
    
      <category term="java" scheme="http://yoursite.com/categories/java/"/>
    
    
      <category term="springboot" scheme="http://yoursite.com/tags/springboot/"/>
    
  </entry>
  
  <entry>
    <title>mac环境变量配置</title>
    <link href="http://yoursite.com/2020/06/03/mac%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E9%85%8D%E7%BD%AE/"/>
    <id>http://yoursite.com/2020/06/03/mac%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E9%85%8D%E7%BD%AE/</id>
    <published>2020-06-03T13:10:43.000Z</published>
    <updated>2020-06-03T13:13:25.334Z</updated>
    
    <content type="html"><![CDATA[<h2 id="gradle环境变量配置"><a href="#gradle环境变量配置" class="headerlink" title="gradle环境变量配置"></a>gradle环境变量配置</h2><pre><code class="hljs xml">vi ~/.bash_profile# 增加gradle环境变量，如下：export GRADLE_HOME=/Users/orange/Documents/gradle-6.4export PATH=$PATH:$GRADLE_HOME/bin# 刷新source ~/.bash_profile# 查看版本gradle -version</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;gradle环境变量配置&quot;&gt;&lt;a href=&quot;#gradle环境变量配置&quot; class=&quot;headerlink&quot; title=&quot;gradle环境变量配置&quot;&gt;&lt;/a&gt;gradle环境变量配置&lt;/h2&gt;&lt;pre&gt;&lt;code class=&quot;hljs xml&quot;&gt;vi ~/
      
    
    </summary>
    
    
      <category term="idea" scheme="http://yoursite.com/categories/idea/"/>
    
    
      <category term="环境变量" scheme="http://yoursite.com/tags/%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/"/>
    
  </entry>
  
  <entry>
    <title>mybatis-generator</title>
    <link href="http://yoursite.com/2020/06/02/mybatis-generator/"/>
    <id>http://yoursite.com/2020/06/02/mybatis-generator/</id>
    <published>2020-06-02T13:36:54.000Z</published>
    <updated>2020-06-03T12:18:35.200Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-作用"><a href="#1-作用" class="headerlink" title="1.作用"></a>1.作用</h2><p>用来自动生成MyBatis的 mapper、dao、entity </p><h2 id="2-使用"><a href="#2-使用" class="headerlink" title="2.使用"></a>2.使用</h2><p>MyBatis Generator的使用方式有4种：</p><ul><li>命令行生成</li><li>Maven方式生成</li><li>使用Ant任务生成</li><li>使用Java代码生成</li></ul><p>其中推荐使用Maven方式进行代码生成，因为集成和使用比较简单。</p><h2 id="3-代码自动生成配置"><a href="#3-代码自动生成配置" class="headerlink" title="3.代码自动生成配置"></a>3.代码自动生成配置</h2><h3 id="Step1：配置pom中plugin依赖"><a href="#Step1：配置pom中plugin依赖" class="headerlink" title="Step1：配置pom中plugin依赖"></a>Step1：配置pom中plugin依赖</h3><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">plugin</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.mybatis.generator<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mybatis-generator-maven-plugin<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.4.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">executions</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">execution</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">id</span>&gt;</span>Generate MyBatis Artifacts<span class="hljs-tag">&lt;/<span class="hljs-name">id</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">phase</span>&gt;</span>package<span class="hljs-tag">&lt;/<span class="hljs-name">phase</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">goals</span>&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">goal</span>&gt;</span>generate<span class="hljs-tag">&lt;/<span class="hljs-name">goal</span>&gt;</span>            <span class="hljs-tag">&lt;/<span class="hljs-name">goals</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">execution</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">executions</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">configuration</span>&gt;</span>        <span class="hljs-comment">&lt;!--允许移动生成的文件 --&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">verbose</span>&gt;</span>true<span class="hljs-tag">&lt;/<span class="hljs-name">verbose</span>&gt;</span>        <span class="hljs-comment">&lt;!-- 是否覆盖 --&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">overwrite</span>&gt;</span>true<span class="hljs-tag">&lt;/<span class="hljs-name">overwrite</span>&gt;</span>        <span class="hljs-comment">&lt;!-- 自动生成的配置 --&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">configurationFile</span>&gt;</span>src/main/resources/generatorConfig.xml<span class="hljs-tag">&lt;/<span class="hljs-name">configurationFile</span>&gt;</span>        <span class="hljs-comment">&lt;!--将当前pom的依赖项添加到生成器的类路径中--&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">includeCompileDependencies</span>&gt;</span>true<span class="hljs-tag">&lt;/<span class="hljs-name">includeCompileDependencies</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">configuration</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">plugin</span>&gt;</span></code></pre><h3 id="Step2：配置generatorConfig-xml文件"><a href="#Step2：配置generatorConfig-xml文件" class="headerlink" title="Step2：配置generatorConfig.xml文件"></a>Step2：配置generatorConfig.xml文件</h3><pre><code class="hljs dust"><span class="xml"><span class="hljs-meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><span class="xml"><span class="hljs-comment">&lt;!--mybatis的代码生成器相关配置--&gt;</span></span><span class="xml"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">generatorConfiguration</span></span></span><span class="xml">        PUBLIC "-//mybatis.org//DTD MyBatis Generator Configuration 1.0//EN"</span><span class="xml">        "http://mybatis.org/dtd/mybatis-generator-config_1_0.dtd"&gt;</span><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">generatorConfiguration</span>&gt;</span></span><span class="xml">    <span class="hljs-comment">&lt;!-- 引入配置文件 --&gt;</span></span><span class="xml">    <span class="hljs-tag">&lt;<span class="hljs-name">properties</span> <span class="hljs-attr">resource</span>=<span class="hljs-string">"application.yml"</span>/&gt;</span>   </span><span class="xml">    <span class="hljs-tag">&lt;<span class="hljs-name">context</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"Mysql"</span> <span class="hljs-attr">targetRuntime</span>=<span class="hljs-string">"MyBatis3Simple"</span> <span class="hljs-attr">defaultModelType</span>=<span class="hljs-string">"flat"</span>&gt;</span></span><span class="xml">        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"autoDelimitKeywords"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"true"</span> /&gt;</span></span><span class="xml">        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"beginningDelimiter"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"`"</span> /&gt;</span></span><span class="xml">        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"endingDelimiter"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"`"</span> /&gt;</span></span><span class="xml">        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"javaFileEncoding"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"utf-8"</span> /&gt;</span></span><span class="xml">        <span class="hljs-tag">&lt;<span class="hljs-name">plugin</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"org.mybatis.generator.plugins.SerializablePlugin"</span> /&gt;</span></span><span class="xml">        <span class="hljs-tag">&lt;<span class="hljs-name">commentGenerator</span> &gt;</span></span><span class="xml">            <span class="hljs-comment">&lt;!-- 不生成注释 --&gt;</span></span><span class="xml">            <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"suppressAllComments"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"true"</span>/&gt;</span></span><span class="xml">            <span class="hljs-comment">&lt;!-- 不生成注释代时间戳--&gt;</span></span><span class="xml">            <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"suppressDate"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"true"</span> /&gt;</span></span><span class="xml">        <span class="hljs-tag">&lt;/<span class="hljs-name">commentGenerator</span>&gt;</span></span><span class="xml">        <span class="hljs-comment">&lt;!--数据库链接地址账号密码--&gt;</span></span><span class="xml">        <span class="hljs-comment">&lt;!--&lt;jdbcConnection driverClass="$</span></span><span class="hljs-template-variable">&#123;spring.datasource.driver-class-name&#125;</span><span class="xml"><span class="hljs-comment">"--&gt;</span></span><span class="xml">                        <span class="hljs-comment">&lt;!--connectionURL="$</span></span><span class="hljs-template-variable">&#123;spring.datasource.url&#125;</span><span class="xml"><span class="hljs-comment">"--&gt;</span></span><span class="xml">                        <span class="hljs-comment">&lt;!--userId="$</span></span><span class="hljs-template-variable">&#123;spring.datasource.username&#125;</span><span class="xml"><span class="hljs-comment">"--&gt;</span></span><span class="xml">                        <span class="hljs-comment">&lt;!--password="$</span></span><span class="hljs-template-variable">&#123;spring.datasource.password&#125;</span><span class="xml"><span class="hljs-comment">"&gt;--&gt;</span></span><span class="xml">        <span class="hljs-comment">&lt;!--&lt;/jdbcConnection&gt;--&gt;</span></span><span class="xml">        <span class="hljs-tag">&lt;<span class="hljs-name">jdbcConnection</span> <span class="hljs-attr">driverClass</span>=<span class="hljs-string">"com.mysql.cj.jdbc.Driver"</span></span></span><span class="xml">            connectionURL="jdbc:mysql://localhost:3306/display"</span><span class="xml">            userId="root"</span><span class="xml">            password="P@ssw0rd"&gt;</span><span class="xml">        <span class="hljs-tag">&lt;/<span class="hljs-name">jdbcConnection</span>&gt;</span></span><span class="xml">        <span class="hljs-comment">&lt;!-- 类型转换 --&gt;</span></span><span class="xml">        <span class="hljs-tag">&lt;<span class="hljs-name">javaTypeResolver</span>&gt;</span></span><span class="xml">            <span class="hljs-comment">&lt;!-- 是否使用bigDecimal， false可自动转化以下类型（Long, Integer, Short, etc.） --&gt;</span></span><span class="xml">            <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"forceBigDecimals"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"false"</span>/&gt;</span></span><span class="xml">        <span class="hljs-tag">&lt;/<span class="hljs-name">javaTypeResolver</span>&gt;</span></span><span class="xml">        <span class="hljs-comment">&lt;!--生成Model类存放位置--&gt;</span></span><span class="xml">        <span class="hljs-tag">&lt;<span class="hljs-name">javaModelGenerator</span> <span class="hljs-attr">targetPackage</span>=<span class="hljs-string">"com.ztf.mybatisplus.bean"</span> <span class="hljs-attr">targetProject</span>=<span class="hljs-string">"src/main/java"</span>&gt;</span></span><span class="xml">            <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"enableSubPackages"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"true"</span>/&gt;</span></span><span class="xml">            <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"trimStrings"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"true"</span>/&gt;</span></span><span class="xml">        <span class="hljs-tag">&lt;/<span class="hljs-name">javaModelGenerator</span>&gt;</span></span><span class="xml">        <span class="hljs-comment">&lt;!-- 生成mapxml文件 --&gt;</span></span><span class="xml">        <span class="hljs-tag">&lt;<span class="hljs-name">sqlMapGenerator</span> <span class="hljs-attr">targetPackage</span>=<span class="hljs-string">"mapper"</span> <span class="hljs-attr">targetProject</span>=<span class="hljs-string">"src/main/resources/mybatis"</span> &gt;</span></span><span class="xml">            <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"enableSubPackages"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"false"</span> /&gt;</span></span><span class="xml">        <span class="hljs-tag">&lt;/<span class="hljs-name">sqlMapGenerator</span>&gt;</span></span><span class="xml">        <span class="hljs-comment">&lt;!-- 生成mapper java文件 --&gt;</span></span><span class="xml">        <span class="hljs-tag">&lt;<span class="hljs-name">javaClientGenerator</span> <span class="hljs-attr">targetPackage</span>=<span class="hljs-string">"com.ztf.mybatisplus.dao"</span> <span class="hljs-attr">targetProject</span>=<span class="hljs-string">"src/main/java"</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"XMLMAPPER"</span> &gt;</span></span><span class="xml">            <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"enableSubPackages"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"false"</span> /&gt;</span></span><span class="xml">        <span class="hljs-tag">&lt;/<span class="hljs-name">javaClientGenerator</span>&gt;</span></span><span class="xml"><span class="hljs-comment">&lt;!--具体解析的表，建议配置domainObjectName属性，避免带上表前缀T_--&gt;</span></span><span class="xml">        <span class="hljs-tag">&lt;<span class="hljs-name">table</span> <span class="hljs-attr">tableName</span>=<span class="hljs-string">"t_corp"</span> <span class="hljs-attr">enableCountByExample</span>=<span class="hljs-string">"true"</span> <span class="hljs-attr">domainObjectName</span>=<span class="hljs-string">"Corp"</span></span></span><span class="xml">               enableUpdateByExample="true" enableDeleteByExample="true"</span><span class="xml">               enableSelectByExample="true" selectByExampleQueryId="true"&gt;</span><span class="xml">            <span class="hljs-comment">&lt;!--&lt;generatedKey column="id" sqlStatement="Mysql" identity="true" /&gt;--&gt;</span></span><span class="xml">        <span class="hljs-tag">&lt;/<span class="hljs-name">table</span>&gt;</span></span><span class="xml">        <span class="hljs-comment">&lt;!--&lt;table tableName="user_log" enableCountByExample="true" --&gt;</span></span><span class="xml">               <span class="hljs-comment">&lt;!--enableUpdateByExample="true" enableDeleteByExample="true" --&gt;</span></span><span class="xml">               <span class="hljs-comment">&lt;!--enableSelectByExample="true" selectByExampleQueryId="true"&gt;--&gt;</span></span><span class="xml">            <span class="hljs-comment">&lt;!--&lt;generatedKey column="id" sqlStatement="Mysql" identity="true" /&gt;--&gt;</span></span><span class="xml">        <span class="hljs-comment">&lt;!--&lt;/table&gt;--&gt;</span></span><span class="xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">context</span>&gt;</span></span><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">generatorConfiguration</span>&gt;</span></span></code></pre><h2 id="4-注意事项"><a href="#4-注意事项" class="headerlink" title="4.注意事项"></a>4.注意事项</h2><ul><li>MyBatis Generator 只会覆盖旧的 po、dao、而 mapper.xml 不会覆盖，而是追加，这样做的目的是防止用户自己写的 sql 语句一不小心都被 MyBatis Generator 给覆盖了</li></ul><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- 是否覆盖 --&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">overwrite</span>&gt;</span>true<span class="hljs-tag">&lt;/<span class="hljs-name">overwrite</span>&gt;</span></code></pre><ul><li>一般配置了 <strong>includeCompileDependencies</strong> 后就不需要配置其他依赖了，因为 <strong>includeCompileDependencies</strong> 会将当前 pom 的 <strong>dependencies</strong> 中所有 <strong>Compile</strong> 期的依赖全部添加到生成器的类路径中。</li></ul><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--将当前pom的依赖项添加到生成器的类路径中--&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">includeCompileDependencies</span>&gt;</span>true<span class="hljs-tag">&lt;/<span class="hljs-name">includeCompileDependencies</span>&gt;</span></code></pre><ul><li>数据库文件yml方式加载不进来配置，写成<code>application.properties&quot;</code>方式就可以</li></ul><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- 引入配置文件 --&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">properties</span> <span class="hljs-attr">resource</span>=<span class="hljs-string">"application-dev.properties"</span>/&gt;</span></code></pre><ul><li>context属性</li></ul><pre><code class="hljs xml">id : 随便填，保证多个 context id 不重复就行defaultModelType ： 可以不填，默认值 conditional，flat表示一张表对应一个potargetRuntime ：可以不填，默认值 MyBatis3，常用的还有 MyBatis3Simple。MyBatis3Simple生成的 dao 和 mapper.xml 内容较少，但也包含了最常用的。</code></pre><ul><li>context的子元素要求有序</li></ul><pre><code class="hljs angelscript"><span class="hljs-number">1.</span> **<span class="hljs-keyword">property</span>** (<span class="hljs-number">0.</span>.N)<span class="hljs-number">2.</span> **plugin** (<span class="hljs-number">0.</span>.N)<span class="hljs-number">3.</span> **commentGenerator** (<span class="hljs-number">0</span> <span class="hljs-keyword">or</span> <span class="hljs-number">1</span>)<span class="hljs-number">4.</span> **jdbcConnection** (需要connectionFactory 或 jdbcConnection)<span class="hljs-number">5.</span> **javaTypeResolver** (<span class="hljs-number">0</span> <span class="hljs-keyword">or</span> <span class="hljs-number">1</span>)<span class="hljs-number">6.</span> **javaModelGenerator** (至少<span class="hljs-number">1</span>个)<span class="hljs-number">7.</span> **sqlMapGenerator** (<span class="hljs-number">0</span> <span class="hljs-keyword">or</span> <span class="hljs-number">1</span>)<span class="hljs-number">8.</span> **javaClientGenerator** (<span class="hljs-number">0</span> <span class="hljs-keyword">or</span> <span class="hljs-number">1</span>)<span class="hljs-number">9.</span> **table** (<span class="hljs-number">1.</span>.N)</code></pre><ul><li>commentGenerator 默认生成注释和时间戳，可显式的声明某一项不生成。<strong>建议全部显式不生成。</strong></li></ul><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">commentGenerator</span>&gt;</span>    <span class="hljs-comment">&lt;!-- 不希望生成的注释中包含时间戳 --&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"suppressDate"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"true"</span>/&gt;</span>    <span class="hljs-comment">&lt;!-- 不希望生成的注释中包含注释 --&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"suppressAllComments"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"true"</span>/&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">commentGenerator</span>&gt;</span></code></pre><ul><li><code>type=&quot;XMLMAPPER&quot;</code> 会将接口的实现放在 mapper.xml中，也推荐这样配置。也可以设置  <code>type=&quot;ANNOTATEDMAPPER&quot;</code>，接口的实现通过注解写在接口上面</li><li>一个 table 对应一张表，如果想同时生成多张表，需要配置多个 table</li><li><strong>domainObjectName</strong> 不配置时，它会按照帕斯卡命名法将表名转换成类名，建议配置该属性，避免带上表前缀T_</li></ul><pre><code class="hljs routeros">&lt;domainObjectRenamingRule <span class="hljs-attribute">searchString</span>=<span class="hljs-string">"^T"</span> <span class="hljs-attribute">replaceString</span>=<span class="hljs-string">""</span> /&gt;</code></pre><ul><li>表字段也会默认带上<code>c_</code>、<code>d_</code>，可设置去掉</li></ul><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- 这个意思就是匹配，开头的任意个非下划线(_)的字符，也就是这种如：c_，d_ 等等 --&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">columnRenamingRule</span> <span class="hljs-attr">searchString</span>=<span class="hljs-string">"^[^_]+"</span> <span class="hljs-attr">replaceString</span>=<span class="hljs-string">""</span>/&gt;</span>  <span class="hljs-comment">&lt;!-- 也可如下只去掉c_--&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">columnRenamingRule</span> <span class="hljs-attr">searchString</span>=<span class="hljs-string">"^c_"</span> <span class="hljs-attr">replaceString</span>=<span class="hljs-string">""</span> /&gt;</span></code></pre><ul><li><strong>enableXXXByExample</strong> 默认为true，但只有在<code>targetRuntime=&quot;MyBatis3&quot;</code>时才生效。当 <code>targetRuntime=&quot;MyBatis3Simple&quot;</code>时，<strong>enableXXXByExample</strong> 不管为true、还是false 都不生效。一般建议全设置为false，true的话会生成很多Example帮助类，造成很多sonar问题。</li></ul><h2 id="4-参考"><a href="#4-参考" class="headerlink" title="4.参考"></a>4.参考</h2><p><a href="https://segmentfault.com/a/1190000016570268" target="_blank" rel="noopener">Spring Boot （七）MyBatis代码自动生成和辅助插件</a></p><p><a href="https://juejin.im/post/5db694e3e51d452a2e25ba45" target="_blank" rel="noopener">MyBatis Generator 超详细配置</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;1-作用&quot;&gt;&lt;a href=&quot;#1-作用&quot; class=&quot;headerlink&quot; title=&quot;1.作用&quot;&gt;&lt;/a&gt;1.作用&lt;/h2&gt;&lt;p&gt;用来自动生成MyBatis的 mapper、dao、entity &lt;/p&gt;
&lt;h2 id=&quot;2-使用&quot;&gt;&lt;a href=&quot;#
      
    
    </summary>
    
    
      <category term="mybatis" scheme="http://yoursite.com/categories/mybatis/"/>
    
    
      <category term="mybatis-generator" scheme="http://yoursite.com/tags/mybatis-generator/"/>
    
  </entry>
  
  <entry>
    <title>性能优化策略</title>
    <link href="http://yoursite.com/2020/06/01/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E7%AD%96%E7%95%A5/"/>
    <id>http://yoursite.com/2020/06/01/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E7%AD%96%E7%95%A5/</id>
    <published>2020-06-01T12:42:04.000Z</published>
    <updated>2020-06-01T13:25:08.525Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、时空转换"><a href="#一、时空转换" class="headerlink" title="一、时空转换"></a>一、时空转换</h2><h3 id="1-1-时间换空间"><a href="#1-1-时间换空间" class="headerlink" title="1.1 时间换空间"></a>1.1 时间换空间</h3><ul><li>场景1: 降低内存空间的占用。</li><li>场景2: 降低数据的大小来方便网络传输和外部存储。</li></ul><p>具体方式：</p><p>1、改变数据结构或者数据格式，减少要存储的数据大小。</p><p>2、使用压缩算法，压缩内存中的数据，使用时解压。</p><p>3、把内存中的数据存储到外部的、更便宜的存储设备中，需要时再取回来。</p><blockquote><p>这些节省内存空间的方法，一般都需要付出时间的代价。</p></blockquote><blockquote><p>衡量任何压缩算法，基本上看三个指标：压缩比例、压缩速度以及使用内存。</p></blockquote><blockquote><p>如果系统的瓶颈在<strong>网络传输速度或者存储空间大小</strong>上，那就尽量采取高压缩比的算法。</p></blockquote><h3 id="1-2-空间换时间"><a href="#1-2-空间换时间" class="headerlink" title="1.2 空间换时间"></a>1.2 空间换时间</h3><ul><li>场景：要求快速响应。</li></ul><p>具体方式：</p><p>1、对数据和服务进行多份拷贝，尽大可能的覆盖更多的用户。</p><blockquote><p>典型案例：集群</p></blockquote><h2 id="二、预处理和延后处理"><a href="#二、预处理和延后处理" class="headerlink" title="二、预处理和延后处理"></a>二、预处理和延后处理</h2><h3 id="2-1-预处理-提前处理"><a href="#2-1-预处理-提前处理" class="headerlink" title="2.1 预处理/提前处理"></a>2.1 预处理/提前处理</h3><p>使用场景：</p><p>1、web静态资源提前加载，preload 和 prefetch。</p><p>2、文件系统预读功能。提前从磁盘读取下一次的数据。</p><blockquote><p>这个功能对顺序读取十分有效，可以减少磁盘请求的数量</p></blockquote><h3 id="2-2-延后-惰性处理"><a href="#2-2-延后-惰性处理" class="headerlink" title="2.2 延后/惰性处理"></a>2.2 延后/惰性处理</h3><ul><li>尽量将操作推迟到必须执行的时刻。</li></ul><p>使用场景：</p><p>1、COW（copy on write）写时复制。多线程读取共享资源时，不进行复制操作，当某个线程需要对资源进行修改时，才拷贝一份到工作内存，使其不会影响其他线程。</p><h2 id="三、并行和并发"><a href="#三、并行和并发" class="headerlink" title="三、并行和并发"></a>三、并行和并发</h2><h2 id="四、缓存-批量合并"><a href="#四、缓存-批量合并" class="headerlink" title="四、缓存/批量合并"></a>四、缓存/批量合并</h2><h3 id="4-1-缓存"><a href="#4-1-缓存" class="headerlink" title="4.1 缓存"></a>4.1 缓存</h3><ul><li>缓存的本质是加速访问。</li></ul><p>使用场景：</p><p>1、对于一个基于 Web 的应用服务，前端会有浏览器缓存，有 CDN 存放在边缘服务器上，有反向代理提供的静态内容缓存；后端则还会有服务器本地缓存。</p><p>2、程序设计中，对于可能重复创建和销毁，且创建销毁代价很大的对象（比如套接字和线程），也可以缓存，对应的缓存形式，就是连接池和线程池等。</p><p>3、对于消耗较大的计算，也可以将计算结果缓存起来，下次可以直接读取结果。比如对递归代码的一个有效优化手段，就是缓存中间结果。</p><h3 id="4-2批量合并"><a href="#4-2批量合并" class="headerlink" title="4.2批量合并"></a>4.2批量合并</h3><ul><li>在有 IO（比如网络 IO 和磁盘 IO）的时候，合并操作和批量操作往往能提升吞吐量，提高性能。</li></ul><p>使用场景：</p><p>1、批量 IO 读写。就是在有多次 IO 的时候，可以把它们合并成一次读写数据。这样可以减少读写时间和协议负担。</p><p>2、对数据库的读写操作，也可以尽量合并。比如，对键值数据库的查询，最好一次查询多个键，而不要分成多次。</p><p>3、涉及到网络请求的时候，网络传输的时间可能远大于请求的处理时间，因此合并网络请求也很有必要。</p><h2 id="五、更高效的算法和数据结构"><a href="#五、更高效的算法和数据结构" class="headerlink" title="五、更高效的算法和数据结构"></a>五、更高效的算法和数据结构</h2><h2 id="附录："><a href="#附录：" class="headerlink" title="附录："></a>附录：</h2><p><a href="https://www.toutiao.com/i6832247243278385671/" target="_blank" rel="noopener">参考文档</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;一、时空转换&quot;&gt;&lt;a href=&quot;#一、时空转换&quot; class=&quot;headerlink&quot; title=&quot;一、时空转换&quot;&gt;&lt;/a&gt;一、时空转换&lt;/h2&gt;&lt;h3 id=&quot;1-1-时间换空间&quot;&gt;&lt;a href=&quot;#1-1-时间换空间&quot; class=&quot;headerlink
      
    
    </summary>
    
    
      <category term="总结" scheme="http://yoursite.com/categories/%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="性能优化" scheme="http://yoursite.com/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>服务熔断</title>
    <link href="http://yoursite.com/2020/05/31/%E6%9C%8D%E5%8A%A1%E7%86%94%E6%96%AD/"/>
    <id>http://yoursite.com/2020/05/31/%E6%9C%8D%E5%8A%A1%E7%86%94%E6%96%AD/</id>
    <published>2020-05-31T14:43:58.000Z</published>
    <updated>2020-05-31T15:45:41.762Z</updated>
    
    <content type="html"><![CDATA[<h1 id="服务熔断"><a href="#服务熔断" class="headerlink" title="服务熔断"></a>服务熔断</h1><ul><li>hystrix，是一个用于处理分布式系统延迟和容错的库，它能够保证在一个子服务出问题的情况下，不会导致整体服务失败，避免级联雪崩，以提高分布式系统的弹性。</li><li>“断路器”本身是一个开关装置，当某个服务单元发生故障后，向调用方返回一个服务预期的、可处理的备选响应，而不是长时间等待或者抛出一个服务端无法处理的异常。这样就保证了调用方线程不会被长时间占用，从而避免故障在分布式系统中蔓延，甚至雪崩。</li></ul><h2 id="1、服务降级（客户端提供异常响应）"><a href="#1、服务降级（客户端提供异常响应）" class="headerlink" title="1、服务降级（客户端提供异常响应）"></a>1、服务降级（客户端提供异常响应）</h2><ul><li>限制其他低相关服务的访问，使他们占用计算机较少的资源，从而保障主服务拥有更多的资源，使其能正常访问。</li></ul><pre><code class="hljs java"><span class="hljs-comment">// 配置文件默认关闭，需手动开启</span>feign:  hystrix:    enabled: true # 启用服务降级<span class="hljs-meta">@FeignClient</span>(name = <span class="hljs-string">"MYCLOUD-PROVIDER"</span>, fallback = HystrixConsumerService<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span><span class="hljs-class"><span class="hljs-title">public</span> <span class="hljs-title">interface</span> <span class="hljs-title">CorpConsumerService</span> </span>&#123;    <span class="hljs-meta">@GetMapping</span>(<span class="hljs-string">"/corps/&#123;id&#125;"</span>)    <span class="hljs-function">Corp <span class="hljs-title">getCorp</span><span class="hljs-params">(@PathVariable(<span class="hljs-string">"id"</span>)</span> String id)</span>;    <span class="hljs-meta">@GetMapping</span>(<span class="hljs-string">"/corps"</span>)    <span class="hljs-function">List&lt;Corp&gt; <span class="hljs-title">getCorps</span><span class="hljs-params">()</span></span>;&#125;<span class="hljs-comment">// 客户端熔断回调缺省值处理</span><span class="hljs-comment">// 假设服务端未启动，即这么处理</span><span class="hljs-meta">@Service</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HystrixConsumerService</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">CorpConsumerService</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> Corp <span class="hljs-title">getCorp</span><span class="hljs-params">(String id)</span> </span>&#123;        <span class="hljs-keyword">return</span> Corp.builder().id(id).name(<span class="hljs-string">"HystrixConsumerService"</span>).age(<span class="hljs-number">40</span>).build();    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;Corp&gt; <span class="hljs-title">getCorps</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;    &#125;&#125;</code></pre><h2 id="2、服务熔断（服务端返回合适的异常响应）"><a href="#2、服务熔断（服务端返回合适的异常响应）" class="headerlink" title="2、服务熔断（服务端返回合适的异常响应）"></a>2、服务熔断（服务端返回合适的异常响应）</h2><ul><li>熔断机制是对微服务雪崩效应的一种链路保护机制。</li><li>当扇出链路的某个微服务不可用或者响应时间太长时，会进行服务的降级，<strong>进而熔断该节点的微服务调用，快速返回错误的响应信息，当检测到该微服务调用响应正常后恢复调用链路。</strong></li><li>hystrix会监控微服务之间的调用状况，当失败的调用到一定阈值，缺省是5s内20ci调用失败就会触发。熔断机制的注解是@HystrixCommand。</li></ul><pre><code class="hljs java"><span class="hljs-comment">// 启动类配置enable</span><span class="hljs-meta">@SpringBootApplication</span><span class="hljs-meta">@EnableEurekaClient</span><span class="hljs-meta">@EnableHystrix</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CorpProvider8005</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        SpringApplication.run(CorpProvider8005<span class="hljs-class">.<span class="hljs-keyword">class</span>, <span class="hljs-title">args</span>)</span>;    &#125;&#125;<span class="hljs-comment">// 添加@HystrixCommand注解</span><span class="hljs-comment">// 发生异常时，会调用hystrixCorp方法，控制台无异常堆栈</span><span class="hljs-meta">@GetMapping</span>(<span class="hljs-string">"/corps/&#123;id&#125;"</span>)<span class="hljs-meta">@HystrixCommand</span>(fallbackMethod = <span class="hljs-string">"hystrixCorp"</span>)<span class="hljs-function">Corp <span class="hljs-title">getCorp</span><span class="hljs-params">(@PathVariable(<span class="hljs-string">"id"</span>)</span> String id) </span>&#123;  Corp corp = corpService.getCorp(id);  <span class="hljs-keyword">if</span> (corp == <span class="hljs-keyword">null</span>) &#123;    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(<span class="hljs-string">"id "</span> + id + <span class="hljs-string">" 不存在"</span>);  &#125;  <span class="hljs-keyword">return</span> corp;&#125;<span class="hljs-function">Corp <span class="hljs-title">hystrixCorp</span><span class="hljs-params">(@PathVariable(<span class="hljs-string">"id"</span>)</span> String id) </span>&#123;  <span class="hljs-keyword">return</span> Corp.builder().id(id).name(<span class="hljs-string">"hystrix"</span>).age(<span class="hljs-number">30</span>).build();&#125;</code></pre><h2 id="3、服务限流"><a href="#3、服务限流" class="headerlink" title="3、服务限流"></a>3、服务限流</h2><h2 id="4、实时监控"><a href="#4、实时监控" class="headerlink" title="4、实时监控"></a>4、实时监控</h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;服务熔断&quot;&gt;&lt;a href=&quot;#服务熔断&quot; class=&quot;headerlink&quot; title=&quot;服务熔断&quot;&gt;&lt;/a&gt;服务熔断&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;hystrix，是一个用于处理分布式系统延迟和容错的库，它能够保证在一个子服务出问题的情况下，不会导致整体服务失
      
    
    </summary>
    
    
      <category term="java" scheme="http://yoursite.com/categories/java/"/>
    
    
      <category term="springCloud hystrix" scheme="http://yoursite.com/tags/springCloud-hystrix/"/>
    
  </entry>
  
  <entry>
    <title>负载均衡</title>
    <link href="http://yoursite.com/2020/05/31/%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/"/>
    <id>http://yoursite.com/2020/05/31/%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/</id>
    <published>2020-05-31T13:32:48.000Z</published>
    <updated>2020-05-31T14:47:12.805Z</updated>
    
    <content type="html"><![CDATA[<h1 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h1><ul><li><p>LB（load balance）：简单的说就是将用户请求平摊分配到多个服务器上，从而达到系统的高可用。</p></li><li><p>常见的负载均衡软件有nginx、lvx</p></li><li><p>常见分类</p><ul><li>集中式LB：在服务的消费方和服务方使用独立的Lb方式，如nginx，由它负责请求转发。</li><li>进程式LB：将LB逻辑集成到消费方，消费方从注册中心获取可用的服务，再从这里面选一个进行访问，如ribbon。</li></ul></li></ul><h2 id="ribbon-负载均衡"><a href="#ribbon-负载均衡" class="headerlink" title="ribbon 负载均衡"></a>ribbon 负载均衡</h2><pre><code class="hljs java"><span class="hljs-comment">// 配置类</span><span class="hljs-meta">@Configuration</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RestTemplateConfig</span> </span>&#123;    <span class="hljs-meta">@Bean</span>    <span class="hljs-meta">@LoadBalanced</span>    <span class="hljs-function">RestTemplate <span class="hljs-title">restTemplate</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> RestTemplate();    &#125;&#125;<span class="hljs-comment">// controller调用</span><span class="hljs-comment">// 第二版根据服务名去访问，需要将restTemplate注解为@LoadBalanced才会生效</span><span class="hljs-keyword">private</span> String service = <span class="hljs-string">"http://MYCLOUD-PROVIDER"</span>;<span class="hljs-meta">@RequestMapping</span>(<span class="hljs-string">"/consumer/corps/&#123;id&#125;"</span>)<span class="hljs-function">Corp <span class="hljs-title">getCorp</span><span class="hljs-params">(@PathVariable(<span class="hljs-string">"id"</span>)</span> String id) </span>&#123;  String url = service + <span class="hljs-string">"/corps/"</span>;  <span class="hljs-keyword">return</span> restTemplate.getForObject(url + id, Corp<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;&#125;</code></pre><blockquote><p>使用服务名去调用，restful风格</p></blockquote><h2 id="feign-负载均衡"><a href="#feign-负载均衡" class="headerlink" title="feign 负载均衡"></a>feign 负载均衡</h2><ul><li>feign是声明式的web service客户端，只需提供一个接口，添加注解就可以了。</li><li>feign是ribbon的封装，以面向对象方式的去访问。</li><li>feign不需要去显式的声明restTemplate</li></ul><blockquote><p>使用接口注解去调用</p></blockquote><pre><code class="hljs java"><span class="hljs-comment">// 逻辑处理类，映射路径为实际接口路径</span><span class="hljs-meta">@FeignClient</span>(name = <span class="hljs-string">"MYCLOUD-PROVIDER"</span>)<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">CorpConsumerService</span> </span>&#123;    <span class="hljs-meta">@GetMapping</span>(<span class="hljs-string">"/corps/&#123;id&#125;"</span>)    <span class="hljs-function">Corp <span class="hljs-title">getCorp</span><span class="hljs-params">(@PathVariable(<span class="hljs-string">"id"</span>)</span> String id)</span>;    <span class="hljs-meta">@GetMapping</span>(<span class="hljs-string">"/corps"</span>)    <span class="hljs-function">List&lt;Corp&gt; <span class="hljs-title">getCorps</span><span class="hljs-params">()</span></span>;&#125;<span class="hljs-comment">// 启动类配置enable</span><span class="hljs-meta">@SpringBootApplication</span><span class="hljs-meta">@EnableEurekaClient</span><span class="hljs-meta">@EnableFeignClients</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CorpConsumer8002</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        SpringApplication.run(CorpConsumer8002<span class="hljs-class">.<span class="hljs-keyword">class</span>, <span class="hljs-title">args</span>)</span>;    &#125;&#125;</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;负载均衡&quot;&gt;&lt;a href=&quot;#负载均衡&quot; class=&quot;headerlink&quot; title=&quot;负载均衡&quot;&gt;&lt;/a&gt;负载均衡&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;LB（load balance）：简单的说就是将用户请求平摊分配到多个服务器上，从而达到系统的高可用。&lt;/
      
    
    </summary>
    
    
      <category term="java" scheme="http://yoursite.com/categories/java/"/>
    
    
      <category term="springCloud ribbon" scheme="http://yoursite.com/tags/springCloud-ribbon/"/>
    
  </entry>
  
  <entry>
    <title>eureka对比zookeeper</title>
    <link href="http://yoursite.com/2020/05/31/eureka%E5%AF%B9%E6%AF%94zookeeper/"/>
    <id>http://yoursite.com/2020/05/31/eureka%E5%AF%B9%E6%AF%94zookeeper/</id>
    <published>2020-05-31T13:09:42.000Z</published>
    <updated>2020-06-09T14:52:36.481Z</updated>
    
    <content type="html"><![CDATA[<h1 id="cap原则"><a href="#cap原则" class="headerlink" title="cap原则"></a>cap原则</h1><h2 id="一、回顾"><a href="#一、回顾" class="headerlink" title="一、回顾"></a>一、回顾</h2><ul><li><p>ACID 原则</p><ul><li>关系数据库管理系统（Relational Database Management System：<em>RDBMS</em>），如mysql、oracle、sqlserver</li><li>A（atomicity）原子性</li><li>C（consistency）一致性</li><li>I（Isolation）隔离性</li><li>D（durability）持久性</li></ul></li><li><p>CAP原则</p><ul><li><p>一般用于redis、mongdb</p></li><li><p>C（consistency）一致性：</p><p>分布式环境下，一致性主要指数据在多个副本之间是否一致，（等同于所有节点访问同一份最新的数据副本）。</p><p>通过某个节点的写操作结果对后面通过其他节点的读操作可见，如果数据更新后并发访问情况下可立即感知其更新， 称为强一致性，如果允许之后部分或者全部感知不到该更新，称为弱一致性，若在之后一段时间后，一定可以感知该更新，称为最终一致性。</p></li><li><p>A（avaibility）可用性：</p><p>在集群中一部分节点故障后，集群整体是否还能响应客户端的读写请求。（对数据更新具备高可用性）</p></li><li><p>P（partition tolerance）分区容错性：</p><p>集群出现网络割裂时，集群还能继续提供一定的可用性和一致性，除非整个网络不可用，也即部分节点宕机或者无法与其他节点通信时，各分区间还可保持分布式系统的功能。</p></li></ul></li></ul><p><strong>著名的CAP理论指出，一个分布式系统不可能同时满足C(一致性)、A(可用性)和P(分区容错性)。由于分区容错性在是分布式系统中必须要保证的，因此我们只能在A和C之间进行权衡。zookeeper保证的是CP， 而eureka则是AP。</strong></p><ul><li><p>BASE理论</p><ul><li><p>BASE是Basically Available（基本可用）、Soft state（软状态）和Eventually consistent（最终一致性）三个短语的简写，BASE是对CAP中一致性和可用性权衡的结果，其来源于对大规模互联网系统分布式实践的结论，是基于CAP定理逐步演化而来的，其核心思想是即使无法做到强一致性（Strong consistency），但每个应用都可以根据自身的业务特点，采用适当的方式来使系统达到最终一致性（Eventual consistency）。</p></li><li><p>BASE之基本可用体现在两个方面： 1、响应时间上的损失：比如某些请求1秒内给出响应，有些请求可能会在5秒内给出响应 2、功能上的损失：例如对于电商系统来说，某些区域可能不能购买某些商品，又或者大促时，部分消费者被引流到降级页面。</p></li><li><p>BASE之弱状态： 也称为软状态，是指允许系统中的数据存在中间状态，并认为该状态不会影响系统的整体可用性，即允许系统在不同节点的数据副本之间存在一定的延时。</p></li><li><p>BASE之最终一致性： 系统中的数据副本在经过一段时间同步后，组中能够达到一个一致的状态。</p></li></ul></li></ul><h2 id="二、集群环境下如何保障数据一致性"><a href="#二、集群环境下如何保障数据一致性" class="headerlink" title="二、集群环境下如何保障数据一致性"></a>二、集群环境下如何保障数据一致性</h2><p>集群环境下有三种方式保障数据一致性：数据复制、WNR和集中存储。</p><p>1、数据复制：先向单节点写入，再复制到其他节点，zookeeper是这样实现的。或者多节点同时写入，但只适合多节点写入的数据不是相同数据的应用场景。在master-slave场景中， 同步复制（slave从master全部复制完成才给客户端返回写入成功）可保证强一致性，但会影响可用性；异步复制（数据写入master就返回写入成功，不需要等到slave复制完成， 之后master通过push向slave推送数据或者slave通过ull方式从master拉数据）可提供可用性但会降低一致性。</p><p>2、WNR：N代表总副本数，W代表每次写操作要保证的最少写成功的副本数，R代表每次读操作最少读取的副本数，当W+R&gt;N时，可保证每次读取的数据至少有一个副本具有最新的更新 （例如可以通过版本号或者时间戳判断是哪个副本的数据是最新的），多个写操作的顺序难以保证，可能导致多副本的写操作顺序不一致，Dynamo通过箱量时钟在保证最终一致性。</p><p>3、集中存储：借助可靠性较高的集中存储，比如NAS存储，分布式缓存（Redis）等。</p><h2 id="二、zookeeper保证的是CP"><a href="#二、zookeeper保证的是CP" class="headerlink" title="二、zookeeper保证的是CP"></a>二、zookeeper保证的是CP</h2><ul><li>放弃可用性，并不是完全没有可用性，是指允许响应超时的时间可以更长，比如报表可以运行10分钟左右，甚至在某些情况下允许超时。</li><li>Zookeeper会出现这样一种情况，当master节点因为网络故障与其他节点失去联系时，剩余节点会重新进行leader选举。问题在于，选举leader的时间太长，30 ~ 120s, 且选举期间整个Zookeeper集群都是不可用的，这就导致在选举期间注册服务瘫痪。在云部署的环境下，因网络问题使得Zookeeper集群失去master节点是较大概率会发生的事，虽然服务能够最终恢复，但是漫长的选举时间导致的注册长期不可用是不能容忍的。</li></ul><p><strong>zk集群：</strong></p><p>1、zk集群是一种对等集群，所有节点（机器）数据都一样。</p><p>2、集群节点之间靠心跳感知彼此的存在。 </p><p>3、所有写操作都在主节点，其他节点只能读，虽然也可以接收写请求，但是内部会把写操作转给主节点。 </p><p>4、通过选举机制选出主节点，从而保障了主节点的高可用，这样主节点就不是固定的，万一主节点宕机还可以重新选举出主节点。 </p><p>5、至少需要三个节点，而且节点个数必须是奇数。 </p><p>6、当一半以上的数据写入成功后，则返回写入成功，是最终一致性策略。</p><h2 id="三、eureka保证的是AP"><a href="#三、eureka保证的是AP" class="headerlink" title="三、eureka保证的是AP"></a>三、eureka保证的是AP</h2><ul><li><p>放弃一致性是放弃数据的强一致性，而保留数据的最终一致性，即数据最终是完全一致的，但有一个时间窗口的问题，这需要根据不同的业务来定义。</p></li><li><p>当向注册中心查询服务列表时，我们可以容忍注册中心返回的是几分钟以前的注册信息，但不能接受服务直接down掉不可用。也就是说，服务注册功能对可用性的要求要高于一致性。</p></li><li><p>Eureka在设计时就优先保证可用性。Eureka各个节点都是平等的，几个节点挂掉不会影响正常节点的工作，剩余的节点依然可以提供注册和查询服务。而Eureka的客户端在向某个Eureka注册或时如果发现连接失败，则会自动切换至其它节点，只要有一台Eureka还在，就能保证注册服务可用(保证可用性)，只不过查到的信息可能不是最新的(不保证强一致性)。</p></li><li><p>除此之外，Eureka还有一种自我保护机制，如果在15分钟内超过85%的节点都没有正常的心跳，那么Eureka就认为客户端与注册中心出现了网络故障，此时会出现以下几种情况：</p><ol><li>Eureka不再从注册列表中移除因为长时间没收到心跳而应该过期的服务。</li><li>Eureka仍然能够接受新服务的注册和查询请求，但是不会被同步到其它节点上(即保证当前节点依然可用) 。</li><li>当网络稳定时，当前实例新的注册信息会被同步到其它节点中。因此， Eureka可以很好的应对因网络故障导致部分节点失去联系的情况，而不会像zookeeper那样使整个注册服务瘫痪。</li></ol></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;cap原则&quot;&gt;&lt;a href=&quot;#cap原则&quot; class=&quot;headerlink&quot; title=&quot;cap原则&quot;&gt;&lt;/a&gt;cap原则&lt;/h1&gt;&lt;h2 id=&quot;一、回顾&quot;&gt;&lt;a href=&quot;#一、回顾&quot; class=&quot;headerlink&quot; title=&quot;一、回顾&quot;
      
    
    </summary>
    
    
      <category term="springCloud" scheme="http://yoursite.com/categories/springCloud/"/>
    
    
      <category term="eureka zookeeper" scheme="http://yoursite.com/tags/eureka-zookeeper/"/>
    
  </entry>
  
  <entry>
    <title>java8方法引用理解</title>
    <link href="http://yoursite.com/2020/05/31/java8%E6%96%B9%E6%B3%95%E5%BC%95%E7%94%A8%E7%90%86%E8%A7%A3/"/>
    <id>http://yoursite.com/2020/05/31/java8%E6%96%B9%E6%B3%95%E5%BC%95%E7%94%A8%E7%90%86%E8%A7%A3/</id>
    <published>2020-05-31T04:12:15.000Z</published>
    <updated>2020-05-31T04:13:16.886Z</updated>
    
    <content type="html"><![CDATA[<h2 id="什么是方法引用"><a href="#什么是方法引用" class="headerlink" title="什么是方法引用?"></a>什么是方法引用?</h2><p>方法引用可用于在不调用方法的情况下引用方法。它将方法视为Lambda表达式。它们只能作为语法糖来减少一些lambdas的冗长。在方法引用中，将包含方法的对象（或类）放在::运算符之前，将方法的名称放在不带参数的方法之后。例如：</p><pre><code class="hljs asciidoc"><span class="hljs-bullet">Object :: </span>methodName</code></pre><h2 id="为什么会出现方法引用？"><a href="#为什么会出现方法引用？" class="headerlink" title="为什么会出现方法引用？"></a>为什么会出现方法引用？</h2><p>在Java中，我们可以通过创建新对象来使用对象的引用,或者引用已有的对象，例如：</p><pre><code class="hljs lasso"><span class="hljs-comment">//创建新对象来引用该对象</span><span class="hljs-built_in">List</span> <span class="hljs-built_in">list</span> = <span class="hljs-literal">new</span> ArrayList();dosth(<span class="hljs-built_in">list</span>);<span class="hljs-comment">//引用已有的对象</span><span class="hljs-built_in">List</span> list2 = <span class="hljs-built_in">list</span>;dosth(list2);</code></pre><p>如果我们只在另一个方法中使用对象的方法，我们仍然必须将完整的对象作为参数传递。那么将方法作为参数传递不是更有效吗？</p><h2 id="方法引用这种语法糖不能用于所有的方法，它们只能用于只有一个方法的lambda表达式"><a href="#方法引用这种语法糖不能用于所有的方法，它们只能用于只有一个方法的lambda表达式" class="headerlink" title="方法引用这种语法糖不能用于所有的方法，它们只能用于只有一个方法的lambda表达式"></a>方法引用这种语法糖不能用于所有的方法，它们只能用于只有一个方法的lambda表达式</h2><pre><code class="hljs arduino"><span class="hljs-comment">//lambda转方法引用</span>Consumer&lt;<span class="hljs-keyword">String</span>&gt; c = s -&gt; System.out.<span class="hljs-built_in">println</span>(s);Consumer&lt;<span class="hljs-keyword">String</span>&gt; c = System.out::<span class="hljs-built_in">println</span>;</code></pre><p>换句话说，可以使用lambda表达式去代替一个匿名类，如果这个匿名类只有一个方法，就可以用更简短的方法引用来代替lambda表达式。</p><h2 id="静态方法引用"><a href="#静态方法引用" class="headerlink" title="静态方法引用"></a>静态方法引用</h2><pre><code class="hljs livescript"><span class="hljs-keyword">from</span><span class="hljs-function"><span class="hljs-params">(args)</span> -&gt;</span> Class.staticMethod(args)<span class="hljs-keyword">to</span>Class::staticMethod</code></pre><p>如上所述，我们不需要显式的传递参数，方法引用中会自动传递参数</p><pre><code class="hljs arduino">Consumer&lt;<span class="hljs-keyword">String</span>&gt; c1 = (s) -&gt; System.out.<span class="hljs-built_in">println</span>(s);Consumer&lt;<span class="hljs-keyword">String</span>&gt; c2 = System.out::<span class="hljs-built_in">println</span>;c2.accept(<span class="hljs-string">"Hello"</span>);</code></pre><p>当我们所使用的lambda表达式仅仅调用了一个静态方法，我们就可以使用静态方法引用。如下所示，将lambda表达式（匿名类）中的值判断提取成isMoreThanFifty这个静态方法，就可以使用静态方法引用这种语法糖。</p><pre><code class="hljs reasonml">public <span class="hljs-keyword">class</span> Numbers &#123;    <span class="hljs-comment">//将值判断提取成静态方法</span>    public static boolean is<span class="hljs-constructor">MoreThanFifty(<span class="hljs-params">int</span> <span class="hljs-params">n1</span>, <span class="hljs-params">int</span> <span class="hljs-params">n2</span>)</span> &#123;        return (n1 + n2) &gt; <span class="hljs-number">50</span>;    &#125;    <span class="hljs-comment">//公共接口方法</span>    public static List&lt;Integer&gt; find<span class="hljs-constructor">Numbers(List&lt;Integer&gt; <span class="hljs-params">l</span>, BiPredicate&lt;Integer, Integer&gt; <span class="hljs-params">p</span>)</span> &#123;        List&lt;Integer&gt; newList = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;<span class="hljs-literal">()</span>;        for (Integer i : l) &#123;            <span class="hljs-keyword">if</span> (p.test(i, i + <span class="hljs-number">10</span>)) &#123;                newList.add(i);            &#125;        &#125;        return newList;    &#125;    public static void main(String<span class="hljs-literal">[]</span> args) &#123;        List&lt;Integer&gt; <span class="hljs-built_in">list</span> = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Arrays</span>.</span></span><span class="hljs-keyword">as</span><span class="hljs-constructor">List(12, 5, 45, 18, 33, 24, 40)</span>;        <span class="hljs-comment">// Using an anonymous class</span>        List&lt;Integer&gt; res = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Numbers</span>.</span></span>find<span class="hljs-constructor">Numbers(<span class="hljs-params">list</span>, <span class="hljs-params">new</span> BiPredicate&lt;Integer, Integer&gt;()</span> &#123;            @Override            public boolean test(Integer integer, Integer integer2) &#123;                return <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Numbers</span>.</span></span>is<span class="hljs-constructor">MoreThanFifty(<span class="hljs-params">integer</span>, <span class="hljs-params">integer2</span>)</span>;            &#125;        &#125;);        res.stream<span class="hljs-literal">()</span>.for<span class="hljs-constructor">Each(System.<span class="hljs-params">out</span> :: <span class="hljs-params">println</span>)</span>;<span class="hljs-comment">//        res.stream().peek(System.out :: println).collect(Collectors.toList());</span>        <span class="hljs-comment">// Using a lambda expression</span>        <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Numbers</span>.</span></span>find<span class="hljs-constructor">Numbers(<span class="hljs-params">list</span>, (<span class="hljs-params">i1</span>, <span class="hljs-params">i2</span>)</span> -&gt; <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Numbers</span>.</span></span>is<span class="hljs-constructor">MoreThanFifty(<span class="hljs-params">i1</span>, <span class="hljs-params">i2</span>)</span>);        <span class="hljs-comment">// Using a method reference</span>        <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Numbers</span>.</span></span>find<span class="hljs-constructor">Numbers(<span class="hljs-params">list</span>, Numbers::<span class="hljs-params">isMoreThanFifty</span>)</span>;    &#125;&#125;</code></pre><h2 id="特定类型的对象的实例方法的方法引用"><a href="#特定类型的对象的实例方法的方法引用" class="headerlink" title="特定类型的对象的实例方法的方法引用"></a>特定类型的对象的实例方法的方法引用</h2><pre><code class="hljs livescript"><span class="hljs-keyword">from</span><span class="hljs-function"><span class="hljs-params">(obj, args)</span> -&gt;</span> obj.instanceMethod(args)<span class="hljs-keyword">to</span>ObjectType::instanceMethod</code></pre><ul><li>我们使用实例的类型而非实例本身</li><li>参数隐式传递<pre><code class="hljs zephir"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">People</span> </span>&#123;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">double</span> calculateWeight() &#123;        <span class="hljs-keyword">double</span> weight = <span class="hljs-number">0</span>;        <span class="hljs-comment">// Calculate weight</span>        <span class="hljs-keyword">return</span> weight;    &#125;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">List</span>&lt;<span class="hljs-keyword">Double</span>&gt; calculateAllWeight(<span class="hljs-keyword">List</span>&lt;People&gt; l, <span class="hljs-function"><span class="hljs-keyword">Function</span>&lt;<span class="hljs-title">People</span>, <span class="hljs-title">Double</span>&gt; <span class="hljs-title">f</span>) </span>&#123;        <span class="hljs-keyword">List</span>&lt;<span class="hljs-keyword">Double</span>&gt; results = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();        <span class="hljs-keyword">for</span> (People s : l) &#123;            results.add(f.apply(s));        &#125;        <span class="hljs-keyword">return</span> results;    &#125;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PeopleClient</span> </span>&#123;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> void main(String[] args) &#123;        <span class="hljs-keyword">List</span>&lt;People&gt; <span class="hljs-keyword">list</span> = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();        People p = <span class="hljs-keyword">new</span> People();        <span class="hljs-comment">// Using an anonymous class</span>        p.calculateAllWeight(<span class="hljs-keyword">list</span>, <span class="hljs-keyword">new</span> <span class="hljs-function"><span class="hljs-keyword">Function</span>&lt;<span class="hljs-title">People</span>, <span class="hljs-title">Double</span>&gt;<span class="hljs-params">()</span> </span>&#123;            @Override            <span class="hljs-keyword">public</span> <span class="hljs-keyword">Double</span> apply(People people) &#123;<span class="hljs-comment">// The object</span>                <span class="hljs-keyword">return</span> people.calculateWeight();<span class="hljs-comment">// The method</span>            &#125;        &#125;);        <span class="hljs-comment">// Using a lambda expression</span>        p.calculateAllWeight(<span class="hljs-keyword">list</span>, people -&gt; people.calculateWeight());        <span class="hljs-comment">// Using a method reference</span>        p.calculateAllWeight(<span class="hljs-keyword">list</span>, People::calculateWeight);    &#125;&#125;</code></pre>在这个例子中，我们没有给方法传递任何参数，关键在于对象的实例是lambda表达式的一个参数，我们通过实例的类型来完成对实例方法的引用。下面是另一个例子，在这个例子中，我们向方法引用中传递了两个参数。<pre><code class="hljs lasso"><span class="hljs-comment">//java中有一个Function接口可以接收一个参数，BiFunction接口接受两个参数，没有接受三个参数的，所以我们自定义一个TriFunction</span>interface TriFunction&lt;T, U, V, R&gt; &#123;  R apply(T t, U u, V v);&#125;<span class="hljs-comment">//然后定义一个类，接收两个参数，并且有一个返回值</span>class <span class="hljs-keyword">Sum</span> &#123;  <span class="hljs-built_in">Integer</span> doSum(<span class="hljs-built_in">String</span> s1, <span class="hljs-built_in">String</span> s2) &#123;    <span class="hljs-keyword">return</span> <span class="hljs-built_in">Integer</span>.parseInt(s1) + <span class="hljs-built_in">Integer</span>.parseInt(s1);  &#125;&#125;<span class="hljs-comment">//用匿名类实现TriFunction，来包装doSum()</span>TriFunction&lt;<span class="hljs-keyword">Sum</span>, <span class="hljs-built_in">String</span>, <span class="hljs-built_in">String</span>, <span class="hljs-built_in">Integer</span>&gt; anonymous =  <span class="hljs-literal">new</span> TriFunction&lt;<span class="hljs-keyword">Sum</span>, <span class="hljs-built_in">String</span>, <span class="hljs-built_in">String</span>, <span class="hljs-built_in">Integer</span>&gt;() &#123;    @Override    <span class="hljs-keyword">public</span> <span class="hljs-built_in">Integer</span> apply(<span class="hljs-keyword">Sum</span> s, <span class="hljs-built_in">String</span> arg1, <span class="hljs-built_in">String</span> arg2) &#123;      <span class="hljs-keyword">return</span> s.doSum(arg1, arg2);    &#125;&#125;;System.out.println(anonymous.apply(<span class="hljs-literal">new</span> <span class="hljs-keyword">Sum</span>(), <span class="hljs-string">"1"</span>, <span class="hljs-string">"4"</span>));<span class="hljs-comment">//使用lambda表达式来包装</span>TriFunction&lt;<span class="hljs-keyword">Sum</span>, <span class="hljs-built_in">String</span>, <span class="hljs-built_in">String</span>, <span class="hljs-built_in">Integer</span>&gt; lambda =  (<span class="hljs-keyword">Sum</span> s, <span class="hljs-built_in">String</span> arg1, <span class="hljs-built_in">String</span> arg2) -&gt; s.doSum(arg1, arg2);System.out.println(lambda.apply(<span class="hljs-literal">new</span> <span class="hljs-keyword">Sum</span>(), <span class="hljs-string">"1"</span>, <span class="hljs-string">"4"</span>));<span class="hljs-comment">//使用方法引用</span>TriFunction&lt;<span class="hljs-keyword">Sum</span>, <span class="hljs-built_in">String</span>, <span class="hljs-built_in">String</span>, <span class="hljs-built_in">Integer</span>&gt; mRef = <span class="hljs-keyword">Sum</span><span class="hljs-type">::doSum</span>;System.out.println(mRef.apply(<span class="hljs-literal">new</span> <span class="hljs-keyword">Sum</span>(), <span class="hljs-string">"1"</span>, <span class="hljs-string">"4"</span>));</code></pre></li><li>第一个参数是要执行的方法的实例对象</li><li>第二、三个参数是传递的其他参数</li><li>最后一个参数是要执行的方法的返回值类型</li></ul><h2 id="已有对象的实例方法引用"><a href="#已有对象的实例方法引用" class="headerlink" title="已有对象的实例方法引用"></a>已有对象的实例方法引用</h2><pre><code class="hljs livescript"><span class="hljs-keyword">from</span><span class="hljs-function"><span class="hljs-params">(args)</span> -&gt;</span> obj.instanceMethod(args)<span class="hljs-keyword">to</span>obj::instanceMethod</code></pre><p>直接引用已经在其他地方实例化的对象的一个方法，本身不需要再实现一次</p><pre><code class="hljs arduino"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Car</span> &#123;</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> id;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">String</span> color;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getId</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> id;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setId</span><span class="hljs-params">(<span class="hljs-keyword">int</span> id)</span> </span>&#123;        <span class="hljs-keyword">this</span>.id = id;    &#125;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Mechanic</span> &#123;</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">fix</span><span class="hljs-params">(Car c)</span> </span>&#123;        System.out.<span class="hljs-built_in">println</span>(<span class="hljs-string">"Fixing car "</span> + c.getId());    &#125;&#125;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">InstanceRef</span> &#123;</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">String</span>[] args)</span> </span>&#123;        InstanceRef instanceRef = <span class="hljs-keyword">new</span> InstanceRef();        <span class="hljs-keyword">final</span> Mechanic mechanic = <span class="hljs-keyword">new</span> Mechanic();        Car car = <span class="hljs-keyword">new</span> Car();        <span class="hljs-comment">// Using an anonymous class</span>        instanceRef.execute(car, <span class="hljs-keyword">new</span> Consumer&lt;Car&gt;() &#123;            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> accept(Car c) &#123;                mechanic.fix(c);            &#125;        &#125;);        <span class="hljs-comment">// Using a lambda expression</span>        instanceRef.execute(car, car1 -&gt; mechanic.fix(car1));        <span class="hljs-comment">//Using a method reference</span>        instanceRef.execute(car, mechanic::fix);    &#125;    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">execute</span><span class="hljs-params">(Car car, Consumer&lt;Car&gt; c)</span> </span>&#123;        c.accept(car);    &#125;&#125;</code></pre><h2 id="构造方法引用"><a href="#构造方法引用" class="headerlink" title="构造方法引用"></a>构造方法引用</h2><pre><code class="hljs livescript"><span class="hljs-keyword">from</span><span class="hljs-function"><span class="hljs-params">(args)</span> -&gt;</span> <span class="hljs-keyword">new</span> ClassName(args)<span class="hljs-keyword">to</span>ClassName::<span class="hljs-keyword">new</span></code></pre><p>这个lambda表达式唯一能做的就是创建一个新对象，我们通过关键字new来引用类的构造函数。与其他情况一样，参数（如果有）不会在方法引用中传递。</p><p><strong>无参构造</strong></p><pre><code class="hljs dart"><span class="hljs-comment">// Using an anonymous class</span>Supplier&lt;<span class="hljs-built_in">List</span>&lt;<span class="hljs-built_in">String</span>&gt;&gt; s = <span class="hljs-keyword">new</span> Supplier() &#123;  public <span class="hljs-built_in">List</span>&lt;<span class="hljs-built_in">String</span>&gt; <span class="hljs-keyword">get</span>() &#123;    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ArrayList&lt;<span class="hljs-built_in">String</span>&gt;();  &#125;&#125;;<span class="hljs-built_in">List</span>&lt;<span class="hljs-built_in">String</span>&gt; l = s.<span class="hljs-keyword">get</span>();<span class="hljs-comment">// Using a lambda expression</span>Supplier&lt;<span class="hljs-built_in">List</span>&lt;<span class="hljs-built_in">String</span>&gt;&gt; s = () -&gt; <span class="hljs-keyword">new</span> ArrayList&lt;<span class="hljs-built_in">String</span>&gt;();<span class="hljs-built_in">List</span>&lt;<span class="hljs-built_in">String</span>&gt; l = s.<span class="hljs-keyword">get</span>();<span class="hljs-comment">// Using a method reference</span>Supplier&lt;<span class="hljs-built_in">List</span>&lt;<span class="hljs-built_in">String</span>&gt;&gt; s = ArrayList::<span class="hljs-keyword">new</span>;<span class="hljs-built_in">List</span>&lt;<span class="hljs-built_in">String</span>&gt; l = s.<span class="hljs-keyword">get</span>();</code></pre><p><strong>带参构造</strong></p><pre><code class="hljs lasso"><span class="hljs-comment">// Using a anonymous class</span>BiFunction&lt;<span class="hljs-built_in">String</span>, <span class="hljs-built_in">String</span>, <span class="hljs-built_in">Locale</span>&gt; f = <span class="hljs-literal">new</span> BiFunction&lt;<span class="hljs-built_in">String</span>, <span class="hljs-built_in">String</span>, <span class="hljs-built_in">Locale</span>&gt;() &#123;  <span class="hljs-keyword">public</span> <span class="hljs-built_in">Locale</span> apply(<span class="hljs-built_in">String</span> lang, <span class="hljs-built_in">String</span> country) &#123;    <span class="hljs-keyword">return</span> <span class="hljs-literal">new</span> <span class="hljs-built_in">Locale</span>(lang, country);  &#125;&#125;;<span class="hljs-built_in">Locale</span> loc = f.apply(<span class="hljs-string">"en"</span>,<span class="hljs-string">"UK"</span>);<span class="hljs-comment">// Using a lambda expression</span>BiFunction&lt;<span class="hljs-built_in">String</span>, <span class="hljs-built_in">String</span>, <span class="hljs-built_in">Locale</span>&gt; f = (lang, country) -&gt; <span class="hljs-literal">new</span> <span class="hljs-built_in">Locale</span>(lang, country);<span class="hljs-built_in">Locale</span> loc = f.apply(<span class="hljs-string">"en"</span>,<span class="hljs-string">"UK"</span>);<span class="hljs-comment">// Using a method reference</span>BiFunction&lt;<span class="hljs-built_in">String</span>, <span class="hljs-built_in">String</span>, <span class="hljs-built_in">Locale</span>&gt; f = <span class="hljs-built_in">Locale</span><span class="hljs-type">::new</span>;<span class="hljs-built_in">Locale</span> loc = f.apply(<span class="hljs-string">"en"</span>,<span class="hljs-string">"UK"</span>);</code></pre><p>如果有三个及以上的参数的构造函数，则必须创建自己的函数接口。引用构造函数与引用静态方法非常相似，区别在于构造函数“方法名称”是new。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>如果使用了方法引用之后能让代码变的更加整洁，就使用它。实际使用中，一种使用方式是将代码包裹在一个方法中，而非使用一个单独的类或者lambda表达式，然后使用方法引用的方式进行调用。方法引用常用于java8的另一种新特性Streams中，而基于方法引用的设计模式也会更加具有拓展性。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;什么是方法引用&quot;&gt;&lt;a href=&quot;#什么是方法引用&quot; class=&quot;headerlink&quot; title=&quot;什么是方法引用?&quot;&gt;&lt;/a&gt;什么是方法引用?&lt;/h2&gt;&lt;p&gt;方法引用可用于在不调用方法的情况下引用方法。它将方法视为Lambda表达式。它们只能作为语法糖来
      
    
    </summary>
    
    
      <category term="java" scheme="http://yoursite.com/categories/java/"/>
    
    
      <category term="stream" scheme="http://yoursite.com/tags/stream/"/>
    
  </entry>
  
  <entry>
    <title>java8新特性之Stream</title>
    <link href="http://yoursite.com/2020/05/31/java8%E6%96%B0%E7%89%B9%E6%80%A7%E4%B9%8BStream/"/>
    <id>http://yoursite.com/2020/05/31/java8%E6%96%B0%E7%89%B9%E6%80%A7%E4%B9%8BStream/</id>
    <published>2020-05-31T04:07:12.000Z</published>
    <updated>2020-05-31T04:09:19.626Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>Stream API与InputStream和OutputStream是完全不同的概念，<strong>Stream API是对Java中集合操作的增强，可以利用它进行各种过滤、排序、分组、聚合等操作</strong>。Stream API配合Lambda表达式可以加大的提高代码可读性和编码效率，Stream API也支持并行操作。</p><h3 id="流不是集合，它不关心数据的存放，只关注如何处理数据"><a href="#流不是集合，它不关心数据的存放，只关注如何处理数据" class="headerlink" title="流不是集合，它不关心数据的存放，只关注如何处理数据"></a>流不是集合，它不关心数据的存放，只关注如何处理数据</h3><p>Stream API主要用于处理集合操作，不过它的处理方式与传统的方式不同，称为“数据流处理”。流（Stream）类似于关系数据库的查询操作，是一种声明式操作。比如要从数据库中获取所有年龄大于20岁的用户的名称，并按照用户的创建时间进行排序，用一条SQL语句就可以搞定，不过使用Java程序实现就会显得有些繁琐，这时候可以使用流：</p><pre><code class="hljs lasso"><span class="hljs-built_in">List</span>&lt;<span class="hljs-built_in">String</span>&gt; userNames = users.stream()    .filter(user -&gt; user.getAge() &gt; <span class="hljs-number">20</span>)    .sorted(comparing(User<span class="hljs-type">::getCreationDate</span>))    .<span class="hljs-built_in">map</span>(User<span class="hljs-type">::getUserName</span>)    .collect(toList());</code></pre><p>在Java中，集合是一种数据结构，或者说是一种容器，用于存放数据，流不是容器，它不关心数据的存放，只关注如何处理。可以把流当做是Java中的Iterator，不过它比Iterator强大多了。</p><h3 id="流使用内部迭代方式处理数据"><a href="#流使用内部迭代方式处理数据" class="headerlink" title="流使用内部迭代方式处理数据"></a>流使用内部迭代方式处理数据</h3><p>流与集合另一个区别在于他们的遍历方式，遍历集合通常使用for-each方式，这种方式称为外部迭代，而流使用内部迭代方式，也就是说它帮你把迭代的工作做了，你只需要给出一个函数来告诉它接下来要干什么：</p><pre><code class="hljs reasonml"><span class="hljs-comment">// 外部迭代</span>List&lt;String&gt; <span class="hljs-built_in">list</span> = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Arrays</span>.</span></span><span class="hljs-keyword">as</span><span class="hljs-constructor">List(<span class="hljs-string">"A"</span>, <span class="hljs-string">"B"</span>, <span class="hljs-string">"C"</span>, <span class="hljs-string">"D"</span>)</span>;for (String str : <span class="hljs-built_in">list</span>) &#123;    <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(str);&#125;<span class="hljs-comment">// 内部迭代</span><span class="hljs-built_in">list</span>.stream<span class="hljs-literal">()</span>.for<span class="hljs-constructor">Each(System.<span class="hljs-params">out</span>::<span class="hljs-params">println</span>)</span>;</code></pre><p>外部迭代更像是作文题，我们不仅要控制元素的迭代方式，还需要定义怎么操作元素；内部迭代更像是填空题，我们只用关注如何操作元素就可以了。</p><h3 id="流只能遍历一次"><a href="#流只能遍历一次" class="headerlink" title="流只能遍历一次"></a>流只能遍历一次</h3><p>流只能遍历一次，遍历结束后，这个流就被关闭掉了。如果要重新遍历，可以从数据源（集合）中重新获取一个流。如果你对一个流遍历两次，就会抛出java.lang.IllegalStateException异常：</p><pre><code class="hljs reasonml">List&lt;String&gt; <span class="hljs-built_in">list</span> = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Arrays</span>.</span></span><span class="hljs-keyword">as</span><span class="hljs-constructor">List(<span class="hljs-string">"A"</span>, <span class="hljs-string">"B"</span>, <span class="hljs-string">"C"</span>, <span class="hljs-string">"D"</span>)</span>;Stream&lt;String&gt; stream = <span class="hljs-built_in">list</span>.stream<span class="hljs-literal">()</span>;stream.for<span class="hljs-constructor">Each(System.<span class="hljs-params">out</span>::<span class="hljs-params">println</span>)</span>;stream.for<span class="hljs-constructor">Each(System.<span class="hljs-params">out</span>::<span class="hljs-params">println</span>)</span>; <span class="hljs-comment">// 这里会抛出java.lang.IllegalStateException异常，因为流已经被关闭</span></code></pre><h3 id="流通常由三部分构成："><a href="#流通常由三部分构成：" class="headerlink" title="流通常由三部分构成："></a>流通常由三部分构成：</h3><ol><li>数据源：数据源一般用于流的获取，比如本文开头那个过滤用户的例子中users.stream()方法。</li><li>中间处理：中间处理包括对流中元素的一系列处理，如：过滤（filter()），映射（map()），排序（sorted()）。</li><li>终端处理：终端处理会生成结果，结果可以是任何不是流值，如List<String>；也可以不返回结果，如stream.forEach(System.out::println)就是将结果打印到控制台中，并没有返回。</String></li></ol><h2 id="创建流"><a href="#创建流" class="headerlink" title="创建流"></a>创建流</h2><h3 id="由值创建流"><a href="#由值创建流" class="headerlink" title="由值创建流"></a>由值创建流</h3><p>使用静态方法Stream.of()创建流，该方法接收一个变长参数：</p><pre><code class="hljs arduino"><span class="hljs-built_in">Stream</span>&lt;<span class="hljs-built_in">Stream</span>&gt; stream = <span class="hljs-built_in">Stream</span>.of(<span class="hljs-string">"A"</span>, <span class="hljs-string">"B"</span>, <span class="hljs-string">"C"</span>, <span class="hljs-string">"D"</span>);<span class="hljs-comment">//也可以使用静态方法Stream.empty()创建一个空的流：</span><span class="hljs-built_in">Stream</span>&lt;<span class="hljs-built_in">Stream</span>&gt; stream = <span class="hljs-built_in">Stream</span>.empty();</code></pre><h3 id="由数组、集合-创建流"><a href="#由数组、集合-创建流" class="headerlink" title="由数组、集合 创建流"></a>由数组、集合 创建流</h3><p>使用静态方法Arrays.stream()从数组创建一个流，该方法接收一个数组参数：</p><pre><code class="hljs armasm"><span class="hljs-keyword">String[] </span><span class="hljs-keyword">strs </span>= &#123;<span class="hljs-string">"A"</span>, <span class="hljs-string">"B"</span>, <span class="hljs-string">"C"</span>, <span class="hljs-string">"D"</span>&#125;<span class="hljs-comment">;</span><span class="hljs-keyword">Stream&lt;Stream&gt; </span><span class="hljs-keyword">stream </span>= Arrays.<span class="hljs-keyword">stream(strs);</span></code></pre><h3 id="通过文件生成流"><a href="#通过文件生成流" class="headerlink" title="通过文件生成流"></a>通过文件生成流</h3><p>使用java.nio.file.Files类中的很多静态方法都可以获取流，比如Files.lines()方法，该方法接收一个java.nio.file.Path对象，返回一个由文件行构成的字符串流：</p><pre><code class="hljs reasonml">Stream&lt;String&gt; stream = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Files</span>.</span></span>lines(<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Paths</span>.</span></span>get(<span class="hljs-string">"text.txt"</span>), <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Charset</span>.</span></span>default<span class="hljs-constructor">Charset()</span>);</code></pre><h3 id="通过函数创建流"><a href="#通过函数创建流" class="headerlink" title="通过函数创建流"></a>通过函数创建流</h3><p>java.util.stream.Stream中有两个静态方法用于从函数生成流，他们分别是Stream.generate()和Stream.iterate()：</p><pre><code class="hljs reasonml"><span class="hljs-comment">// iteartor 打印100以内的所有偶数</span><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Stream</span>.</span></span>iterate(<span class="hljs-number">0</span>, n -&gt; n + <span class="hljs-number">2</span>).limit(<span class="hljs-number">51</span>).for<span class="hljs-constructor">Each(System.<span class="hljs-params">out</span>::<span class="hljs-params">println</span>)</span>;<span class="hljs-comment">// generate 打印10个Hello Man!</span><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Stream</span>.</span></span>generate(<span class="hljs-literal">()</span> -&gt; <span class="hljs-string">"Hello Man!"</span>).limit(<span class="hljs-number">10</span>).for<span class="hljs-constructor">Each(System.<span class="hljs-params">out</span>::<span class="hljs-params">println</span>)</span>;</code></pre><p>值得注意的是，这两个方法生成的流都是无限流，没有固定大小，可以无穷的计算下去，可以使用limit()来限制边界。</p><pre><code class="hljs reasonml"><span class="hljs-comment">//一般来说，iterate()用于生成一系列值，比如生成以当前时间开始之后的10天的日期：</span><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Stream</span>.</span></span>iterate(<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">LocalDate</span>.</span></span>now<span class="hljs-literal">()</span>, date -&gt; date.plus<span class="hljs-constructor">Days(1)</span>).limit(<span class="hljs-number">10</span>).for<span class="hljs-constructor">Each(System.<span class="hljs-params">out</span>::<span class="hljs-params">println</span>)</span>;<span class="hljs-comment">//generate()方法用于生成一些随机数，比如生成10个UUID：</span><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Stream</span>.</span></span>generate(<span class="hljs-literal">()</span> -&gt; <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">UUID</span>.</span></span>random<span class="hljs-constructor">UUID()</span>.<span class="hljs-keyword">to</span><span class="hljs-constructor">String()</span>).limit(<span class="hljs-number">10</span>).for<span class="hljs-constructor">Each(System.<span class="hljs-params">out</span>::<span class="hljs-params">println</span>)</span>;</code></pre><h3 id="collect-toList-将流中的值转换为集合"><a href="#collect-toList-将流中的值转换为集合" class="headerlink" title="collect(toList())将流中的值转换为集合"></a>collect(toList())将流中的值转换为集合</h3><pre><code class="hljs reasonml"><span class="hljs-comment">//of从初识值生成新的stream，再通过collect(toList())生成新的集合</span>List&lt;String&gt; collect = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Stream</span>.</span></span><span class="hljs-keyword">of</span>(<span class="hljs-string">"aa"</span>, <span class="hljs-string">"bb"</span>, <span class="hljs-string">"cc"</span>, <span class="hljs-string">"aa"</span>, <span class="hljs-string">"bb"</span>).collect(<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Collectors</span>.</span></span><span class="hljs-keyword">to</span><span class="hljs-constructor">List()</span>);</code></pre><p>of是惰性求值，不生成新的集合，通过collect(toList())这种及早求值才生成新的集合。返回值是stream就是惰性求值，返回值为另一个值或者空就是及早求值。</p><h3 id="惰性求值与及早求值的区别"><a href="#惰性求值与及早求值的区别" class="headerlink" title="惰性求值与及早求值的区别"></a>惰性求值与及早求值的区别</h3><pre><code class="hljs processing"><span class="hljs-comment">//如下加count就是及早求值，会sout输出strs。不加count，程序不输出任何信息</span>strs.stream().<span class="hljs-built_in">filter</span>(<span class="hljs-built_in">str</span> -&gt; &#123;    System.out.<span class="hljs-built_in">println</span>(<span class="hljs-built_in">str</span>);    <span class="hljs-keyword">return</span> <span class="hljs-built_in">str</span>.startsWith(<span class="hljs-string">"a"</span>);&#125;).count();</code></pre><p>过滤+计数，只循环了一次。只执行fileter会返回一个stream，他不是一个新集合，仅仅是创建新集合的配方。</p><h2 id="流常用方法"><a href="#流常用方法" class="headerlink" title="流常用方法"></a>流常用方法</h2><h3 id="过滤和排序"><a href="#过滤和排序" class="headerlink" title="过滤和排序"></a>过滤和排序</h3><pre><code class="hljs angelscript">Stream.of(<span class="hljs-number">1</span>, <span class="hljs-number">8</span>, <span class="hljs-number">5</span>, <span class="hljs-number">2</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">9</span>, <span class="hljs-number">2</span>, <span class="hljs-number">0</span>, <span class="hljs-number">4</span>, <span class="hljs-number">8</span>)    .filter(n -&gt; n &gt; <span class="hljs-number">2</span>)     <span class="hljs-comment">// 对元素过滤，保留大于2的元素</span>    .distinct()             <span class="hljs-comment">// 去重，类似于SQL语句中的DISTINCT</span>    .skip(<span class="hljs-number">1</span>)                <span class="hljs-comment">// 跳过前面1个元素</span>    .limit(<span class="hljs-number">2</span>)               <span class="hljs-comment">// 返回开头2个元素，类似于SQL语句中的SELECT TOP</span>    .sorted()               <span class="hljs-comment">// 对结果排序</span>    .forEach(System.<span class="hljs-keyword">out</span>::println);</code></pre><p>filter 对集合的值进行过滤，必须返回true或者false</p><h3 id="查找和匹配"><a href="#查找和匹配" class="headerlink" title="查找和匹配"></a>查找和匹配</h3><pre><code class="hljs reasonml"><span class="hljs-comment">//检查流中的任意元素是否包含字符串"PHP"</span>boolean match1 = get<span class="hljs-constructor">Stream()</span>.any<span class="hljs-constructor">Match(<span class="hljs-params">s</span> -&gt; <span class="hljs-params">s</span>.<span class="hljs-params">equals</span>(<span class="hljs-string">"PHP"</span>)</span>);<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(match1);boolean match2 = get<span class="hljs-constructor">Stream()</span>.collect(<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Collectors</span>.</span></span><span class="hljs-keyword">to</span><span class="hljs-constructor">List()</span>).contains(<span class="hljs-string">"PHP"</span>);<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(match2);<span class="hljs-comment">// 检查流中的所有元素是否都包含字符串"#"</span>boolean hasAllMatch = get<span class="hljs-constructor">Stream()</span>.all<span class="hljs-constructor">Match(<span class="hljs-params">s</span> -&gt; <span class="hljs-params">s</span>.<span class="hljs-params">contains</span>(<span class="hljs-string">"#"</span>)</span>);<span class="hljs-comment">// 检查流中的任意元素是否没有以"C"开头的字符串</span>boolean hasNoneMatch = get<span class="hljs-constructor">Stream()</span>.none<span class="hljs-constructor">Match(<span class="hljs-params">s</span> -&gt; <span class="hljs-params">s</span>.<span class="hljs-params">startsWith</span>(<span class="hljs-string">"C"</span>)</span>);<span class="hljs-comment">// 查找元素</span>Optional&lt;String&gt; element = get<span class="hljs-constructor">Stream()</span>.ilter(s -&gt; s.contains(<span class="hljs-string">"C"</span>))    <span class="hljs-comment">// .findFirst()     // 查找第一个元素</span>    .find<span class="hljs-constructor">Any()</span>;         <span class="hljs-comment">// 查找任意元素</span> <span class="hljs-comment">//获取初始流   </span><span class="hljs-keyword">private</span> static Stream&lt;String&gt; get<span class="hljs-constructor">Stream()</span> &#123;    return <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Stream</span>.</span></span><span class="hljs-keyword">of</span>(<span class="hljs-string">"Java"</span>, <span class="hljs-string">"C#"</span>, <span class="hljs-string">"PHP"</span>, <span class="hljs-string">"C++"</span>, <span class="hljs-string">"Python"</span>);&#125;</code></pre><ol><li>每次都需要重新getStream()来获取新的流，因为之前的流已经使用并且关闭了。可以理解为若返回值不是stream，则表示已经结束了流操作</li><li>findAny的返回类型是一个Optional<T>类（java.util.Optional），它一个容器类，代表一个值存在或不存在，用来避免控制正异常。</T></li><li>findFirst()和findAny()返回的都是第一个元素，通过查看javadoc描述，大致意思是findAny()是为了提高并行操作时的性能。数据大时可findany。</li></ol><h3 id="归约"><a href="#归约" class="headerlink" title="归约"></a>归约</h3><p>归约操作就是将流中的元素进行合并，形成一个新的值，常见的归约操作包括求和，求最大值或最小值。归约操作一般使用reduce()方法，与map()方法搭配使用，可以处理一些很复杂的归约操作。</p><pre><code class="hljs lasso"><span class="hljs-comment">// 获取流</span><span class="hljs-built_in">List</span>&lt;Book&gt; books = Arrays.asList(   <span class="hljs-literal">new</span> Book(<span class="hljs-string">"Java编程思想"</span>, <span class="hljs-string">"Bruce Eckel"</span>, <span class="hljs-string">"机械工业出版社"</span>, <span class="hljs-number">108.00</span>D),   <span class="hljs-literal">new</span> Book(<span class="hljs-string">"Java 8实战"</span>, <span class="hljs-string">"Mario Fusco"</span>, <span class="hljs-string">"人民邮电出版社"</span>, <span class="hljs-number">79.00</span>D),   <span class="hljs-literal">new</span> Book(<span class="hljs-string">"MongoDB权威指南（第2版）"</span>, <span class="hljs-string">"Kristina Chodorow"</span>, <span class="hljs-string">"人民邮电出版社"</span>, <span class="hljs-number">69.00</span>D));<span class="hljs-comment">// 计算所有图书的总价</span>Optional&lt;Double&gt; totalPrice = books.stream()       .<span class="hljs-built_in">map</span>(Book<span class="hljs-type">::getPrice</span>)       .reduce((n, m) -&gt; n + m);<span class="hljs-comment">// 价格最高的图书</span>Optional&lt;Book&gt; expensive = books.stream().<span class="hljs-keyword">max</span>(Comparator.comparing(Book<span class="hljs-type">::getPrice</span>));<span class="hljs-comment">// 价格最低的图书</span>Optional&lt;Book&gt; cheapest = books.stream().<span class="hljs-keyword">min</span>(Comparator.comparing(Book<span class="hljs-type">::getPrice</span>));<span class="hljs-comment">// 计算总数</span>long count = books.stream().count()</code></pre><h3 id="reduce从一组值中生成一个值，如累加。"><a href="#reduce从一组值中生成一个值，如累加。" class="headerlink" title="reduce从一组值中生成一个值，如累加。"></a>reduce从一组值中生成一个值，如累加。</h3><pre><code class="hljs angelscript"><span class="hljs-comment">//0初始值，total总值，index循环的每一个值。</span>Integer num = Stream.of(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>).reduce(<span class="hljs-number">0</span>, (total, index) -&gt; total + index);</code></pre><h3 id="max-min-传入comparator进行大小比较，返回Optional对象"><a href="#max-min-传入comparator进行大小比较，返回Optional对象" class="headerlink" title="max(min) 传入comparator进行大小比较，返回Optional对象"></a>max(min) 传入comparator进行大小比较，返回Optional对象</h3><pre><code class="hljs maxima">//Optional对象(代表一个可能存在也可能不存在的值，NPE方案),通过<span class="hljs-built_in">get</span>拿到Optional对象中的值Integer <span class="hljs-built_in">integer</span> = Stream.of(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>).<span class="hljs-built_in">min</span>(Comparator.comparing(<span class="hljs-built_in">num</span> -&gt; <span class="hljs-built_in">num</span>)).<span class="hljs-built_in">get</span>();</code></pre><h3 id="map-将流中的值转换为新值"><a href="#map-将流中的值转换为新值" class="headerlink" title="map 将流中的值转换为新值"></a>map 将流中的值转换为新值</h3><pre><code class="hljs reasonml"><span class="hljs-comment">//将list小写处理成大写</span><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Stream</span>.</span></span><span class="hljs-keyword">of</span>(<span class="hljs-string">"aa"</span>, <span class="hljs-string">"bb"</span>, <span class="hljs-string">"cc"</span>, <span class="hljs-string">"aa"</span>, <span class="hljs-string">"bb"</span>).map(str -&gt; str.<span class="hljs-keyword">to</span><span class="hljs-constructor">UpperCase()</span>).collect(<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Collectors</span>.</span></span><span class="hljs-keyword">to</span><span class="hljs-constructor">List()</span>);</code></pre><h3 id="flatmap-把多个stream合并成一个stream并返回"><a href="#flatmap-把多个stream合并成一个stream并返回" class="headerlink" title="flatmap 把多个stream合并成一个stream并返回"></a>flatmap 把多个stream合并成一个stream并返回</h3><p>与map()方法类似的还有一个flatMap()，flatMap()方法让你把一个流中的每个值都换成另一个流，然后把所有的流连接起来成为一个新的流。</p><pre><code class="hljs reasonml"><span class="hljs-comment">//传统for循环</span>List&lt;String&gt; names0 = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;<span class="hljs-literal">()</span>;for (Company company : data) &#123;    List&lt;User&gt; users = company.get<span class="hljs-constructor">Uesrs()</span>;    for (User user : users) &#123;        <span class="hljs-keyword">if</span> (user.get<span class="hljs-constructor">Age()</span> &gt; <span class="hljs-number">30</span>) &#123;            names0.add(user.get<span class="hljs-constructor">Name()</span>);        &#125;    &#125;&#125;<span class="hljs-comment">//lambda方式1</span>List&lt;String&gt; names1 = data.stream<span class="hljs-literal">()</span>    .flat<span class="hljs-constructor">Map(<span class="hljs-params">company</span> -&gt; <span class="hljs-params">company</span>.<span class="hljs-params">getUesrs</span>()</span>.stream<span class="hljs-literal">()</span>)    .filter(user -&gt; user.get<span class="hljs-constructor">Age()</span> &gt; <span class="hljs-number">30</span>)    .map(user -&gt; user.get<span class="hljs-constructor">Name()</span>)    .collect(<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Collectors</span>.</span></span><span class="hljs-keyword">to</span><span class="hljs-constructor">List()</span>);<span class="hljs-comment">//lambda方式2</span>List&lt;String&gt; names2 = data.stream<span class="hljs-literal">()</span>    .map(Company::getUesrs)    .flat<span class="hljs-constructor">Map(Collection::<span class="hljs-params">stream</span>)</span>    .filter(user -&gt; user.get<span class="hljs-constructor">Age()</span> &gt; <span class="hljs-number">30</span>)    .map(User::getName)    .collect(<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Collectors</span>.</span></span><span class="hljs-keyword">to</span><span class="hljs-constructor">List()</span>);</code></pre><p>使用flatMap()方法的效果是，各个数组并不是分别映射成一个流，而是映射成流的内容。所有使用map(Arrays::stream)时生成的单个流都被合并起来，也就是对流扁平化操作。</p><h3 id="peek-用于记录中间值（输出流中的值），不会改变流。一般用作日志输出，断点调试。"><a href="#peek-用于记录中间值（输出流中的值），不会改变流。一般用作日志输出，断点调试。" class="headerlink" title="peek 用于记录中间值（输出流中的值），不会改变流。一般用作日志输出，断点调试。"></a>peek 用于记录中间值（输出流中的值），不会改变流。一般用作日志输出，断点调试。</h3><pre><code class="hljs reasonml">List&lt;Integer&gt; nums = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Stream</span>.</span></span><span class="hljs-keyword">of</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>).collect(<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Collectors</span>.</span></span><span class="hljs-keyword">to</span><span class="hljs-constructor">List()</span>);nums.stream<span class="hljs-literal">()</span>.filter(num -&gt; num &gt; <span class="hljs-number">3</span>).peek(num -&gt; &#123;    <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(num);&#125;).collect(<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Collectors</span>.</span></span><span class="hljs-keyword">to</span><span class="hljs-constructor">List()</span>);</code></pre><h2 id="数据收集"><a href="#数据收集" class="headerlink" title="数据收集"></a>数据收集</h2><p>前面总结了如何创建流以及流处理，接下来总结下数据收集。数据收集是流式数据处理的终端处理，<strong>与中间处理不同的是，终端处理会消耗流，也就是说，终端处理之后，这个流就会被关闭，如果再进行中间处理，就会抛出异常</strong>。数据收集主要使用collect方法，该方法也属于归约操作，像reduce()方法那样可以接收各种做法作为参数，将流中的元素累积成一个汇总结果，具体的做法是通过定义新的Collector接口来定义的。</p><h3 id="可以静态导入Collectors和Comparator两个类，这样就不用再去写Collectors-counting-和Comparator-comparing-。"><a href="#可以静态导入Collectors和Comparator两个类，这样就不用再去写Collectors-counting-和Comparator-comparing-。" class="headerlink" title="可以静态导入Collectors和Comparator两个类，这样就不用再去写Collectors.counting()和Comparator.comparing()。"></a>可以静态导入Collectors和Comparator两个类，这样就不用再去写Collectors.counting()和Comparator.comparing()。</h3><pre><code class="hljs gradle"><span class="hljs-keyword">import</span> <span class="hljs-keyword">static</span> java.util.stream.Collectors.*;<span class="hljs-keyword">import</span> <span class="hljs-keyword">static</span> java.util.Comparator.*;<span class="hljs-comment">// 求和</span><span class="hljs-keyword">long</span> <span class="hljs-keyword">count</span> = books.stream().<span class="hljs-keyword">collect</span>(counting());<span class="hljs-comment">// 价格最高的图书</span>Optional&lt;Book&gt; expensive = books.stream().<span class="hljs-keyword">collect</span>(maxBy(comparing(Book::getPrice)));<span class="hljs-comment">// 价格最低的图书</span>Optional&lt;Book&gt; cheapest = books.stream().<span class="hljs-keyword">collect</span>(minBy(comparing(Book::getPrice)));</code></pre><h3 id="收集顺序"><a href="#收集顺序" class="headerlink" title="收集顺序"></a>收集顺序</h3><pre><code class="hljs plain">进有序，出有序；进无序，出无序。</code></pre><h3 id="特定收集器"><a href="#特定收集器" class="headerlink" title="特定收集器"></a>特定收集器</h3><pre><code class="hljs reasonml">stream.collect(<span class="hljs-keyword">to</span><span class="hljs-constructor">Collection(TreeSet::<span class="hljs-params">new</span>)</span>);</code></pre><h3 id="字符串操作joining"><a href="#字符串操作joining" class="headerlink" title="字符串操作joining"></a>字符串操作joining</h3><pre><code class="hljs reasonml"><span class="hljs-comment">//将流中的字符串通过逗号连接成一个新的字符串</span>String str = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Stream</span>.</span></span><span class="hljs-keyword">of</span>(<span class="hljs-string">"A"</span>, <span class="hljs-string">"B"</span>, <span class="hljs-string">"C"</span>, <span class="hljs-string">"D"</span>).collect(joining(<span class="hljs-string">","</span>));List&lt;Integer&gt; data = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Stream</span>.</span></span><span class="hljs-keyword">of</span>(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>).collect(<span class="hljs-keyword">to</span><span class="hljs-constructor">List()</span>);List&lt;Integer&gt; integers = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Arrays</span>.</span></span><span class="hljs-keyword">as</span><span class="hljs-constructor">List(1, 2, 3, 4, 5)</span>;<span class="hljs-comment">//前后缀拼接</span><span class="hljs-comment">//传统for循环</span>StringBuilder sb = <span class="hljs-keyword">new</span> <span class="hljs-constructor">StringBuilder(<span class="hljs-string">"["</span>)</span>;for (Integer num : integers) &#123;    sb.append(num).append(<span class="hljs-string">", "</span>);&#125;sb.append(<span class="hljs-string">"]"</span>);<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(sb);<span class="hljs-comment">//lambda循环（map是为了将int转为string）</span>String str = data.stream<span class="hljs-literal">()</span>.map(String::valueOf).collect(joining(<span class="hljs-string">","</span>, <span class="hljs-string">"["</span>, <span class="hljs-string">"]"</span>));<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(str);</code></pre><h3 id="数据分块（parttitioningBy，将流分解成两个集合），传入一个pridicate对象来判断属于哪部分。"><a href="#数据分块（parttitioningBy，将流分解成两个集合），传入一个pridicate对象来判断属于哪部分。" class="headerlink" title="数据分块（parttitioningBy，将流分解成两个集合），传入一个pridicate对象来判断属于哪部分。"></a>数据分块（parttitioningBy，将流分解成两个集合），传入一个pridicate对象来判断属于哪部分。</h3><pre><code class="hljs pgsql">//数据分块：将数据分成<span class="hljs-keyword">true</span>和<span class="hljs-keyword">false</span>两部分Map&lt;<span class="hljs-type">Boolean</span>, List&lt;<span class="hljs-keyword">User</span>&gt;&gt; res = users.stream().collect(partitioningBy(<span class="hljs-keyword">user</span> -&gt; <span class="hljs-keyword">user</span>.getName().length() &gt; <span class="hljs-number">3</span>));</code></pre><h3 id="数据分组（groupingBy）"><a href="#数据分组（groupingBy）" class="headerlink" title="数据分组（groupingBy）"></a>数据分组（groupingBy）</h3><pre><code class="hljs lasso"><span class="hljs-comment">//数据分组：将数据以某个key值分成多部分</span><span class="hljs-built_in">Map</span>&lt;<span class="hljs-built_in">String</span>, <span class="hljs-built_in">List</span>&lt;User&gt;&gt; result = users.stream().collect(groupingBy(user -&gt; user.getAddress()));<span class="hljs-built_in">Map</span>&lt;<span class="hljs-built_in">String</span>, <span class="hljs-built_in">List</span>&lt;User&gt;&gt; result = users.stream().collect(groupingBy(User<span class="hljs-type">::getAddress</span>));</code></pre><h3 id="组合收集器（下游收集器），在主收集器中应用下级收集器，对结果进行再次封装。"><a href="#组合收集器（下游收集器），在主收集器中应用下级收集器，对结果进行再次封装。" class="headerlink" title="组合收集器（下游收集器），在主收集器中应用下级收集器，对结果进行再次封装。"></a>组合收集器（下游收集器），在主收集器中应用下级收集器，对结果进行再次封装。</h3><pre><code class="hljs reasonml"><span class="hljs-comment">//将数据分组后，不是返回每组的数据，而是统计每组的个数返回。</span>Map&lt;String, Long&gt; collect1 = users.stream<span class="hljs-literal">()</span>.collect(grouping<span class="hljs-constructor">By(User::<span class="hljs-params">getName</span>, <span class="hljs-params">counting</span>()</span>));<span class="hljs-comment">//通过mapping可以进行其他二次收集。</span>Map&lt;String, List&lt;String&gt;&gt; collect2 = users.stream<span class="hljs-literal">()</span>.collect(grouping<span class="hljs-constructor">By(User::<span class="hljs-params">getAddress</span>, <span class="hljs-params">mapping</span>(User::<span class="hljs-params">getName</span>, <span class="hljs-params">toList</span>()</span>) ));函数拆分示例：collect( grouping<span class="hljs-constructor">By(<span class="hljs-params">key1</span>,  <span class="hljs-params">mapping</span>(<span class="hljs-params">key2</span>,  <span class="hljs-params">value</span>)</span>  )  )</code></pre><h2 id="进阶集合操作"><a href="#进阶集合操作" class="headerlink" title="进阶集合操作"></a>进阶集合操作</h2><h3 id="map的foreach循环"><a href="#map的foreach循环" class="headerlink" title="map的foreach循环"></a>map的foreach循环</h3><pre><code class="hljs lasso"><span class="hljs-built_in">Map</span>&lt;<span class="hljs-built_in">String</span>, <span class="hljs-built_in">Integer</span>&gt; <span class="hljs-keyword">cache</span> = <span class="hljs-literal">new</span> HashMap&lt;&gt;();<span class="hljs-built_in">Map</span>&lt;<span class="hljs-built_in">String</span>, <span class="hljs-built_in">List</span>&lt;User&gt;&gt; users = <span class="hljs-literal">new</span> HashMap&lt;<span class="hljs-built_in">String</span>, <span class="hljs-built_in">List</span>&lt;User&gt;&gt;();<span class="hljs-comment">//传统for循环</span>for (<span class="hljs-built_in">Map</span>.Entry&lt;<span class="hljs-built_in">String</span>, <span class="hljs-built_in">List</span>&lt;User&gt;&gt; entry : users.entrySet()) &#123;    <span class="hljs-built_in">String</span> key = entry.getKey();    <span class="hljs-built_in">List</span>&lt;User&gt; value = entry.getValue();    <span class="hljs-keyword">cache</span>.put(key, value.size());&#125;<span class="hljs-comment">//lambda方式</span>users.forEach((key, value) -&gt; &#123;    <span class="hljs-keyword">cache</span>.put(key, value.size());&#125;);</code></pre><h3 id="computeIfAbsent"><a href="#computeIfAbsent" class="headerlink" title="computeIfAbsent"></a>computeIfAbsent</h3><p>根据key获取某个值，若值不存在，丛数据库中取</p><pre><code class="hljs pgsql">//传统方式<span class="hljs-built_in">public</span> List&lt;<span class="hljs-keyword">User</span>&gt; getUserByName(String <span class="hljs-type">name</span>) &#123;    List&lt;<span class="hljs-keyword">User</span>&gt; <span class="hljs-keyword">user</span> = users.<span class="hljs-keyword">get</span>(<span class="hljs-type">name</span>);    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">user</span> == <span class="hljs-keyword">null</span>) &#123;        <span class="hljs-keyword">user</span> = readFromDB(<span class="hljs-type">name</span>);        users.put(<span class="hljs-type">name</span>, <span class="hljs-keyword">user</span>);    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-keyword">user</span>;&#125;//lambda方式<span class="hljs-built_in">public</span> List&lt;<span class="hljs-keyword">User</span>&gt; getUser1ByName(String <span class="hljs-type">name</span>) &#123;    <span class="hljs-keyword">return</span> users.computeIfAbsent(<span class="hljs-type">name</span>, this::readFromDB);&#125;private List&lt;<span class="hljs-keyword">User</span>&gt; readFromDB(String <span class="hljs-type">name</span>) &#123;    <span class="hljs-keyword">return</span> <span class="hljs-built_in">new</span> ArrayList&lt;&gt;();&#125;</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;p&gt;Stream API与InputStream和OutputStream是完全不同的概念，&lt;strong&gt;Stream API是对Java中集
      
    
    </summary>
    
    
      <category term="java" scheme="http://yoursite.com/categories/java/"/>
    
    
      <category term="stream" scheme="http://yoursite.com/tags/stream/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://yoursite.com/2020/05/31/hello-world/"/>
    <id>http://yoursite.com/2020/05/31/hello-world/</id>
    <published>2020-05-31T01:14:54.029Z</published>
    <updated>2020-05-31T01:14:54.029Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre><code class="hljs bash">$ hexo new <span class="hljs-string">"My New Post"</span></code></pre><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre><code class="hljs bash">$ hexo server</code></pre><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre><code class="hljs bash">$ hexo generate</code></pre><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre><code class="hljs bash">$ hexo deploy</code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.
      
    
    </summary>
    
    
    
  </entry>
  
</feed>

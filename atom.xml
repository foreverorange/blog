<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>foreverorange</title>
  
  
  <link href="/blog/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2020-08-19T15:34:52.750Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>foreverorange</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>maven基础操作</title>
    <link href="http://yoursite.com/2020/08/19/maven%E5%9F%BA%E7%A1%80%E6%93%8D%E4%BD%9C/"/>
    <id>http://yoursite.com/2020/08/19/maven%E5%9F%BA%E7%A1%80%E6%93%8D%E4%BD%9C/</id>
    <published>2020-08-19T15:25:25.000Z</published>
    <updated>2020-08-19T15:34:52.750Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、指定jdk版本"><a href="#一、指定jdk版本" class="headerlink" title="一、指定jdk版本"></a>一、指定jdk版本</h2><ul><li>不指定，每次reimportant都会变成1.5<pre><code class="hljs java">&lt;properties&gt;    &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;    &lt;project.build.sourceVersion&gt;1.8&lt;/project.build.sourceVersion&gt;    &lt;project.build.targetVersion&gt;1.8&lt;/project.build.targetVersion&gt;        &lt;!--maven report 会使用<span class="hljs-number">1.8</span>编译，不加每次都会退到<span class="hljs-number">1.5</span>--&gt;    &lt;maven.compiler.source&gt;1.8&lt;/maven.compiler.source&gt;    &lt;maven.compiler.target&gt;1.8&lt;/maven.compiler.target&gt;    &lt;java.version&gt;1.8&lt;/java.version&gt;&lt;/properties&gt;</code></pre></li></ul><h2 id="二、包含src下的静态文件"><a href="#二、包含src下的静态文件" class="headerlink" title="二、包含src下的静态文件"></a>二、包含src下的静态文件</h2><ul><li>一般是mapper文件，不指定，则不打包到文件中<pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">build</span>&gt;</span>    <span class="hljs-comment">&lt;!-- 将xml一起打包 --&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">resources</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">resource</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">directory</span>&gt;</span>src/main/resources<span class="hljs-tag">&lt;/<span class="hljs-name">directory</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">includes</span>&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">include</span>&gt;</span>**/*.*<span class="hljs-tag">&lt;/<span class="hljs-name">include</span>&gt;</span>            <span class="hljs-tag">&lt;/<span class="hljs-name">includes</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">resource</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">resource</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">directory</span>&gt;</span>src/main/java<span class="hljs-tag">&lt;/<span class="hljs-name">directory</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">includes</span>&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">include</span>&gt;</span>**/*.properties<span class="hljs-tag">&lt;/<span class="hljs-name">include</span>&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">include</span>&gt;</span>**/*.xml<span class="hljs-tag">&lt;/<span class="hljs-name">include</span>&gt;</span>            <span class="hljs-tag">&lt;/<span class="hljs-name">includes</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">resource</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">resources</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">build</span>&gt;</span></code></pre></li></ul><h2 id="三、tomcat部署临时maven仓库"><a href="#三、tomcat部署临时maven仓库" class="headerlink" title="三、tomcat部署临时maven仓库"></a>三、tomcat部署临时maven仓库</h2><pre><code class="hljs crystal">将maven整个包放在 webapps/ROOT下，如下所示/market/maven/apache-tomcat/webapps/ROOT</code></pre><h2 id="四、scope"><a href="#四、scope" class="headerlink" title="四、scope"></a>四、scope</h2><h3 id="4-1-Dependency-Scope"><a href="#4-1-Dependency-Scope" class="headerlink" title="4.1 Dependency Scope"></a>4.1 Dependency Scope</h3><pre><code class="hljs asciidoc"><span class="hljs-bullet">* </span>compile，缺省值，适用于所有阶段，会随着项目一起发布。 <span class="hljs-bullet">* </span>provided，类似compile，期望JDK、容器或使用者会提供这个依赖。如servlet.jar。 <span class="hljs-bullet">* </span>runtime，只在运行时使用，如JDBC驱动，适用运行和测试阶段。 <span class="hljs-bullet">* </span>test，只在测试时使用，用于编译和运行测试代码。不会随项目发布。 <span class="hljs-bullet">* </span>system，类似provided，需要显式提供包含依赖的jar，Maven不会在Repository中查找</code></pre><blockquote><p> 依赖范围import只在dependencyManagement元素下才有效果，使用该范围的依赖通常指向一个pom，作用是将目标pom中的dependencyManagement配置导入并合并到当前pom的dependencyManagement配置。</p></blockquote><h3 id="4-2-Optional和Exclusions"><a href="#4-2-Optional和Exclusions" class="headerlink" title="4.2 Optional和Exclusions"></a>4.2 Optional和Exclusions</h3><p>Optional和Exclusions都是用来排除jar包依赖使用的，两者在使用上却是相反。</p><p>Optional定义后，该依赖只能在本项目中传递，不会传递到引用该项目的父项目中，父项目需要主动引用该依赖才行。</p><p>Exclusions则是主动排除子项目传递过来的依赖。</p><h2 id="五、导出maven项目依赖的jar包"><a href="#五、导出maven项目依赖的jar包" class="headerlink" title="五、导出maven项目依赖的jar包"></a>五、导出maven项目依赖的jar包</h2><h3 id="5-1、导出到自定义目录中"><a href="#5-1、导出到自定义目录中" class="headerlink" title="5.1、导出到自定义目录中"></a>5.1、导出到自定义目录中</h3><ul><li>打开cmd，进入项目根目录（pom.xml文件也在这里)，并执行目录，lib文件如没有手动创建也会自动创建： </li></ul><pre><code class="hljs crystal">mvn <span class="hljs-symbol">dependency:</span>copy-dependencies -DoutputDirectory=<span class="hljs-class"><span class="hljs-keyword">lib</span></span></code></pre><h3 id="5-2、导出到默认目录-targed-dependency"><a href="#5-2、导出到默认目录-targed-dependency" class="headerlink" title="5.2、导出到默认目录 targed/dependency"></a>5.2、导出到默认目录 targed/dependency</h3><ul><li>从Maven项目中导出项目依赖的jar包：进入工程pom.xml 所在的目录下，执行如下命令：</li></ul><pre><code class="hljs dockerfile">mvn dependency:<span class="hljs-keyword">copy</span><span class="bash">-dependencies</span></code></pre><ul><li>或在eclipse中，选择项目的pom.xml文件，点击右键菜单中的Run As,见下图红框中，在弹出的Configuration窗口中，输入 dependency:copy-dependencies后，点击运行<br>maven项目所依赖的jar包会导出到targed/dependency目录中。</li></ul><h3 id="5-3、设置依赖级别"><a href="#5-3、设置依赖级别" class="headerlink" title="5.3、设置依赖级别"></a>5.3、设置依赖级别</h3><ul><li>同时可以设置依赖级别，通常使用compile级别</li></ul><pre><code class="hljs routeros">mvn dependency:copy-dependencies <span class="hljs-attribute">-DoutputDirectory</span>=lib   <span class="hljs-attribute">-DincludeScope</span>=compile</code></pre><h2 id="六、dependency"><a href="#六、dependency" class="headerlink" title="六、dependency"></a>六、dependency</h2><h3 id="6-1-dependencyManagement"><a href="#6-1-dependencyManagement" class="headerlink" title="6.1 dependencyManagement"></a>6.1 dependencyManagement</h3><p>dependencyManagement里只是声明依赖，并不实现引入，因此子项目需要显示的声明需要用的依赖。如果不在子项目中声明依赖，是不会从父项目中继承下来的；只有在子项目中写了该依赖项，并且没有指定具体版本，才会从父项目中继承该项，并且version和scope都读取自父pom;另外如果子项目中指定了版本号，那么会使用子项目中指定的jar版本。</p><h3 id="6-2-Dependencies"><a href="#6-2-Dependencies" class="headerlink" title="6.2 Dependencies"></a>6.2 Dependencies</h3><p>所有生命在dependencies里的依赖都会自动引入，并默认被所有的子项目继承。dependencies即使在子项目中不写该依赖项，那么子项目仍然会从父项目中继承该依赖项（全部继承）</p><h3 id="6-3reposity"><a href="#6-3reposity" class="headerlink" title="6.3reposity"></a>6.3reposity</h3><p>pom.xml中添加指定的中央仓库</p><p><code>&lt;repositories&gt;&lt;repository&gt;&lt;&gt;&lt;&gt;</code></p><h2 id="七、依赖冲突"><a href="#七、依赖冲突" class="headerlink" title="七、依赖冲突"></a>七、依赖冲突</h2><p>为什么会出现依赖冲突？</p><p>首先要说明Maven的依赖管理，maven在依赖冲管理中有一下几个原则。</p><ul><li>依赖是使用Maven坐标来定位的，而Maven坐标主要由GAV（groupId, artifactId, version）构成。如果两个相同的依赖包，如果groupId, artifactId, version不同，那么maven也认为这两个是不同的。</li><li>依赖会传递，A依赖了B，B依赖了C，那么A的依赖中就会出现B和C。</li><li>Maven对同一个groupId, artifactId的冲突仲裁，不是以version越大越保留，而是依赖路径越短越优先，然后进行保留。</li><li>依赖的scope会影响依赖的影响范围。</li></ul><blockquote><p>可以通过设定依赖的<code>&lt;exclusions&gt;</code>来进行排除。</p></blockquote><h2 id="八、部署到本地、远程仓库"><a href="#八、部署到本地、远程仓库" class="headerlink" title="八、部署到本地、远程仓库"></a>八、部署到本地、远程仓库</h2><h3 id="8-1-安装到本地仓库"><a href="#8-1-安装到本地仓库" class="headerlink" title="8.1 安装到本地仓库"></a>8.1 安装到本地仓库</h3><p><code>mvn clean install</code></p><h3 id="8-2-部署到远程仓库"><a href="#8-2-部署到远程仓库" class="headerlink" title="8.2 部署到远程仓库"></a>8.2 部署到远程仓库</h3><p><code>mvn clean deploy</code></p><p>需要认证信息，只能在settings.xml中配置。仓库的id要对应上</p><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">servers</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">server</span>&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">id</span>&gt;</span>public-snapshots<span class="hljs-tag">&lt;/<span class="hljs-name">id</span>&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">username</span>&gt;</span>dev<span class="hljs-tag">&lt;/<span class="hljs-name">username</span>&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">password</span>&gt;</span>help<span class="hljs-tag">&lt;/<span class="hljs-name">password</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">server</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">server</span>&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">id</span>&gt;</span>public-repo<span class="hljs-tag">&lt;/<span class="hljs-name">id</span>&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">username</span>&gt;</span>dev<span class="hljs-tag">&lt;/<span class="hljs-name">username</span>&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">password</span>&gt;</span>help<span class="hljs-tag">&lt;/<span class="hljs-name">password</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">server</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">server</span>&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">id</span>&gt;</span>nexus<span class="hljs-tag">&lt;/<span class="hljs-name">id</span>&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">username</span>&gt;</span>admin<span class="hljs-tag">&lt;/<span class="hljs-name">username</span>&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">password</span>&gt;</span>admin123<span class="hljs-tag">&lt;/<span class="hljs-name">password</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">server</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">servers</span>&gt;</span></code></pre><p>pom中的发布信息</p><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">distributionManagement</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">repository</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">id</span>&gt;</span>public-repo<span class="hljs-tag">&lt;/<span class="hljs-name">id</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>thunisoft snapshots repository<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">url</span>&gt;</span>http://repo.aliyun.com/maven2/content/repositories/releases/<span class="hljs-tag">&lt;/<span class="hljs-name">url</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">repository</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">snapshotRepository</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">id</span>&gt;</span>public-snapshots<span class="hljs-tag">&lt;/<span class="hljs-name">id</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>thunisoft release repository<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">url</span>&gt;</span>http://repo.aliyun.com/maven2/content/repositories/snapshots/<span class="hljs-tag">&lt;/<span class="hljs-name">url</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">snapshotRepository</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">distributionManagement</span>&gt;</span></code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;一、指定jdk版本&quot;&gt;&lt;a href=&quot;#一、指定jdk版本&quot; class=&quot;headerlink&quot; title=&quot;一、指定jdk版本&quot;&gt;&lt;/a&gt;一、指定jdk版本&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;不指定，每次reimportant都会变成1.5&lt;pre&gt;&lt;code c
      
    
    </summary>
    
    
      <category term="maven" scheme="http://yoursite.com/categories/maven/"/>
    
    
      <category term="maven" scheme="http://yoursite.com/tags/maven/"/>
    
  </entry>
  
  <entry>
    <title>线程之多少个线程合适</title>
    <link href="http://yoursite.com/2020/08/12/%E7%BA%BF%E7%A8%8B%E4%B9%8B%E4%BB%BB%E5%8A%A1%E6%89%A7%E8%A1%8C/"/>
    <id>http://yoursite.com/2020/08/12/%E7%BA%BF%E7%A8%8B%E4%B9%8B%E4%BB%BB%E5%8A%A1%E6%89%A7%E8%A1%8C/</id>
    <published>2020-08-12T00:40:24.000Z</published>
    <updated>2020-08-19T00:25:11.356Z</updated>
    
    <content type="html"><![CDATA[<p>在正常的负载下，服务器应用程序应该同时表现出良好的吞吐量和快速的响应性。</p><p>服务商希望应用程序支持尽可能多的用户，从而降低每个用户的服务成本；而用户则希望获得尽快的响应。</p><p>当负荷过载时，应用程序的性能应该是逐渐降低，而不是直接失败。因此需要有任务边界和任务隔离。</p><h2 id="一、无限制创建线程的不足"><a href="#一、无限制创建线程的不足" class="headerlink" title="一、无限制创建线程的不足"></a>一、无限制创建线程的不足</h2><h3 id="2-1-线程生命周期的开销非常高"><a href="#2-1-线程生命周期的开销非常高" class="headerlink" title="2.1. 线程生命周期的开销非常高"></a>2.1. 线程生命周期的开销非常高</h3><p>线程的创建需要时间，需要jvm和操作系统提供辅助支持</p><h3 id="2-2-资源消耗"><a href="#2-2-资源消耗" class="headerlink" title="2.2. 资源消耗"></a>2.2. 资源消耗</h3><ul><li>活跃的线程会消耗系统资源，尤其是内存。</li><li>如果可运行的线程数量多于可用处理器的数量，那么有些线程将会闲置。</li><li>大量空闲的线程会占用很多内存，给垃圾回收器带来压力。</li><li>大量线程在竞争cpu时还将产生其他性能开销。</li><li>如果已经拥有足够多的线程使cpu处于忙碌状态，那么再创建更多的线程反而会降低性能。</li></ul><h2 id="二、创建多少个线程合适"><a href="#二、创建多少个线程合适" class="headerlink" title="二、创建多少个线程合适"></a>二、创建多少个线程合适</h2><p>多线程的使用场景：通过设置正确个数的线程来最大化程序的运行速度。翻译到硬件级别就是要充分的提高 CPU 和 I/O 的利用率。</p><p>应用程序一般可作如下划分：</p><ul><li>CPU 密集型程序</li><li>I/O 密集型程序</li></ul><h3 id="3-1-CPU密集型"><a href="#3-1-CPU密集型" class="headerlink" title="3.1 CPU密集型"></a>3.1 CPU密集型</h3><p>一个完整请求，I/O操作可以在很短时间内完成， CPU还有很多运算要处理，也就是说 CPU 计算的比例占很大一部分。</p><p>如果是多核CPU 处理 CPU 密集型程序，我们完全可以最大化的利用 CPU 核心数，应用并发编程来提高效率</p><h4 id="3-1-1-CPU-密集型程序创建多少个线程合适"><a href="#3-1-1-CPU-密集型程序创建多少个线程合适" class="headerlink" title="3.1.1  CPU 密集型程序创建多少个线程合适"></a>3.1.1  CPU 密集型程序创建多少个线程合适</h4><p>对于 CPU 密集型来说，理论上 <code>线程数量 = CPU 核数（逻辑）</code> 就可以了，但是实际上，数量一般会设置为 <code>CPU 核数（逻辑）+ 1</code>， 为什么呢？</p><blockquote><p>计算密（CPU）集型的线程恰好在某时因为发生一个页错误或者因其他原因而暂停，刚好有一个“额外”的线程，可以确保在这种情况下CPU周期不会中断工作。</p></blockquote><p>所以对于CPU密集型程序， <code>CPU 核数（逻辑）+ 1</code> 个线程数是比较好的经验值的原因了</p><h3 id="3-2-I-O密集型程序"><a href="#3-2-I-O密集型程序" class="headerlink" title="3.2 I/O密集型程序"></a>3.2 I/O密集型程序</h3><p>与 CPU 密集型程序相对，一个完整请求，CPU运算操作完成之后还有很多 I/O 操作要做，也就是说 I/O 操作占比很大部分。</p><p>我们都知道在进行 I/O 操作时，CPU是空闲状态，所以我们要最大化的利用 CPU，不能让其是空闲状态</p><blockquote><p>线程等待时间所占比例越高，需要越多线程；线程CPU时间所占比例越高，需要越少线程。</p></blockquote><h4 id="3-2-1-I-O密集型程序创建多少个线程合适"><a href="#3-2-1-I-O密集型程序创建多少个线程合适" class="headerlink" title="3.2.1  I/O密集型程序创建多少个线程合适"></a>3.2.1  I/O密集型程序创建多少个线程合适</h4><p>最佳线程数 = <code>(1/CPU利用率)</code> = <code>1 + (I/O耗时/CPU耗时)</code></p><p>如果多个核心，那么 I/O 密集型程序的最佳线程数就是：</p><blockquote><p>最佳线程数 = <code>CPU核心数</code> * <code>(1/CPU利用率)</code> = <code>CPU核心数</code> * <code>1 + (I/O耗时/CPU耗时)</code></p></blockquote><h4 id="3-2-2-案例"><a href="#3-2-2-案例" class="headerlink" title="3.2.2 案例"></a>3.2.2 案例</h4><ul><li>计算操作需要5ms，DB操作需要 100ms，对于一台 8个CPU的服务器，怎么设置线程数呢？</li></ul><p>答案是：</p><p>线程数 = 8 * (1 + 100/5) = 168 (个)</p><p>每秒的QPS = 168 * (1000/(5 + 100)) = 1600 QPS</p><ul><li>那如果DB的 QPS（Query Per Second）上限是1000，此时这个线程数又该设置为多大呢？</li></ul><p>答案是：</p><p>一个任务需要5+100=105ms，那么一个线程每秒（即1000ms）处理的任务是1000/105，上限1000/(1000/105)=105个线程</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在正常的负载下，服务器应用程序应该同时表现出良好的吞吐量和快速的响应性。&lt;/p&gt;
&lt;p&gt;服务商希望应用程序支持尽可能多的用户，从而降低每个用户的服务成本；而用户则希望获得尽快的响应。&lt;/p&gt;
&lt;p&gt;当负荷过载时，应用程序的性能应该是逐渐降低，而不是直接失败。因此需要有任务边
      
    
    </summary>
    
    
      <category term="java" scheme="http://yoursite.com/categories/java/"/>
    
    
      <category term="thread" scheme="http://yoursite.com/tags/thread/"/>
    
  </entry>
  
  <entry>
    <title>多线程基础</title>
    <link href="http://yoursite.com/2020/07/29/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80/"/>
    <id>http://yoursite.com/2020/07/29/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80/</id>
    <published>2020-07-29T00:08:57.000Z</published>
    <updated>2020-07-30T15:40:29.898Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一、volatile变量的可见性"><a href="#一、volatile变量的可见性" class="headerlink" title="一、volatile变量的可见性"></a>一、volatile变量的可见性</h3><ul><li>一种稍弱的同步机制，用来确保将变量的更新操作通知到其他线程。</li><li>即读取volatile类型的变量时，总会获取到最新写入的值。</li><li>将变量声明为volatile类型后，会禁止指令重排。</li><li>volatile的语义不足以确保递增操作（count++）的原子性</li></ul><blockquote><p>加锁机制既能确保可见性，又能确保原子性，而volatile变量只能确保可见性。</p></blockquote><p>当且仅当满足如下条件时，使用volatile变量</p><ol><li>对变量的写入不依赖变量的当前值，或者能确保只有一个线程更新变量值</li><li>该变量不会与其他状态变量一起纳入不变性条件中。</li><li>在访问变量时不需要加锁。</li></ol><h3 id="二、发布与逸出"><a href="#二、发布与逸出" class="headerlink" title="二、发布与逸出"></a>二、发布与逸出</h3><p>发布：对象能够在当前作用域之外的代码中访问。</p><ul><li>将对象的引用保存在其他代码可以访问的地方。</li><li>在某个非私有的方法中返回该引用。</li><li>将引用传递到其他类的方法中。</li><li>发布一个内部类实例，该实例包含了对外部类实例的隐含引用。（即Outer.this引用）</li></ul><p>逸出：在对象尚未构造完成之前就发布该对象，就会破坏线程安全性。</p><h4 id="2-1-this引用逸出"><a href="#2-1-this引用逸出" class="headerlink" title="2.1 this引用逸出"></a>2.1 this引用逸出</h4><pre><code class="hljs arduino"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ThisEscape</span> &#123;</span>       <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> id;      <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">String</span> name;      <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ThisEscape</span><span class="hljs-params">(EventSource&lt;EventListener&gt; source)</span> </span>&#123;            id = <span class="hljs-number">1</span>;            <span class="hljs-comment">// 创建EventListener的匿名内部类</span>            <span class="hljs-comment">// 传递到source中，从而将匿名内部类对象发布出去</span>            source.registerListener(<span class="hljs-keyword">new</span> EventListener() &#123;                  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> onEvent(Object obj) &#123;                        System.out.<span class="hljs-built_in">println</span>(<span class="hljs-string">"id: "</span>+ThisEscape.<span class="hljs-keyword">this</span>.id);                        System.out.<span class="hljs-built_in">println</span>(<span class="hljs-string">"name: "</span>+ThisEscape.<span class="hljs-keyword">this</span>.name);                  &#125;            &#125;);            <span class="hljs-comment">// 上一步发布的匿名内部类对象已经发布出去了，它包含了对其外部类ThisEscape.this的隐含引用</span>            <span class="hljs-comment">// 而此时ThisEscape实例由于sleep尚未构造完成，假设外部通过ThisEscape.this来访问该实例就会出现问题</span>            <span class="hljs-comment">// 不sleep的话，访问name可能是fly，sleep后大概率会出现null。</span>            <span class="hljs-keyword">try</span> &#123;                  Thread.sleep(<span class="hljs-number">1000</span>); <span class="hljs-comment">// 调用sleep模拟其他耗时的初始化操作</span>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;                  <span class="hljs-comment">// TODO Auto-generated catch block</span>                  e.printStackTrace();            &#125;            name = <span class="hljs-string">"fly"</span>;                  &#125;&#125;</code></pre><h4 id="2-2-this引用逸出是怎样产生的"><a href="#2-2-this引用逸出是怎样产生的" class="headerlink" title="2.2 this引用逸出是怎样产生的"></a>2.2 this引用逸出是怎样产生的</h4><p>它需要满足两个条件：</p><ol><li><p>在构造函数中创建内部类(EventListener)，</p></li><li><p>在构造函数中就把这个内部类给发布了出去(source.registerListener)。</p></li></ol><h4 id="2-3-如何防止this引用逸出"><a href="#2-3-如何防止this引用逸出" class="headerlink" title="2.3 如何防止this引用逸出"></a>2.3 如何防止this引用逸出</h4><p>避免让这两个条件同时出现。也就是说，如果要在构造函数中创建内部类，那么就不能在构造函数中把他发布了，应该在构造函数外发布，<strong>即确保构造函数执行完毕，初始化工作已全部完成，再发布内部类。</strong></p><ul><li>如下所示，使用一个私有的构造函数进行初始化和一个公共的工厂方法进行发布</li></ul><pre><code class="hljs arduino"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ThisSafe</span> &#123;</span>       <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> id;      <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">String</span> name;      <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> EventListener listener;            <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">ThisSafe</span><span class="hljs-params">()</span> </span>&#123;            id = <span class="hljs-number">1</span>;            <span class="hljs-comment">// 在构造中创建匿名内部类对象</span>            listener = <span class="hljs-keyword">new</span> EventListener()&#123;                  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> onEvent(Object obj) &#123;                        System.out.<span class="hljs-built_in">println</span>(<span class="hljs-string">"id: "</span>+ThisSafe.<span class="hljs-keyword">this</span>.id);                        System.out.<span class="hljs-built_in">println</span>(<span class="hljs-string">"name: "</span>+ThisSafe.<span class="hljs-keyword">this</span>.name);                  &#125;            &#125;;            name = <span class="hljs-string">"flysqrlboy"</span>;      &#125;      <span class="hljs-comment">// 在其他公有方法中发布EventListener对象</span>      <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ThisSafe <span class="hljs-title">getInstance</span><span class="hljs-params">(EventSource&lt;EventListener&gt; source)</span> </span>&#123;            ThisSafe safe = <span class="hljs-keyword">new</span> ThisSafe();            source.registerListener(safe.listener);            <span class="hljs-keyword">return</span> safe;      &#125;&#125;</code></pre><h4 id="2-4-其他"><a href="#2-4-其他" class="headerlink" title="2.4 其他"></a>2.4 其他</h4><p>另一种导致this引用逸出的常见错误，<strong>是在构造函数中启动一个线程</strong>。其原理跟上文说的内部类导致的this引用逸出相类似。解决的办法也相似，即<strong>可以在构造函数中创建线程，但别启动它。在构造函数外面再启动。</strong></p><h3 id="三、线程封闭"><a href="#三、线程封闭" class="headerlink" title="三、线程封闭"></a>三、线程封闭</h3><h4 id="3-1-栈封闭"><a href="#3-1-栈封闭" class="headerlink" title="3.1 栈封闭"></a>3.1 栈封闭</h4><p>在栈封闭中，只有通过局部变量才能访问对象。</p><h4 id="3-2-threadLocal"><a href="#3-2-threadLocal" class="headerlink" title="3.2 threadLocal"></a>3.2 threadLocal</h4><p>线程变量，仅对当前线程可见。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;一、volatile变量的可见性&quot;&gt;&lt;a href=&quot;#一、volatile变量的可见性&quot; class=&quot;headerlink&quot; title=&quot;一、volatile变量的可见性&quot;&gt;&lt;/a&gt;一、volatile变量的可见性&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;一种稍弱的同步机
      
    
    </summary>
    
    
      <category term="java" scheme="http://yoursite.com/categories/java/"/>
    
    
      <category term="thread" scheme="http://yoursite.com/tags/thread/"/>
    
  </entry>
  
  <entry>
    <title>hystrix源码分析</title>
    <link href="http://yoursite.com/2020/06/29/hystrix%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    <id>http://yoursite.com/2020/06/29/hystrix%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/</id>
    <published>2020-06-29T14:40:44.000Z</published>
    <updated>2020-06-29T15:12:50.420Z</updated>
    
    <content type="html"><![CDATA[<h3 id="基本原理"><a href="#基本原理" class="headerlink" title="基本原理"></a>基本原理</h3><p>分布式系统中一个服务可能依赖着很多其他服务，在高并发的场景下，如何保证依赖的某些服务如果出了问题不会导致主服务宕机这个问题就会变得异常重要。</p><p>针对这个问题直观想到的解决方案就是做依赖隔离。将不同的依赖分配到不同的调用链中，某一条链发生失败不会影响别的链。</p><ol><li>hystrix使用命令模式hystrixCommand进行包装，每个命令在单独线程（信号量）下执行。</li><li>调用结果分为：成功、异常失败、超时、线程拒绝、短路。失败（异常、超时、拒绝、短路）时执行fallback（降级）逻辑。</li><li>可自动运行或手动调用，默认错误率阈值为50%,超过将自动运行。</li></ol><p>PS：其他断路器Resilience4j 和 Sentinel</p><p>PS：短路：多个依赖服务顺序请求，前面的请求失败时，则后面的请求不会发出。</p><h3 id="Hystrix如何实现依赖隔离"><a href="#Hystrix如何实现依赖隔离" class="headerlink" title="Hystrix如何实现依赖隔离"></a>Hystrix如何实现依赖隔离</h3><p><strong>命令模式</strong></p><p>将所有请求外部系统或者依赖服务的逻辑封装到hystrixCommand（hystrixObservableCommand）中，run方法为实现的业务逻辑，在独立的线程中执行真正的请求，并在失败时执行fallback回退逻辑。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;基本原理&quot;&gt;&lt;a href=&quot;#基本原理&quot; class=&quot;headerlink&quot; title=&quot;基本原理&quot;&gt;&lt;/a&gt;基本原理&lt;/h3&gt;&lt;p&gt;分布式系统中一个服务可能依赖着很多其他服务，在高并发的场景下，如何保证依赖的某些服务如果出了问题不会导致主服务宕机这个问题就
      
    
    </summary>
    
    
      <category term="springCloud" scheme="http://yoursite.com/categories/springCloud/"/>
    
    
      <category term="hystrix" scheme="http://yoursite.com/tags/hystrix/"/>
    
  </entry>
  
  <entry>
    <title>ribbon源码分析</title>
    <link href="http://yoursite.com/2020/06/15/ribbon%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    <id>http://yoursite.com/2020/06/15/ribbon%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/</id>
    <published>2020-06-15T12:55:28.000Z</published>
    <updated>2020-06-16T16:46:34.680Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、-LoadBalanced注解"><a href="#一、-LoadBalanced注解" class="headerlink" title="一、@LoadBalanced注解"></a>一、@LoadBalanced注解</h2><p>唯一加的注解就是<code>@LoadBalanced</code>，如下所示</p><pre><code class="hljs java"><span class="hljs-meta">@Bean</span><span class="hljs-meta">@LoadBalanced</span><span class="hljs-function"><span class="hljs-keyword">public</span> RestTemplate <span class="hljs-title">restTemplate</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> RestTemplate();&#125;</code></pre><p>点进<code>@LoadBalanced</code>注解如下：</p><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * Annotation to mark a RestTemplate or WebClient bean to be configured to use a</span><span class="hljs-comment"> * LoadBalancerClient.</span><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> Spencer Gibb</span><span class="hljs-comment"> */</span><span class="hljs-meta">@Target</span>(&#123; ElementType.FIELD, ElementType.PARAMETER, ElementType.METHOD &#125;)<span class="hljs-meta">@Retention</span>(RetentionPolicy.RUNTIME)<span class="hljs-meta">@Documented</span><span class="hljs-meta">@Inherited</span><span class="hljs-meta">@Qualifier</span><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> LoadBalanced &#123;&#125;</code></pre><ol><li>使用了@Qualifier注解进行限定标识</li><li>类注释意思是，该注解用于标记一个<code>RestTemplate</code>或者<code>WebClient</code>实例，它将会被配置成使用<code>LoadBalancerClient</code></li></ol><blockquote><p>由此可以初步猜测，ribbon最终是通过<code>LoadBalancerClient</code>实现的客户端负载均衡。</p></blockquote><h2 id="二、jar包中META-INF-spring-factories"><a href="#二、jar包中META-INF-spring-factories" class="headerlink" title="二、jar包中META-INF/spring.factories"></a>二、jar包中META-INF/spring.factories</h2><pre><code class="hljs yaml"><span class="hljs-string">org.springframework.boot.autoconfigure.EnableAutoConfiguration=\</span><span class="hljs-string">org.springframework.cloud.netflix.ribbon.RibbonAutoConfiguration</span></code></pre><blockquote><p>声明了RibbonAutoConfiguration的自动配置类</p></blockquote><h3 id="1、ribbon自动配置"><a href="#1、ribbon自动配置" class="headerlink" title="1、ribbon自动配置"></a>1、ribbon自动配置</h3><ul><li>RibbonAutoConfiguration</li></ul><p>点进去如下：</p><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * Auto configuration for Ribbon (client side load balancing).</span><span class="hljs-comment"> *</span><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> Spencer Gibb</span><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> Dave Syer</span><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> Biju Kunjummen</span><span class="hljs-comment"> */</span><span class="hljs-meta">@Configuration</span><span class="hljs-meta">@Conditional</span>(RibbonAutoConfiguration.RibbonClassesConditions<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span><span class="hljs-class">@<span class="hljs-title">RibbonClients</span></span><span class="hljs-class">@<span class="hljs-title">AutoConfigureAfter</span>(</span><span class="hljs-class"><span class="hljs-title">name</span> </span>= <span class="hljs-string">"org.springframework.cloud.netflix.eureka.EurekaClientAutoConfiguration"</span>)<span class="hljs-meta">@AutoConfigureBefore</span>(&#123; LoadBalancerAutoConfiguration<span class="hljs-class">.<span class="hljs-keyword">class</span>,</span><span class="hljs-class"><span class="hljs-title">AsyncLoadBalancerAutoConfiguration</span>.<span class="hljs-title">class</span> &#125;)</span><span class="hljs-class">@<span class="hljs-title">EnableConfigurationProperties</span>(</span>&#123; RibbonEagerLoadProperties<span class="hljs-class">.<span class="hljs-keyword">class</span>,</span><span class="hljs-class"><span class="hljs-title">ServerIntrospectorProperties</span>.<span class="hljs-title">class</span> &#125;)</span><span class="hljs-class"><span class="hljs-title">public</span> <span class="hljs-title">class</span> <span class="hljs-title">RibbonAutoConfiguration</span> </span>&#123;···<span class="hljs-meta">@Bean</span>  <span class="hljs-meta">@ConditionalOnMissingBean</span>(LoadBalancerClient<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span><span class="hljs-class">  <span class="hljs-title">public</span> <span class="hljs-title">LoadBalancerClient</span> <span class="hljs-title">loadBalancerClient</span>() </span>&#123;    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> RibbonLoadBalancerClient(springClientFactory());  &#125;    <span class="hljs-meta">@Bean</span><span class="hljs-meta">@ConditionalOnMissingBean</span><span class="hljs-function"><span class="hljs-keyword">public</span> SpringClientFactory <span class="hljs-title">springClientFactory</span><span class="hljs-params">()</span> </span>&#123;SpringClientFactory factory = <span class="hljs-keyword">new</span> SpringClientFactory();factory.setConfigurations(<span class="hljs-keyword">this</span>.configurations);<span class="hljs-keyword">return</span> factory;&#125;···</code></pre><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SpringClientFactory</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">NamedContextFactory</span>&lt;<span class="hljs-title">RibbonClientSpecification</span>&gt; </span>&#123;<span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String NAMESPACE = <span class="hljs-string">"ribbon"</span>;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">SpringClientFactory</span><span class="hljs-params">()</span> </span>&#123;super(RibbonClientConfiguration.class, NAMESPACE, "ribbon.client.name");&#125;</code></pre><p>可以看出，它声明了<code>LoadBalancerClient</code>的实例为<code>RibbonLoadBalancerClient</code>，在生成<code>RibbonLoadBalancerClient</code>时传入了<code>springClientFactory()</code>，其内部引入了<code>RibbonClientConfiguration.class</code></p><h3 id="2、ribbonClient实例配置"><a href="#2、ribbonClient实例配置" class="headerlink" title="2、ribbonClient实例配置"></a>2、ribbonClient实例配置</h3><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * Ribbon client default connect timeout.</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> DEFAULT_CONNECT_TIMEOUT = <span class="hljs-number">1000</span>;<span class="hljs-comment">/**</span><span class="hljs-comment"> * Ribbon client default read timeout.</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> DEFAULT_READ_TIMEOUT = <span class="hljs-number">1000</span>;<span class="hljs-comment">/**</span><span class="hljs-comment"> * Ribbon client default Gzip Payload flag.</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> DEFAULT_GZIP_PAYLOAD = <span class="hljs-keyword">true</span>;<span class="hljs-meta">@RibbonClientName</span><span class="hljs-keyword">private</span> String name = <span class="hljs-string">"client"</span>;<span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> maybe re-instate autowired load balancers: identified by name they could be</span><span class="hljs-comment">// associated with ribbon clients</span><span class="hljs-meta">@Autowired</span><span class="hljs-keyword">private</span> PropertiesFactory propertiesFactory;<span class="hljs-comment">// 定义ribbonClientConfig的配置类</span><span class="hljs-meta">@Bean</span><span class="hljs-meta">@ConditionalOnMissingBean</span><span class="hljs-function"><span class="hljs-keyword">public</span> IClientConfig <span class="hljs-title">ribbonClientConfig</span><span class="hljs-params">()</span> </span>&#123;DefaultClientConfigImpl config = <span class="hljs-keyword">new</span> DefaultClientConfigImpl();config.loadProperties(<span class="hljs-keyword">this</span>.name);config.set(CommonClientConfigKey.ConnectTimeout, DEFAULT_CONNECT_TIMEOUT);config.set(CommonClientConfigKey.ReadTimeout, DEFAULT_READ_TIMEOUT);config.set(CommonClientConfigKey.GZipPayload, DEFAULT_GZIP_PAYLOAD);<span class="hljs-keyword">return</span> config;&#125;<span class="hljs-comment">// 定义默认的负载均衡策略</span><span class="hljs-meta">@Bean</span><span class="hljs-meta">@ConditionalOnMissingBean</span><span class="hljs-function"><span class="hljs-keyword">public</span> IRule <span class="hljs-title">ribbonRule</span><span class="hljs-params">(IClientConfig config)</span> </span>&#123;<span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.propertiesFactory.isSet(IRule<span class="hljs-class">.<span class="hljs-keyword">class</span>, <span class="hljs-title">name</span>)) </span>&#123;<span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.propertiesFactory.get(IRule<span class="hljs-class">.<span class="hljs-keyword">class</span>, <span class="hljs-title">config</span>, <span class="hljs-title">name</span>)</span>;&#125;ZoneAvoidanceRule rule = <span class="hljs-keyword">new</span> ZoneAvoidanceRule();rule.initWithNiwsConfig(config);<span class="hljs-keyword">return</span> rule;&#125;<span class="hljs-comment">// 定义默认的ping规则</span><span class="hljs-meta">@Bean</span><span class="hljs-meta">@ConditionalOnMissingBean</span><span class="hljs-function"><span class="hljs-keyword">public</span> IPing <span class="hljs-title">ribbonPing</span><span class="hljs-params">(IClientConfig config)</span> </span>&#123;<span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.propertiesFactory.isSet(IPing<span class="hljs-class">.<span class="hljs-keyword">class</span>, <span class="hljs-title">name</span>)) </span>&#123;<span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.propertiesFactory.get(IPing<span class="hljs-class">.<span class="hljs-keyword">class</span>, <span class="hljs-title">config</span>, <span class="hljs-title">name</span>)</span>;&#125;<span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> DummyPing();&#125;<span class="hljs-comment">// 定义服务列表</span><span class="hljs-meta">@Bean</span><span class="hljs-meta">@ConditionalOnMissingBean</span><span class="hljs-meta">@SuppressWarnings</span>(<span class="hljs-string">"unchecked"</span>)<span class="hljs-function"><span class="hljs-keyword">public</span> ServerList&lt;Server&gt; <span class="hljs-title">ribbonServerList</span><span class="hljs-params">(IClientConfig config)</span> </span>&#123;<span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.propertiesFactory.isSet(ServerList<span class="hljs-class">.<span class="hljs-keyword">class</span>, <span class="hljs-title">name</span>)) </span>&#123;<span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.propertiesFactory.get(ServerList<span class="hljs-class">.<span class="hljs-keyword">class</span>, <span class="hljs-title">config</span>, <span class="hljs-title">name</span>)</span>;&#125;ConfigurationBasedServerList serverList = <span class="hljs-keyword">new</span> ConfigurationBasedServerList();serverList.initWithNiwsConfig(config);<span class="hljs-keyword">return</span> serverList;&#125;  <span class="hljs-comment">// 定义服务列表更新器</span><span class="hljs-meta">@Bean</span><span class="hljs-meta">@ConditionalOnMissingBean</span><span class="hljs-function"><span class="hljs-keyword">public</span> ServerListUpdater <span class="hljs-title">ribbonServerListUpdater</span><span class="hljs-params">(IClientConfig config)</span> </span>&#123;<span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> PollingServerListUpdater(config);&#125;<span class="hljs-comment">// 定义负载均衡器，传入默认的rule和ping，生成ZoneAwareLoadBalancer默认负载均衡器</span><span class="hljs-meta">@Bean</span><span class="hljs-meta">@ConditionalOnMissingBean</span><span class="hljs-function"><span class="hljs-keyword">public</span> ILoadBalancer <span class="hljs-title">ribbonLoadBalancer</span><span class="hljs-params">(IClientConfig config,</span></span><span class="hljs-function"><span class="hljs-params">ServerList&lt;Server&gt; serverList, ServerListFilter&lt;Server&gt; serverListFilter,</span></span><span class="hljs-function"><span class="hljs-params">IRule rule, IPing ping, ServerListUpdater serverListUpdater)</span> </span>&#123;<span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.propertiesFactory.isSet(ILoadBalancer<span class="hljs-class">.<span class="hljs-keyword">class</span>, <span class="hljs-title">name</span>)) </span>&#123;<span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.propertiesFactory.get(ILoadBalancer<span class="hljs-class">.<span class="hljs-keyword">class</span>, <span class="hljs-title">config</span>, <span class="hljs-title">name</span>)</span>;&#125;<span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ZoneAwareLoadBalancer&lt;&gt;(config, rule, ping, serverList,serverListFilter, serverListUpdater);&#125;</code></pre><h3 id="3、负载均衡器自动配置"><a href="#3、负载均衡器自动配置" class="headerlink" title="3、负载均衡器自动配置"></a>3、负载均衡器自动配置</h3><ul><li>LoadBalancerAutoConfiguration</li></ul><p>而在类的上方，使用了<code>@AutoConfigureBefore({ LoadBalancerAutoConfiguration.class</code>，点进去如下：</p><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * Auto-configuration for Ribbon (client-side load balancing).</span><span class="hljs-comment"> *</span><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> Spencer Gibb</span><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> Dave Syer</span><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> Will Tran</span><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> Gang Li</span><span class="hljs-comment"> */</span><span class="hljs-meta">@Configuration</span>(proxyBeanMethods = <span class="hljs-keyword">false</span>)<span class="hljs-meta">@ConditionalOnClass</span>(RestTemplate<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span><span class="hljs-class">@<span class="hljs-title">ConditionalOnBean</span>(<span class="hljs-title">LoadBalancerClient</span>.<span class="hljs-title">class</span>)</span><span class="hljs-class">@<span class="hljs-title">EnableConfigurationProperties</span>(<span class="hljs-title">LoadBalancerRetryProperties</span>.<span class="hljs-title">class</span>)</span><span class="hljs-class"><span class="hljs-title">public</span> <span class="hljs-title">class</span> <span class="hljs-title">LoadBalancerAutoConfiguration</span> </span>&#123;<span class="hljs-comment">// 这里使用了@LoadBalanced注解进行限定，即只有被该注解标注的restTemplates才会被注入到list中</span><span class="hljs-meta">@LoadBalanced</span><span class="hljs-meta">@Autowired</span>(required = <span class="hljs-keyword">false</span>)<span class="hljs-keyword">private</span> List&lt;RestTemplate&gt; restTemplates = Collections.emptyList();<span class="hljs-meta">@Autowired</span>(required = <span class="hljs-keyword">false</span>)<span class="hljs-keyword">private</span> List&lt;LoadBalancerRequestTransformer&gt; transformers = Collections.emptyList();<span class="hljs-meta">@Bean</span><span class="hljs-function"><span class="hljs-keyword">public</span> SmartInitializingSingleton <span class="hljs-title">loadBalancedRestTemplateInitializerDeprecated</span><span class="hljs-params">(</span></span><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">final</span> ObjectProvider&lt;List&lt;RestTemplateCustomizer&gt;&gt; restTemplateCustomizers)</span> </span>&#123;<span class="hljs-comment">// 这里返回了一个SmartInitializingSingleton实例</span>    <span class="hljs-keyword">return</span> () -&gt; restTemplateCustomizers.ifAvailable(customizers -&gt; &#123;      <span class="hljs-comment">// 循环限定注入的List&lt;RestTemplate&gt;，使用RestTemplateCustomizer进行定制</span><span class="hljs-keyword">for</span> (RestTemplate restTemplate : LoadBalancerAutoConfiguration.<span class="hljs-keyword">this</span>.restTemplates) &#123;<span class="hljs-keyword">for</span> (RestTemplateCustomizer customizer : customizers) &#123;customizer.customize(restTemplate);&#125;&#125;&#125;);&#125;···    <span class="hljs-meta">@Bean</span><span class="hljs-meta">@ConditionalOnMissingBean</span><span class="hljs-function"><span class="hljs-keyword">public</span> LoadBalancerRequestFactory <span class="hljs-title">loadBalancerRequestFactory</span><span class="hljs-params">(</span></span><span class="hljs-function"><span class="hljs-params">LoadBalancerClient loadBalancerClient)</span> </span>&#123;<span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> LoadBalancerRequestFactory(loadBalancerClient, <span class="hljs-keyword">this</span>.transformers);&#125;  <span class="hljs-meta">@Configuration</span>(proxyBeanMethods = <span class="hljs-keyword">false</span>)<span class="hljs-meta">@ConditionalOnMissingClass</span>(<span class="hljs-string">"org.springframework.retry.support.RetryTemplate"</span>)<span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LoadBalancerInterceptorConfig</span> </span>&#123;<span class="hljs-meta">@Bean</span>    <span class="hljs-comment">// 声明拦截器实例</span><span class="hljs-function"><span class="hljs-keyword">public</span> LoadBalancerInterceptor <span class="hljs-title">ribbonInterceptor</span><span class="hljs-params">(</span></span><span class="hljs-function"><span class="hljs-params">LoadBalancerClient loadBalancerClient,</span></span><span class="hljs-function"><span class="hljs-params">LoadBalancerRequestFactory requestFactory)</span> </span>&#123;<span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> LoadBalancerInterceptor(loadBalancerClient, requestFactory);&#125;<span class="hljs-meta">@Bean</span><span class="hljs-meta">@ConditionalOnMissingBean</span>    <span class="hljs-comment">// 声明在SmartInitializingSingleton中用于定制的处理实例</span><span class="hljs-function"><span class="hljs-keyword">public</span> RestTemplateCustomizer <span class="hljs-title">restTemplateCustomizer</span><span class="hljs-params">(</span></span><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">final</span> LoadBalancerInterceptor loadBalancerInterceptor)</span> </span>&#123;      为restTemplate增加一个额外的拦截器loadBalancerInterceptor<span class="hljs-keyword">return</span> restTemplate -&gt; &#123;List&lt;ClientHttpRequestInterceptor&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;(restTemplate.getInterceptors());list.add(loadBalancerInterceptor);restTemplate.setInterceptors(list);&#125;;&#125;···    <span class="hljs-comment">/**</span><span class="hljs-comment"> * Auto configuration for retry mechanism.</span><span class="hljs-comment"> */</span><span class="hljs-meta">@Configuration</span>(proxyBeanMethods = <span class="hljs-keyword">false</span>)<span class="hljs-meta">@ConditionalOnClass</span>(RetryTemplate<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span><span class="hljs-class"><span class="hljs-title">public</span> <span class="hljs-title">static</span> <span class="hljs-title">class</span> <span class="hljs-title">RetryAutoConfiguration</span> </span>&#123;<span class="hljs-meta">@Bean</span><span class="hljs-meta">@ConditionalOnMissingBean</span><span class="hljs-function"><span class="hljs-keyword">public</span> LoadBalancedRetryFactory <span class="hljs-title">loadBalancedRetryFactory</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> LoadBalancedRetryFactory() &#123;&#125;;&#125;&#125;    ···&#125;</code></pre><p>可以看出，在<code>LoadBalancerAutoConfiguration</code>中，维护了一个<code>List&lt;RestTemplate&gt;</code>，并注入被<code>LoadBalanced</code>修饰的<code>RestTemplate</code>实例。之后对限定的<code>RestTemplate</code>实例增加一个<code>LoadBalancerInterceptor</code>拦截器。另外可以看出，重试机制使用的<code>RetryTemplate.class</code>，重试的时候也会走配置好的负载均衡拦截器。</p><h4 id="PS：-Qualifier注解解读"><a href="#PS：-Qualifier注解解读" class="headerlink" title="PS：@Qualifier注解解读"></a>PS：@Qualifier注解解读</h4><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * This annotation may be used on a field or parameter as a qualifier for</span><span class="hljs-comment"> * candidate beans when autowiring. It may also be used to annotate other</span><span class="hljs-comment"> * custom annotations that can then in turn be used as qualifiers.</span><span class="hljs-comment"> * 1、该注解可以声明在一个字段或者参数上，用于表示在自动注入时，仅限定的候选实例才会被注入，</span><span class="hljs-comment"> * 例如同一个接口多个实现时，可以用它限定注入哪一个实例。</span><span class="hljs-comment"> * 2、该注解也可以使用在一个自定义注解上，那么该自定义注解可以被当做限定词使用，</span><span class="hljs-comment"> * 可以理解为是<span class="hljs-doctag">@Qualifier</span>("<span class="hljs-doctag">@xx</span>")这种限定</span><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> Mark Fisher</span><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> Juergen Hoeller</span><span class="hljs-comment"> * <span class="hljs-doctag">@since</span> 2.5</span><span class="hljs-comment"> * <span class="hljs-doctag">@see</span> Autowired</span><span class="hljs-comment"> */</span><span class="hljs-meta">@Target</span>(&#123;ElementType.FIELD, ElementType.METHOD, ElementType.PARAMETER, ElementType.TYPE, ElementType.ANNOTATION_TYPE&#125;)<span class="hljs-meta">@Retention</span>(RetentionPolicy.RUNTIME)<span class="hljs-meta">@Inherited</span><span class="hljs-meta">@Documented</span><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> Qualifier &#123;   <span class="hljs-function">String <span class="hljs-title">value</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> ""</span>;&#125;</code></pre><h3 id="4、负载均衡拦截器"><a href="#4、负载均衡拦截器" class="headerlink" title="4、负载均衡拦截器"></a>4、负载均衡拦截器</h3><ul><li>LoadBalancerInterceptor</li></ul><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LoadBalancerInterceptor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">ClientHttpRequestInterceptor</span> </span>&#123;<span class="hljs-keyword">private</span> LoadBalancerClient loadBalancer;<span class="hljs-keyword">private</span> LoadBalancerRequestFactory requestFactory;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">LoadBalancerInterceptor</span><span class="hljs-params">(LoadBalancerClient loadBalancer,</span></span><span class="hljs-function"><span class="hljs-params">LoadBalancerRequestFactory requestFactory)</span> </span>&#123;<span class="hljs-keyword">this</span>.loadBalancer = loadBalancer;<span class="hljs-keyword">this</span>.requestFactory = requestFactory;&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">LoadBalancerInterceptor</span><span class="hljs-params">(LoadBalancerClient loadBalancer)</span> </span>&#123;<span class="hljs-comment">// for backwards compatibility</span><span class="hljs-keyword">this</span>(loadBalancer, <span class="hljs-keyword">new</span> LoadBalancerRequestFactory(loadBalancer));&#125;<span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">public</span> ClientHttpResponse <span class="hljs-title">intercept</span><span class="hljs-params">(<span class="hljs-keyword">final</span> HttpRequest request, <span class="hljs-keyword">final</span> <span class="hljs-keyword">byte</span>[] body,</span></span><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">final</span> ClientHttpRequestExecution execution)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<span class="hljs-keyword">final</span> URI originalUri = request.getURI();    <span class="hljs-comment">// 这里得到的就是我们在resttemplate中填写的服务名</span>String serviceName = originalUri.getHost();Assert.state(serviceName != <span class="hljs-keyword">null</span>,<span class="hljs-string">"Request URI does not contain a valid hostname: "</span> + originalUri);    <span class="hljs-comment">// 这里可以看出，拦截器内部使用LoadBalancerClient实例进行实际调用</span><span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.loadBalancer.execute(serviceName,<span class="hljs-keyword">this</span>.requestFactory.createRequest(request, body, execution));&#125;&#125;</code></pre><p>跟踪到这里才发现，通过注解对<code>RestTemplate</code>进行拦截，使用<code>LoadBalancerClient</code>做实际调用处理。</p><p><code>LoadBalancerClient</code>就是之前声明的<code>RibbonLoadBalancerClient</code>，其具体处理如下：</p><pre><code class="hljs java"><span class="hljs-meta">@Override</span><span class="hljs-keyword">public</span> &lt;T&gt; <span class="hljs-function">T <span class="hljs-title">execute</span><span class="hljs-params">(String serviceId, LoadBalancerRequest&lt;T&gt; request)</span></span><span class="hljs-function"><span class="hljs-keyword">throws</span> IOException </span>&#123;<span class="hljs-keyword">return</span> execute(serviceId, request, <span class="hljs-keyword">null</span>);&#125;<span class="hljs-comment">/**  使用key选择一个server来执行请求</span><span class="hljs-comment"> * New: Execute a request by selecting server using a 'key'. The hint will have to be</span><span class="hljs-comment"> * the last parameter to not mess with the `execute(serviceId, ServiceInstance,</span><span class="hljs-comment"> * request)` method. This somewhat breaks the fluent coding style when using a lambda</span><span class="hljs-comment"> * to define the LoadBalancerRequest.</span><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &lt;T&gt; returned request execution result type</span><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> serviceId id of the service to execute the request to</span><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> request to be executed</span><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> hint used to choose appropriate &#123;<span class="hljs-doctag">@link</span> Server&#125; instance</span><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> request execution result</span><span class="hljs-comment"> * <span class="hljs-doctag">@throws</span> IOException executing the request may result in an &#123;<span class="hljs-doctag">@link</span> IOException&#125;</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> &lt;T&gt; <span class="hljs-function">T <span class="hljs-title">execute</span><span class="hljs-params">(String serviceId, LoadBalancerRequest&lt;T&gt; request, Object hint)</span></span><span class="hljs-function"><span class="hljs-keyword">throws</span> IOException </span>&#123;    <span class="hljs-comment">// 根据服务名获取一个ILoadBalancer负载均衡器处理实例</span>ILoadBalancer loadBalancer = getLoadBalancer(serviceId);Server server = getServer(loadBalancer, hint);<span class="hljs-keyword">if</span> (server == <span class="hljs-keyword">null</span>) &#123;<span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalStateException(<span class="hljs-string">"No instances available for "</span> + serviceId);&#125;RibbonServer ribbonServer = <span class="hljs-keyword">new</span> RibbonServer(serviceId, server,isSecure(server, serviceId),serverIntrospector(serviceId).getMetadata(server));<span class="hljs-keyword">return</span> execute(serviceId, ribbonServer, request);&#125;</code></pre><p>当一个被<code>@LoadBalanced</code>修饰的<code>RestTemplate</code>实例向外发送请求时，会被<code>LoadBalancerInterceptor</code>类的intercept函数拦截。之后通过<code>originalUri.getHost()</code>拿到具体的服务名，然后调用execute方法，根据服务名选择实例发起实际的请求。</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">protected</span> Server <span class="hljs-title">getServer</span><span class="hljs-params">(ILoadBalancer loadBalancer, Object hint)</span> </span>&#123;<span class="hljs-keyword">if</span> (loadBalancer == <span class="hljs-keyword">null</span>) &#123;<span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;&#125;<span class="hljs-comment">// Use 'default' on a null hint, or just pass it on?</span><span class="hljs-keyword">return</span> loadBalancer.chooseServer(hint != <span class="hljs-keyword">null</span> ? hint : <span class="hljs-string">"default"</span>);&#125;</code></pre><p>getServer方法使用ILoadBalancer获取了具体的服务。由第二小节ribbonClient实例配置中，我们知道，默认的loadBalancer是<code>ZoneAwareLoadBalancer</code>，通过<code>ZoneAwareLoadBalancer</code>的chooseServer方法获取到负载均衡策略分配到的服务实例server，将其包装成RibbonServer，继续执行execute方法：</p><pre><code class="hljs java"><span class="hljs-meta">@Override</span><span class="hljs-keyword">public</span> &lt;T&gt; <span class="hljs-function">T <span class="hljs-title">execute</span><span class="hljs-params">(String serviceId, ServiceInstance serviceInstance,</span></span><span class="hljs-function"><span class="hljs-params">LoadBalancerRequest&lt;T&gt; request)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;Server server = <span class="hljs-keyword">null</span>;<span class="hljs-keyword">if</span> (serviceInstance <span class="hljs-keyword">instanceof</span> RibbonServer) &#123;server = ((RibbonServer) serviceInstance).getServer();&#125;<span class="hljs-keyword">if</span> (server == <span class="hljs-keyword">null</span>) &#123;<span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalStateException(<span class="hljs-string">"No instances available for "</span> + serviceId);&#125;RibbonLoadBalancerContext context = <span class="hljs-keyword">this</span>.clientFactory.getLoadBalancerContext(serviceId);    <span class="hljs-comment">// 这里还使用了RibbonStatsRecorder来跟踪服务请求记录</span>RibbonStatsRecorder statsRecorder = <span class="hljs-keyword">new</span> RibbonStatsRecorder(context, server);<span class="hljs-keyword">try</span> &#123;      <span class="hljs-comment">// 回调LoadBalancerInterceptor中的LoadBalancerRequest的apply函数，向一个实际的服务发起请求</span>T returnVal = request.apply(serviceInstance);statsRecorder.recordStats(returnVal);<span class="hljs-keyword">return</span> returnVal;&#125;<span class="hljs-comment">// catch IOException and rethrow so RestTemplate behaves correctly</span><span class="hljs-keyword">catch</span> (IOException ex) &#123;statsRecorder.recordStats(ex);<span class="hljs-keyword">throw</span> ex;&#125;<span class="hljs-keyword">catch</span> (Exception ex) &#123;statsRecorder.recordStats(ex);ReflectionUtils.rethrowRuntimeException(ex);&#125;<span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;&#125;</code></pre><blockquote><p>回调LoadBalancerInterceptor中的LoadBalancerRequest的apply函数，向一个实际的服务发起请求。从而实现了一开始以服务名作为host的URI到host:port形式的实际请求地址的转换。</p></blockquote><p>request.apply(serviceInstance)的具体实现如下</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> LoadBalancerRequest&lt;ClientHttpResponse&gt; <span class="hljs-title">createRequest</span><span class="hljs-params">(</span></span><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">final</span> HttpRequest request, <span class="hljs-keyword">final</span> <span class="hljs-keyword">byte</span>[] body,</span></span><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">final</span> ClientHttpRequestExecution execution)</span> </span>&#123;<span class="hljs-keyword">return</span> instance -&gt; &#123;      <span class="hljs-comment">// 接收传入的serviceInstance，将其包装成HttpRequest</span>HttpRequest serviceRequest = <span class="hljs-keyword">new</span> ServiceRequestWrapper(request, instance,<span class="hljs-keyword">this</span>.loadBalancer);<span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.transformers != <span class="hljs-keyword">null</span>) &#123;<span class="hljs-keyword">for</span> (LoadBalancerRequestTransformer transformer : <span class="hljs-keyword">this</span>.transformers) &#123;serviceRequest = transformer.transformRequest(serviceRequest,instance);&#125;&#125;      <span class="hljs-comment">// 调用ClientHttpRequestExecution并传入serviceRequest</span><span class="hljs-keyword">return</span> execution.execute(serviceRequest, body);&#125;;&#125;</code></pre><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">InterceptingClientHttpRequest</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractBufferingClientHttpRequest</span> </span>&#123;  ···<span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">public</span> ClientHttpResponse <span class="hljs-title">execute</span><span class="hljs-params">(HttpRequest request, <span class="hljs-keyword">byte</span>[] body)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.iterator.hasNext()) &#123;ClientHttpRequestInterceptor nextInterceptor = <span class="hljs-keyword">this</span>.iterator.next();<span class="hljs-keyword">return</span> nextInterceptor.intercept(request, body, <span class="hljs-keyword">this</span>);&#125;<span class="hljs-keyword">else</span> &#123;HttpMethod method = request.getMethod();Assert.state(method != <span class="hljs-keyword">null</span>, <span class="hljs-string">"No standard HTTP method"</span>);        <span class="hljs-comment">// 这里真正创建请求，传入request.getURI()，即调用了上一步包装的HttpRequest.getURI()</span>ClientHttpRequest delegate = requestFactory.createRequest(request.getURI(), method);request.getHeaders().forEach((key, value) -&gt; delegate.getHeaders().addAll(key, value));<span class="hljs-keyword">if</span> (body.length &gt; <span class="hljs-number">0</span>) &#123;<span class="hljs-keyword">if</span> (delegate <span class="hljs-keyword">instanceof</span> StreamingHttpOutputMessage) &#123;StreamingHttpOutputMessage streamingOutputMessage = (StreamingHttpOutputMessage) delegate;streamingOutputMessage.setBody(outputStream -&gt; StreamUtils.copy(body, outputStream));&#125;<span class="hljs-keyword">else</span> &#123;StreamUtils.copy(body, delegate.getBody());&#125;&#125;<span class="hljs-keyword">return</span> delegate.execute();&#125;&#125;&#125;</code></pre><p>包装类HttpRequest.getURI()方法如下：</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ServiceRequestWrapper</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">HttpRequestWrapper</span> </span>&#123;<span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> ServiceInstance instance;<span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> LoadBalancerClient loadBalancer;<span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">public</span> URI <span class="hljs-title">getURI</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-comment">// 这里获取URI时，调用了loadBalancer.reconstructURI方法</span>URI uri = <span class="hljs-keyword">this</span>.loadBalancer.reconstructURI(<span class="hljs-keyword">this</span>.instance, getRequest().getURI());<span class="hljs-keyword">return</span> uri;&#125;</code></pre><p>reconstructURI如下：</p><pre><code class="hljs java"><span class="hljs-keyword">private</span> SpringClientFactory clientFactory;<span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">public</span> URI <span class="hljs-title">reconstructURI</span><span class="hljs-params">(ServiceInstance instance, URI original)</span> </span>&#123;Assert.notNull(instance, <span class="hljs-string">"instance can not be null"</span>);    <span class="hljs-comment">// 获取服务id</span>String serviceId = instance.getServiceId();    <span class="hljs-comment">// 从SpringClientFactory中获取对应服务的负载均衡器的上下文对象</span>RibbonLoadBalancerContext context = <span class="hljs-keyword">this</span>.clientFactory.getLoadBalancerContext(serviceId);URI uri;Server server;<span class="hljs-keyword">if</span> (instance <span class="hljs-keyword">instanceof</span> RibbonServer) &#123;      <span class="hljs-comment">// 根据ServiceInstance构建具体服务实例信息的Server对象</span>RibbonServer ribbonServer = (RibbonServer) instance;      <span class="hljs-comment">// 将springCloud定义的ServiceInstance转成netflix中需要的Server对象</span>server = ribbonServer.getServer();uri = updateToSecureConnectionIfNeeded(original, ribbonServer);&#125;<span class="hljs-keyword">else</span> &#123;server = <span class="hljs-keyword">new</span> Server(instance.getScheme(), instance.getHost(),instance.getPort());IClientConfig clientConfig = clientFactory.getClientConfig(serviceId);ServerIntrospector serverIntrospector = serverIntrospector(serviceId);uri = updateToSecureConnectionIfNeeded(original, clientConfig,serverIntrospector, server);&#125;    <span class="hljs-comment">// 使用上下文对象来构建服务实例的URL</span><span class="hljs-keyword">return</span> context.reconstructURIWithServer(server, uri);&#125;</code></pre><blockquote><p>SpringClientFactory是一个用来创建客户端负载均衡器的工厂类，它为每一个不同名的ribbon客户端生成不同的Spring上下文。</p></blockquote><blockquote><p>RibbonLoadBalancerContext时LoadBalancerContext的子类，用于存储负载均衡器本身的一些上下文内容和常用API操作，如reconstructURIWithServer。</p></blockquote><p>reconstructURIWithServer如下：</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> URI <span class="hljs-title">reconstructURIWithServer</span><span class="hljs-params">(Server server, URI original)</span> </span>&#123;  <span class="hljs-comment">// 从server中获取host和port信息，然后和original中的其他信息进行拼接整合，形成最终要访问的服务实例的具体地址</span>        String host = server.getHost();        <span class="hljs-keyword">int</span> port = server.getPort();        String scheme = server.getScheme();                <span class="hljs-keyword">if</span> (host.equals(original.getHost())                 &amp;&amp; port == original.getPort()                &amp;&amp; scheme == original.getScheme()) &#123;            <span class="hljs-keyword">return</span> original;        &#125;        <span class="hljs-keyword">if</span> (scheme == <span class="hljs-keyword">null</span>) &#123;            scheme = original.getScheme();        &#125;        <span class="hljs-keyword">if</span> (scheme == <span class="hljs-keyword">null</span>) &#123;            scheme = deriveSchemeAndPortFromPartialUri(original).first();        &#125;        <span class="hljs-keyword">try</span> &#123;            StringBuilder sb = <span class="hljs-keyword">new</span> StringBuilder();            sb.append(scheme).append(<span class="hljs-string">"://"</span>);            <span class="hljs-keyword">if</span> (!Strings.isNullOrEmpty(original.getRawUserInfo())) &#123;                sb.append(original.getRawUserInfo()).append(<span class="hljs-string">"@"</span>);            &#125;            sb.append(host);            <span class="hljs-keyword">if</span> (port &gt;= <span class="hljs-number">0</span>) &#123;                sb.append(<span class="hljs-string">":"</span>).append(port);            &#125;            sb.append(original.getRawPath());            <span class="hljs-keyword">if</span> (!Strings.isNullOrEmpty(original.getRawQuery())) &#123;                sb.append(<span class="hljs-string">"?"</span>).append(original.getRawQuery());            &#125;            <span class="hljs-keyword">if</span> (!Strings.isNullOrEmpty(original.getRawFragment())) &#123;                sb.append(<span class="hljs-string">"#"</span>).append(original.getRawFragment());            &#125;            URI newURI = <span class="hljs-keyword">new</span> URI(sb.toString());            <span class="hljs-keyword">return</span> newURI;                    &#125; <span class="hljs-keyword">catch</span> (URISyntaxException e) &#123;            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(e);        &#125;    &#125;</code></pre><h3 id="5、负载均衡器接口"><a href="#5、负载均衡器接口" class="headerlink" title="5、负载均衡器接口"></a>5、负载均衡器接口</h3><ul><li><p>ILoadBalancer</p><p>ILoadBalancer 中定义了负载均衡器的操作的接口：</p></li></ul><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * Interface that defines the operations for a software loadbalancer. </span><span class="hljs-comment"> * A typical loadbalancer minimally need a set of servers to loadbalance for, a method to</span><span class="hljs-comment"> * mark a particular server to be out of rotation and a call that will choose a</span><span class="hljs-comment"> * server from the existing list of server.</span><span class="hljs-comment"> * 一个接口，用于定义软件负载均衡的操作。</span><span class="hljs-comment"> * 一个典型的负载均衡器最少需要一组实例进行负载均衡。</span><span class="hljs-comment"> * 一个方法去标记特定的服务不可用</span><span class="hljs-comment"> * 一个调用，从现有的服务列表中选择一个服务</span><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> stonse</span><span class="hljs-comment"> * </span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">ILoadBalancer</span> </span>&#123;<span class="hljs-comment">/**</span><span class="hljs-comment"> * Initial list of servers.</span><span class="hljs-comment"> * This API also serves to add additional ones at a later time</span><span class="hljs-comment"> * The same logical server (host:port) could essentially be added multiple times</span><span class="hljs-comment"> * (helpful in cases where you want to give more "weightage" perhaps ..)</span><span class="hljs-comment"> * 初始化服务列表。</span><span class="hljs-comment"> * 也可以用于追加服务到列表中。</span><span class="hljs-comment"> * 同一逻辑服务(host:port) 本质上可以多次添加。</span><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> newServers new servers to add</span><span class="hljs-comment"> */</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addServers</span><span class="hljs-params">(List&lt;Server&gt; newServers)</span></span>;<span class="hljs-comment">/**</span><span class="hljs-comment"> * Choose a server from load balancer.</span><span class="hljs-comment"> * 根据key从负载均衡器中选择一个服务</span><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> key An object that the load balancer may use to determine which server to return. null if </span><span class="hljs-comment"> *         the load balancer does not use this parameter.</span><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> server chosen</span><span class="hljs-comment"> */</span><span class="hljs-function"><span class="hljs-keyword">public</span> Server <span class="hljs-title">chooseServer</span><span class="hljs-params">(Object key)</span></span>;<span class="hljs-comment">/**</span><span class="hljs-comment"> * To be called by the clients of the load balancer to notify that a Server is down</span><span class="hljs-comment"> * else, the LB will think its still Alive until the next Ping cycle - potentially</span><span class="hljs-comment"> * (assuming that the LB Impl does a ping)</span><span class="hljs-comment"> * 由负载均衡器的客户端去调用，通知服务已关闭。否则LB将认为它仍然有效，直到下一个ping周期</span><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> server Server to mark as down</span><span class="hljs-comment"> */</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">markServerDown</span><span class="hljs-params">(Server server)</span></span>;<span class="hljs-comment">/**返回所有可用的服务列表</span><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> Only the servers that are up and reachable.</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;Server&gt; <span class="hljs-title">getReachableServers</span><span class="hljs-params">()</span></span>;    <span class="hljs-comment">/**返回所有的服务列表（包含可用、不可用的）</span><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> All known servers, both reachable and unreachable.</span><span class="hljs-comment">     */</span><span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;Server&gt; <span class="hljs-title">getAllServers</span><span class="hljs-params">()</span></span>;&#125;</code></pre><blockquote><p>Server对象包含了服务端节点的元数据信息，如host、port、以及一些部署信息。</p></blockquote><p>ILoadBalancer的实现类，完整的类图如下：</p><p><img src="/blog/2020/06/15/ribbon%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/ILoadBalancerDiagram.png" srcset="/blog/img/loading.gif" alt="ILoadBalancerDiagram"></p><p>从上面的类图可以看到，ILoadBalancer 有三个实现类，BaseLoadBalancer实现了基础的负载均衡，DynamicServerListLoadBalancer和ZoneAwareLoadBalancer则在策略上做了一些功能的扩展。他们之间是继承关系，最终的实现类是 ZoneAwareLoadBalancer。</p><p>很多东西都是定义在BaseLoadBalancer中的，先从 BaseLoadBalancer 中的 变量看：</p><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * A basic implementation of the load balancer where an arbitrary list of</span><span class="hljs-comment"> * servers can be set as the server pool. A ping can be set to determine the</span><span class="hljs-comment"> * liveness of a server. Internally, this class maintains an "all" server list</span><span class="hljs-comment"> * and an "up" server list and use them depending on what the caller asks for.</span><span class="hljs-comment"> * 一个基础的负载均衡器的实现类</span><span class="hljs-comment"> * 默认的ping策略去查明存活的服务</span><span class="hljs-comment"> * 维护一个所有服务的list和存活服务的list</span><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> stonse</span><span class="hljs-comment"> * </span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BaseLoadBalancer</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractLoadBalancer</span> <span class="hljs-keyword">implements</span></span><span class="hljs-class">        <span class="hljs-title">PrimeConnections</span>.<span class="hljs-title">PrimeConnectionListener</span>, <span class="hljs-title">IClientConfigAware</span> </span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Logger logger = LoggerFactory            .getLogger(BaseLoadBalancer<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;  <span class="hljs-comment">// 默认的线性轮询负载均衡策略</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">static</span> IRule DEFAULT_RULE = <span class="hljs-keyword">new</span> RoundRobinRule();  <span class="hljs-comment">// 串行ping策略</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">static</span> SerialPingStrategy DEFAULT_PING_STRATEGY = <span class="hljs-keyword">new</span> SerialPingStrategy();    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String DEFAULT_NAME = <span class="hljs-string">"default"</span>;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String PREFIX = <span class="hljs-string">"LoadBalancer_"</span>;    <span class="hljs-keyword">protected</span> IRule rule = DEFAULT_RULE;    <span class="hljs-keyword">protected</span> IPingStrategy pingStrategy = DEFAULT_PING_STRATEGY;    <span class="hljs-keyword">protected</span> IPing ping = <span class="hljs-keyword">null</span>;<span class="hljs-comment">// 所有服务列表</span>    <span class="hljs-meta">@Monitor</span>(name = PREFIX + <span class="hljs-string">"AllServerList"</span>, type = DataSourceType.INFORMATIONAL)    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">volatile</span> List&lt;Server&gt; allServerList = Collections            .synchronizedList(<span class="hljs-keyword">new</span> ArrayList&lt;Server&gt;());    <span class="hljs-comment">// 存续服务列表</span>  <span class="hljs-meta">@Monitor</span>(name = PREFIX + <span class="hljs-string">"UpServerList"</span>, type = DataSourceType.INFORMATIONAL)    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">volatile</span> List&lt;Server&gt; upServerList = Collections            .synchronizedList(<span class="hljs-keyword">new</span> ArrayList&lt;Server&gt;());<span class="hljs-comment">// 客户端配置</span>    <span class="hljs-keyword">private</span> IClientConfig config;     <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">BaseLoadBalancer</span><span class="hljs-params">(String name, IRule rule, LoadBalancerStats stats,</span></span><span class="hljs-function"><span class="hljs-params">            IPing ping, IPingStrategy pingStrategy)</span> </span>&#123;        logger.debug(<span class="hljs-string">"LoadBalancer [&#123;&#125;]:  initialized"</span>, name);                <span class="hljs-keyword">this</span>.name = name;        <span class="hljs-keyword">this</span>.ping = ping;        <span class="hljs-keyword">this</span>.pingStrategy = pingStrategy;        setRule(rule);        setupPingTask();        lbStats = stats;        init();    &#125;</code></pre><p>从上面的变量信息我们可以看出一些东西：</p><ol><li>默认的 负载均衡策略是随机负载均衡；</li><li>默认的Ping策略为串行化Ping；</li><li>使用了一个list来保存所有的服务列表，一个list来保存当前所有的存活状态的服务列表；</li><li>定义了客户端配置，用于初始化客户端以及负载均衡配置 。</li><li>PingTask定时验证服务器状态</li></ol><p>分析完 BaseLoadBalancer ，DynamicServerListLoadBalancer 和 ZoneAwareLoadBalancer 基本大同小异：</p><ul><li><strong>DynamicServerListLoadBalancer</strong> ：使用动态源的服务器， 即服务器列表可能是在运行时更改。 通过一些Filter函数来动态的过滤掉指定的服务器列表；</li><li><strong>ZoneAwareLoadBalancer</strong> ：这个负载均衡器适用于异地多机房的情况，在选择服务器的时候可以避免整个区域。LoadBalancer将计算并检查所有可用区域的区域统计信息。如果任何区域的“平均活动请求数”已达到配置的阈值，则该区域将从活动服务器列表中删除。如果多个区域已达到阈值，则将删除每台服务器上最活跃请求的区域。一旦删除了最坏的区域，将在其余区域中选择一个区域，其概率与其实例数成正比。服务器将从具有指定规则的选定区域返回。对于每个请求都将重复上述步骤，也就是说，每个区域相关的负载平衡决策都是在最新统计信息的帮助下实时做的。</li></ul><h2 id="三、总结"><a href="#三、总结" class="headerlink" title="三、总结"></a>三、总结</h2><p>使用<code>@LoadBalanced</code>注解标记<code>RestTemplate</code>，在<code>LoadBalancerAutoConfiguration</code>中注入被标记的<code>RestTemplate</code>，使用<code>RestTemplateCustomizer</code>（定制器）并为其增加<code>LoadBalancerInterceptor</code>的拦截器，拦截器中调用<code>LoadBalancerClient</code>（负载均衡客户端）进行处理，获取实际server信息，并回调request，将以逻辑服务名为host的URI转成具体的服务实例。而<code>LoadBalancerClient</code>（负载均衡客户端）内部实际还是调用netflix的 <code>ILoadBalancer</code>（负载均衡器）接口的实现<strong>（ZoneAwareLoadBalancer）</strong></p><p>在<code>ILoadBalancer</code> （负载均衡器）中配置了PIng策略、负载均衡策略、服务列表信息。整个过程如下：</p><p><code>@LoadBalanced</code>–&gt;<code>LoadBalancerAutoConfiguration</code>–&gt;<code>RestTemplateCustomizer</code>–&gt;<code>LoadBalancerInterceptor</code>–&gt;<code>LoadBalancerClient</code>–&gt;<code>ILoadBalancer</code></p><p>注解限定 –&gt; rest定制器 –&gt;  拦截器 –&gt;  客户端  –&gt; 负载均衡器</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;一、-LoadBalanced注解&quot;&gt;&lt;a href=&quot;#一、-LoadBalanced注解&quot; class=&quot;headerlink&quot; title=&quot;一、@LoadBalanced注解&quot;&gt;&lt;/a&gt;一、@LoadBalanced注解&lt;/h2&gt;&lt;p&gt;唯一加的注解就是&lt;c
      
    
    </summary>
    
    
      <category term="springCloud" scheme="http://yoursite.com/categories/springCloud/"/>
    
    
      <category term="ribbon" scheme="http://yoursite.com/tags/ribbon/"/>
    
  </entry>
  
  <entry>
    <title>eureka源码</title>
    <link href="http://yoursite.com/2020/06/13/eureka%E6%BA%90%E7%A0%81/"/>
    <id>http://yoursite.com/2020/06/13/eureka%E6%BA%90%E7%A0%81/</id>
    <published>2020-06-13T13:35:50.000Z</published>
    <updated>2020-06-13T15:17:05.142Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、两种方式禁用服务注册"><a href="#一、两种方式禁用服务注册" class="headerlink" title="一、两种方式禁用服务注册"></a>一、两种方式禁用服务注册</h2><h3 id="1、-EnableDiscoveryClient-autoRegister-false"><a href="#1、-EnableDiscoveryClient-autoRegister-false" class="headerlink" title="1、@EnableDiscoveryClient(autoRegister=false)"></a>1、@EnableDiscoveryClient(autoRegister=false)</h3><h3 id="2、spring-cloud-service-registry-auto-registration-enabled-false"><a href="#2、spring-cloud-service-registry-auto-registration-enabled-false" class="headerlink" title="2、spring.cloud.service-registry.auto-registration.enabled=false"></a>2、spring.cloud.service-registry.auto-registration.enabled=false</h3><pre><code class="hljs java"><span class="hljs-meta">@Import</span>(EnableDiscoveryClientImportSelector<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span><span class="hljs-class"><span class="hljs-title">public</span> @<span class="hljs-title">interface</span> <span class="hljs-title">EnableDiscoveryClient</span> </span>&#123;<span class="hljs-comment">/**</span><span class="hljs-comment"> * If true, the ServiceRegistry will automatically register the local server.</span><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> - &#123;<span class="hljs-doctag">@code</span> true&#125; if you want to automatically register.</span><span class="hljs-comment"> */</span><span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">autoRegister</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">true</span></span>;&#125;</code></pre><ul><li>该配置项默认为true，但是可以主动声明去禁用</li></ul><p><strong><code>@Import(EnableDiscoveryClientImportSelector.class)</code></strong>的源码如下：</p><pre><code class="hljs java"><span class="hljs-meta">@Order</span>(Ordered.LOWEST_PRECEDENCE - <span class="hljs-number">100</span>)<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">EnableDiscoveryClientImportSelector</span></span><span class="hljs-class"><span class="hljs-keyword">extends</span> <span class="hljs-title">SpringFactoryImportSelector</span>&lt;<span class="hljs-title">EnableDiscoveryClient</span>&gt; </span>&#123;<span class="hljs-meta">@Override</span><span class="hljs-keyword">public</span> String[] selectImports(AnnotationMetadata metadata) &#123;    <span class="hljs-comment">// 父类loadFactoryNames方法，定义去加载了FACTORIES_RESOURCE_LOCATION = "META-INF/spring.factories";中所有的自动配置类</span>String[] imports = <span class="hljs-keyword">super</span>.selectImports(metadata);AnnotationAttributes attributes = AnnotationAttributes.fromMap(metadata.getAnnotationAttributes(getAnnotationClass().getName(), <span class="hljs-keyword">true</span>));<span class="hljs-comment">// 获取注解声明的autoRegister，从而调用实际处理</span><span class="hljs-keyword">boolean</span> autoRegister = attributes.getBoolean(<span class="hljs-string">"autoRegister"</span>);<span class="hljs-keyword">if</span> (autoRegister) &#123;List&lt;String&gt; importsList = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;(Arrays.asList(imports));importsList.add(<span class="hljs-string">"org.springframework.cloud.client.serviceregistry.AutoServiceRegistrationConfiguration"</span>);imports = importsList.toArray(<span class="hljs-keyword">new</span> String[<span class="hljs-number">0</span>]);&#125;<span class="hljs-keyword">else</span> &#123;Environment env = getEnvironment();<span class="hljs-keyword">if</span> (ConfigurableEnvironment<span class="hljs-class">.<span class="hljs-keyword">class</span>.<span class="hljs-title">isInstance</span>(<span class="hljs-title">env</span>)) </span>&#123;ConfigurableEnvironment configEnv = (ConfigurableEnvironment) env;LinkedHashMap&lt;String, Object&gt; map = <span class="hljs-keyword">new</span> LinkedHashMap&lt;&gt;();        <span class="hljs-comment">// 从这里可以看出，其实还是通过这个方式处理的</span>map.put(<span class="hljs-string">"spring.cloud.service-registry.auto-registration.enabled"</span>, <span class="hljs-keyword">false</span>);MapPropertySource propertySource = <span class="hljs-keyword">new</span> MapPropertySource(<span class="hljs-string">"springCloudDiscoveryClient"</span>, map);configEnv.getPropertySources().addLast(propertySource);&#125;&#125;<span class="hljs-keyword">return</span> imports;&#125;</code></pre><h2 id="二、springCloud对netflixEureka进行了封装"><a href="#二、springCloud对netflixEureka进行了封装" class="headerlink" title="二、springCloud对netflixEureka进行了封装"></a>二、springCloud对netflixEureka进行了封装</h2><p>打开<code>spring-cloud-starter-netflix-eureka-client.jar</code>，找到<code>META-INF/spring.factories</code>，内容如下：</p><pre><code class="hljs yaml"><span class="hljs-string">org.springframework.boot.autoconfigure.EnableAutoConfiguration=\</span><span class="hljs-string">org.springframework.cloud.netflix.eureka.config.EurekaClientConfigServerAutoConfiguration,\</span><span class="hljs-string">org.springframework.cloud.netflix.eureka.config.DiscoveryClientOptionalArgsConfiguration,\</span><span class="hljs-comment"># EurekaClient的自动配置类</span><span class="hljs-string">org.springframework.cloud.netflix.eureka.EurekaClientAutoConfiguration,\</span><span class="hljs-string">org.springframework.cloud.netflix.ribbon.eureka.RibbonEurekaAutoConfiguration,\</span><span class="hljs-comment"># EurekaDiscoveryClient的自动配置类，默认就扫描加载了</span><span class="hljs-string">org.springframework.cloud.netflix.eureka.EurekaDiscoveryClientConfiguration,\</span><span class="hljs-string">org.springframework.cloud.netflix.eureka.reactive.EurekaReactiveDiscoveryClientConfiguration,\</span><span class="hljs-string">org.springframework.cloud.netflix.eureka.loadbalancer.LoadBalancerEurekaAutoConfiguration</span><span class="hljs-string">org.springframework.cloud.bootstrap.BootstrapConfiguration=\</span><span class="hljs-string">org.springframework.cloud.netflix.eureka.config.EurekaConfigServerBootstrapConfiguration</span></code></pre><p>打开<code>EurekaDiscoveryClientConfiguration</code>，发现，其构造是注入了netflix的EurekaClient，其本身也是一层包装</p><pre><code class="hljs java"><span class="hljs-keyword">import</span> com.netflix.discovery.EurekaClient;<span class="hljs-keyword">import</span> com.netflix.discovery.EurekaClientConfig;<span class="hljs-meta">@Bean</span><span class="hljs-meta">@ConditionalOnMissingBean</span><span class="hljs-function"><span class="hljs-keyword">public</span> EurekaDiscoveryClient <span class="hljs-title">discoveryClient</span><span class="hljs-params">(EurekaClient client,</span></span><span class="hljs-function"><span class="hljs-params">                                             EurekaClientConfig clientConfig)</span> </span>&#123;  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> EurekaDiscoveryClient(client, clientConfig);&#125;</code></pre><p>点进去<code>EurekaClient</code>,其接口和实现类<code>DiscoveryClient</code></p><pre><code class="hljs java"><span class="hljs-meta">@ImplementedBy</span>(DiscoveryClient<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span><span class="hljs-class"><span class="hljs-title">public</span> <span class="hljs-title">interface</span> <span class="hljs-title">EurekaClient</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">LookupService</span> </span>&#123;  ···&#125;</code></pre><p>在<code>DiscoveryClient</code>的构造函数中进行了定时任务的初始化</p><pre><code class="hljs java"><span class="hljs-meta">@Inject</span>DiscoveryClient(ApplicationInfoManager applicationInfoManager, EurekaClientConfig config, AbstractDiscoveryClientOptionalArgs args,                Provider&lt;BackupRegistry&gt; backupRegistryProvider, EndpointRandomizer endpointRandomizer) &#123;···<span class="hljs-comment">// finally, init the schedule tasks (e.g. cluster resolvers, heartbeat, instanceInfo replicator, fetch</span>initScheduledTasks();···</code></pre><h2 id="三、服务获取"><a href="#三、服务获取" class="headerlink" title="三、服务获取"></a>三、服务获取</h2><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * Initializes all scheduled tasks.</span><span class="hljs-comment"> */</span><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">initScheduledTasks</span><span class="hljs-params">()</span> </span>&#123;  <span class="hljs-comment">// 内部是EurekaClientConfigBean中的`eureka.client.fetch-registry=true`参数判断</span>    <span class="hljs-keyword">if</span> (clientConfig.shouldFetchRegistry()) &#123;        <span class="hljs-comment">// registry cache refresh timer</span>        <span class="hljs-keyword">int</span> registryFetchIntervalSeconds = clientConfig.getRegistryFetchIntervalSeconds();        <span class="hljs-keyword">int</span> expBackOffBound = clientConfig.getCacheRefreshExecutorExponentialBackOffBound();      <span class="hljs-comment">// 声明了一个定时任务</span>        cacheRefreshTask = <span class="hljs-keyword">new</span> TimedSupervisorTask(                <span class="hljs-string">"cacheRefresh"</span>,                scheduler,                cacheRefreshExecutor,                registryFetchIntervalSeconds,<span class="hljs-comment">//默认更新周期，30s</span>                TimeUnit.SECONDS,                expBackOffBound,                <span class="hljs-keyword">new</span> CacheRefreshThread()        );              scheduler.schedule(                cacheRefreshTask,                registryFetchIntervalSeconds, TimeUnit.SECONDS);    &#125;····</code></pre><ul><li>服务获取的逻辑处理是一个单独的if</li><li>其判断依据就是eureka.client.fetch-registry=true参数</li></ul><pre><code class="hljs java"><span class="hljs-meta">@ConfigurationProperties</span>(EurekaClientConfigBean.PREFIX)<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">EurekaClientConfigBean</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">EurekaClientConfig</span>, <span class="hljs-title">Ordered</span> </span>&#123;<span class="hljs-comment">/**</span><span class="hljs-comment"> * Default prefix for Eureka client config properties.</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String PREFIX = <span class="hljs-string">"eureka.client"</span>;<span class="hljs-comment">/**</span><span class="hljs-comment"> * Indicates whether this client should fetch eureka registry information from eureka</span><span class="hljs-comment"> * server.</span><span class="hljs-comment"> */</span>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> fetchRegistry = <span class="hljs-keyword">true</span>;</code></pre><h2 id="四、服务注册"><a href="#四、服务注册" class="headerlink" title="四、服务注册"></a>四、服务注册</h2><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment">     * Initializes all scheduled tasks.</span><span class="hljs-comment">     */</span><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">initScheduledTasks</span><span class="hljs-params">()</span> </span>&#123;  ···    <span class="hljs-keyword">if</span> (clientConfig.shouldRegisterWithEureka()) &#123;      ···      <span class="hljs-comment">// InstanceInfo replicator</span>      instanceInfoReplicator = <span class="hljs-keyword">new</span> InstanceInfoReplicator(        <span class="hljs-keyword">this</span>,        instanceInfo,        clientConfig.getInstanceInfoReplicationIntervalSeconds(),        <span class="hljs-number">2</span>); <span class="hljs-comment">// burstSize</span>      ···      instanceInfoReplicator.start(clientConfig.getInitialInstanceInfoReplicationIntervalSeconds());    &#125; <span class="hljs-keyword">else</span> &#123;      logger.info(<span class="hljs-string">"Not registering with Eureka server per configuration"</span>);    &#125;&#125;</code></pre><ul><li>创建了一个instanceInfoReplicator实例，start调用进行定时任务</li></ul><p>定时任务具体如下：</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;  <span class="hljs-keyword">try</span> &#123;    discoveryClient.refreshInstanceInfo();    Long dirtyTimestamp = instanceInfo.isDirtyWithTime();    <span class="hljs-keyword">if</span> (dirtyTimestamp != <span class="hljs-keyword">null</span>) &#123;      <span class="hljs-comment">// 真是出发调用注册的地方就在这里</span>      discoveryClient.register();     ···&#125;<span class="hljs-comment">/**</span><span class="hljs-comment">     * Register with the eureka service by making the appropriate REST call.</span><span class="hljs-comment">     */</span><span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">register</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Throwable </span>&#123;  logger.info(PREFIX + <span class="hljs-string">"&#123;&#125;: registering service..."</span>, appPathIdentifier);  EurekaHttpResponse&lt;Void&gt; httpResponse;  <span class="hljs-keyword">try</span> &#123;    <span class="hljs-comment">// 注册也是通过rest请求，传入了一个instanceInfo对象</span>    httpResponse = eurekaTransport.registrationClient.register(instanceInfo);  &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;    logger.warn(PREFIX + <span class="hljs-string">"&#123;&#125; - registration failed &#123;&#125;"</span>, appPathIdentifier, e.getMessage(), e);    <span class="hljs-keyword">throw</span> e;  &#125;  <span class="hljs-keyword">if</span> (logger.isInfoEnabled()) &#123;    logger.info(PREFIX + <span class="hljs-string">"&#123;&#125; - registration status: &#123;&#125;"</span>, appPathIdentifier, httpResponse.getStatusCode());  &#125;  <span class="hljs-keyword">return</span> httpResponse.getStatusCode() == Status.NO_CONTENT.getStatusCode();&#125;</code></pre><h2 id="五、服务续约"><a href="#五、服务续约" class="headerlink" title="五、服务续约"></a>五、服务续约</h2><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * Initializes all scheduled tasks.</span><span class="hljs-comment"> */</span><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">initScheduledTasks</span><span class="hljs-params">()</span> </span>&#123;    ···    <span class="hljs-keyword">if</span> (clientConfig.shouldRegisterWithEureka()) &#123;        <span class="hljs-keyword">int</span> renewalIntervalInSecs = instanceInfo.getLeaseInfo().getRenewalIntervalInSecs();        <span class="hljs-keyword">int</span> expBackOffBound = clientConfig.getHeartbeatExecutorExponentialBackOffBound();        logger.info(<span class="hljs-string">"Starting heartbeat executor: "</span> + <span class="hljs-string">"renew interval is: &#123;&#125;"</span>, renewalIntervalInSecs);        <span class="hljs-comment">// Heartbeat timer</span>        heartbeatTask = <span class="hljs-keyword">new</span> TimedSupervisorTask(                <span class="hljs-string">"heartbeat"</span>,                scheduler,                heartbeatExecutor,                renewalIntervalInSecs,                TimeUnit.SECONDS,                expBackOffBound,                <span class="hljs-keyword">new</span> HeartbeatThread()        );        scheduler.schedule(                heartbeatTask,                renewalIntervalInSecs, TimeUnit.SECONDS);···&#125;  <span class="hljs-comment">/**</span><span class="hljs-comment">     * The heartbeat task that renews the lease in the given intervals.</span><span class="hljs-comment">     */</span><span class="hljs-keyword">private</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HeartbeatThread</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Runnable</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;      <span class="hljs-keyword">if</span> (renew()) &#123;        lastSuccessfulHeartbeatTimestamp = System.currentTimeMillis();      &#125;    &#125;&#125;  <span class="hljs-comment">/**</span><span class="hljs-comment">     * Renew with the eureka service by making the appropriate REST call</span><span class="hljs-comment">     */</span><span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">renew</span><span class="hljs-params">()</span> </span>&#123;  EurekaHttpResponse&lt;InstanceInfo&gt; httpResponse;  <span class="hljs-keyword">try</span> &#123;    <span class="hljs-comment">// 续约也是rest方式</span>    httpResponse = eurekaTransport.registrationClient.sendHeartBeat(instanceInfo.getAppName(), instanceInfo.getId(), instanceInfo, <span class="hljs-keyword">null</span>);    logger.debug(PREFIX + <span class="hljs-string">"&#123;&#125; - Heartbeat status: &#123;&#125;"</span>, appPathIdentifier, httpResponse.getStatusCode());    <span class="hljs-keyword">if</span> (httpResponse.getStatusCode() == Status.NOT_FOUND.getStatusCode()) &#123;      REREGISTER_COUNTER.increment();      logger.info(PREFIX + <span class="hljs-string">"&#123;&#125; - Re-registering apps/&#123;&#125;"</span>, appPathIdentifier, instanceInfo.getAppName());      <span class="hljs-keyword">long</span> timestamp = instanceInfo.setIsDirtyWithTime();      <span class="hljs-keyword">boolean</span> success = register();      <span class="hljs-keyword">if</span> (success) &#123;        instanceInfo.unsetIsDirty(timestamp);      &#125;      <span class="hljs-keyword">return</span> success;    &#125;    <span class="hljs-keyword">return</span> httpResponse.getStatusCode() == Status.OK.getStatusCode();  &#125; <span class="hljs-keyword">catch</span> (Throwable e) &#123;    logger.error(PREFIX + <span class="hljs-string">"&#123;&#125; - was unable to send heartbeat!"</span>, appPathIdentifier, e);    <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;  &#125;&#125;</code></pre><ul><li>声明了一个heartbeatTask定时任务进行续约，传入HeartbeatThread</li><li>服务续约也是rest方式</li></ul><h2 id="六、配置详解"><a href="#六、配置详解" class="headerlink" title="六、配置详解"></a>六、配置详解</h2><p><code>META-INF/spring.factories</code>，内容中还有个<code>EurekaClientAutoConfiguration</code>，用于加载配置参数类</p><pre><code class="hljs yaml"><span class="hljs-comment"># EurekaClient的自动配置类</span><span class="hljs-string">org.springframework.cloud.netflix.eureka.EurekaClientAutoConfiguration,\</span></code></pre><pre><code class="hljs java"><span class="hljs-meta">@Bean</span><span class="hljs-meta">@ConditionalOnMissingBean</span>(value = EurekaClientConfig<span class="hljs-class">.<span class="hljs-keyword">class</span>,</span><span class="hljs-class">                          <span class="hljs-title">search</span> </span>= SearchStrategy.CURRENT)<span class="hljs-function"><span class="hljs-keyword">public</span> EurekaClientConfigBean <span class="hljs-title">eurekaClientConfigBean</span><span class="hljs-params">(ConfigurableEnvironment env)</span> </span>&#123;  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> EurekaClientConfigBean();&#125;<span class="hljs-meta">@Bean</span><span class="hljs-meta">@ConditionalOnMissingBean</span>(value = EurekaInstanceConfig<span class="hljs-class">.<span class="hljs-keyword">class</span>,</span><span class="hljs-class">                          <span class="hljs-title">search</span> </span>= SearchStrategy.CURRENT)<span class="hljs-function"><span class="hljs-keyword">public</span> EurekaInstanceConfigBean <span class="hljs-title">eurekaInstanceConfigBean</span><span class="hljs-params">(InetUtils inetUtils,</span></span><span class="hljs-function"><span class="hljs-params">                                                         ManagementMetadataProvider managementMetadataProvider)</span> </span>&#123;&#125;</code></pre><ul><li>可以查看<code>EurekaClientConfigBean</code>和<code>EurekaInstanceConfigBean</code>获取比官方文档更详细的解释说明</li><li>eureka的所有的配置信息，都是通过<code>EurekaInstanceConfigBean</code>加载的，真正注册时，内部包装成<code>InstanceInfo</code>进行传递</li></ul><h3 id="1、注册中心配置"><a href="#1、注册中心配置" class="headerlink" title="1、注册中心配置"></a>1、注册中心配置</h3><ul><li><code>eureka.client.serverUrl.defaultZone=xxx</code>：</li></ul><pre><code class="hljs java"><span class="hljs-keyword">private</span> Map&lt;String, String&gt; serviceUrl = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();&#123;   <span class="hljs-keyword">this</span>.serviceUrl.put(DEFAULT_ZONE, DEFAULT_URL);&#125;<span class="hljs-comment">/**</span><span class="hljs-comment"> * Default Eureka URL.</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String DEFAULT_URL = <span class="hljs-string">"http://localhost:8761"</span> + DEFAULT_PREFIX+ <span class="hljs-string">"/"</span>;<span class="hljs-comment">/**</span><span class="hljs-comment"> * Default availability zone if none is resolved based on region.</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String DEFAULT_ZONE = <span class="hljs-string">"defaultZone"</span>;</code></pre><h3 id="2、实例名配置"><a href="#2、实例名配置" class="headerlink" title="2、实例名配置"></a>2、实例名配置</h3><ul><li><code>eureka.instance.instanceId</code></li><li>它是区分同一服务不同实例的唯一标识</li><li>实例名采用主机名作为唯一标识，规则如下</li></ul><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title">getDefaultInstanceId</span><span class="hljs-params">(PropertyResolver resolver,</span></span><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">boolean</span> includeHostname)</span> </span>&#123;String vcapInstanceId = resolver.getProperty(<span class="hljs-string">"vcap.application.instance_id"</span>);<span class="hljs-keyword">if</span> (StringUtils.hasText(vcapInstanceId)) &#123;<span class="hljs-keyword">return</span> vcapInstanceId;&#125;String hostname = <span class="hljs-keyword">null</span>;<span class="hljs-keyword">if</span> (includeHostname) &#123;hostname = resolver.getProperty(<span class="hljs-string">"spring.cloud.client.hostname"</span>);&#125;String appName = resolver.getProperty(<span class="hljs-string">"spring.application.name"</span>);String namePart = combineParts(hostname, SEPARATOR, appName);String indexPart = resolver.getProperty(<span class="hljs-string">"spring.application.instance_id"</span>,resolver.getProperty(<span class="hljs-string">"server.port"</span>));<span class="hljs-keyword">return</span> combineParts(namePart, SEPARATOR, indexPart);&#125;</code></pre><blockquote><p>即 <code>${spring.cloud.client.hostname}:${spring.application.name}:${spring.application.instance_id}</code></p></blockquote><h3 id="3、端点配置"><a href="#3、端点配置" class="headerlink" title="3、端点配置"></a>3、端点配置</h3><ul><li><p><code>homePageUrl、statusPageUrl、healthCheckUrl</code>，即<code>spring-boot-actuator</code>模块提供的<code>/info</code>和<code>/health</code>端点</p></li><li><p>当应用设置了context-path时，端点也需要加上该前缀</p></li></ul><pre><code class="hljs ini"><span class="hljs-attr">xxx.context-path</span>=/orange<span class="hljs-attr">eureka.instance.statusPageUrlPath</span>=<span class="hljs-variable">$&#123;xxx.context-path&#125;</span>/info<span class="hljs-attr">eureka.instance.healthCheckUrlPath</span>=<span class="hljs-variable">$&#123;xxx.context-path&#125;</span>/health</code></pre><ul><li>或者为了安全考虑，修改端点的原始路径</li></ul><pre><code class="hljs ini"><span class="hljs-attr">endpoints.info.path</span>=/orangeInfo<span class="hljs-attr">endpoints.health.path</span>=/orangeHealth<span class="hljs-attr">eureka.instance.statusPageUrlPath</span>=<span class="hljs-variable">$&#123;endpoints.info.path&#125;</span><span class="hljs-attr">eureka.instance.healthCheckUrlPath</span>=<span class="hljs-variable">$&#123;endpoints.health.path&#125;</span></code></pre><h3 id="4、健康检查"><a href="#4、健康检查" class="headerlink" title="4、健康检查"></a>4、健康检查</h3><ul><li>客户端默认的心跳方式可以有效的检查客户端进程是否运行，但是无法保证客户端能否正常提供服务</li><li>可以把客户端的健康检查交给actuator</li></ul><pre><code class="hljs yaml"><span class="hljs-comment"># 在pom中引入Spring-boot-starter-actuator</span><span class="hljs-comment"># 增加参数配置：eureka.client.healthcheck.enabled=true</span></code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;一、两种方式禁用服务注册&quot;&gt;&lt;a href=&quot;#一、两种方式禁用服务注册&quot; class=&quot;headerlink&quot; title=&quot;一、两种方式禁用服务注册&quot;&gt;&lt;/a&gt;一、两种方式禁用服务注册&lt;/h2&gt;&lt;h3 id=&quot;1、-EnableDiscoveryClient-
      
    
    </summary>
    
    
      <category term="springCloud" scheme="http://yoursite.com/categories/springCloud/"/>
    
    
      <category term="eureka" scheme="http://yoursite.com/tags/eureka/"/>
    
  </entry>
  
  <entry>
    <title>eureka组件</title>
    <link href="http://yoursite.com/2020/06/09/eureka%E7%BB%84%E4%BB%B6/"/>
    <id>http://yoursite.com/2020/06/09/eureka%E7%BB%84%E4%BB%B6/</id>
    <published>2020-06-09T12:50:00.000Z</published>
    <updated>2020-06-13T15:17:20.004Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、EnableDiscoveryClient与EnableEurekaClient的区别"><a href="#一、EnableDiscoveryClient与EnableEurekaClient的区别" class="headerlink" title="一、EnableDiscoveryClient与EnableEurekaClient的区别"></a>一、EnableDiscoveryClient与EnableEurekaClient的区别</h2><p>Spring Cloud版本：Angle -&gt; Brixton -&gt; Camden -&gt; Dalston -&gt; Edgware -&gt; Finchley-&gt;Greenwich-&gt;Hoxton</p><blockquote><ol><li>Dalston或更早期的版本,为了启用服务注册发现功能。需要在主启动类上增加<code>@EnableDiscoveryClient</code>或者<code>@EnableEurekaClient</code>注解。</li><li><code>@EnableEurekaClient</code>内部使用了<code>@EnableDiscoveryClient</code>注解，因此如果要使用eureka的注册发现服务，两者功能是一样的。</li><li>EnableDiscoveryClient注解在spring.factories配置中通过配置项EurekaDiscoveryClientConfiguration来开启服务注册发现功能。</li></ol></blockquote><ul><li>@EnableDiscoveryClient注解是基于spring-cloud-commons依赖，并且在classpath中实现。</li><li>@EnableEurekaClient注解是基于spring-cloud-netflix依赖，只能为eureka作用。</li><li>@EnableEurekaClient只适用于Eureka作为注册中心，@EnableDiscoveryClient 可以是其他注册中心。</li></ul><h2 id="二、-EnableDiscoveryClient注解现在也没用了（Dalston之后的版本中（不含Dalston））"><a href="#二、-EnableDiscoveryClient注解现在也没用了（Dalston之后的版本中（不含Dalston））" class="headerlink" title="二、 @EnableDiscoveryClient注解现在也没用了（Dalston之后的版本中（不含Dalston））"></a>二、 @EnableDiscoveryClient注解现在也没用了（Dalston之后的版本中（不含Dalston））</h2><p>只要依赖了以spring-cloud-starter-netflix为前缀的库(例如spring-cloud-starter-netflix-eureka-client)，就启用了服务注册发现功能。</p><p>使用配置项<code>spring.cloud.service-registry.auto-registration.enabled=false</code>即可禁止服务注册发现功能。</p><p>spring容器在查询spring.factories的过程中，如果找到了EnableDiscoveryClient的配置，就会实例化该配置对应的服务注册发现：例如eureka、consul、zookeeper等。</p><p>打开工程spring-cloud-netflix-eureka-client.jar，去看src\main\resources\META-INF目录下的spring.factories文件，发现在springboot的自动配置项中，出现了一个关键配置EurekaDiscoveryClientConfiguration，如下：</p><pre><code class="hljs yaml"><span class="hljs-string">org.springframework.boot.autoconfigure.EnableAutoConfiguration=\</span><span class="hljs-string">org.springframework.cloud.netflix.eureka.config.EurekaClientConfigServerAutoConfiguration,\</span><span class="hljs-string">org.springframework.cloud.netflix.eureka.config.DiscoveryClientOptionalArgsConfiguration,\</span><span class="hljs-string">org.springframework.cloud.netflix.eureka.EurekaClientAutoConfiguration,\</span><span class="hljs-string">org.springframework.cloud.netflix.ribbon.eureka.RibbonEurekaAutoConfiguration,\</span><span class="hljs-string">org.springframework.cloud.netflix.eureka.EurekaDiscoveryClientConfiguration,\</span><span class="hljs-string">org.springframework.cloud.netflix.eureka.reactive.EurekaReactiveDiscoveryClientConfiguration,\</span><span class="hljs-string">org.springframework.cloud.netflix.eureka.loadbalancer.LoadBalancerEurekaAutoConfiguration</span><span class="hljs-string">org.springframework.cloud.bootstrap.BootstrapConfiguration=\</span><span class="hljs-string">org.springframework.cloud.netflix.eureka.config.EurekaConfigServerBootstrapConfiguration</span></code></pre><blockquote><ol><li><p>在spring.factories配置中，配置类EurekaDiscoveryClientConfiguration被配置到springboot的自动配置注解中，与EnableDiscoveryClient注解没有关系了,也就是说只要开启了springboot的自动配置，服务注册发现功能就会启用。</p></li><li><p>EnableEurekaClient源码中没有使用注解EnableDiscoveryClient，此时EnableEurekaClient已经没用了。</p></li></ol></blockquote><h2 id="三、Eureka两个组件：Eureka-Server和Eureka-Client。"><a href="#三、Eureka两个组件：Eureka-Server和Eureka-Client。" class="headerlink" title="三、Eureka两个组件：Eureka Server和Eureka Client。"></a>三、Eureka两个组件：Eureka Server和Eureka Client。</h2><p><strong>Eureka Server</strong></p><ul><li>Eureka Server 提供服务发现能力，各个微服务启动时，会向Eureka Server注册自己的信息（例如IP、端口、微服务名称等），Eureka Server会存储这些信息。</li><li>Eureka Server作为一个独立的部署单元，以REST API的形式为服务实例提供了注册、管理和查询等操作。同时，Eureka Server也为我们提供了可视化的监控页面，可以直观地看到各个Eureka Server当前的运行状态和所有已注册服务的情况。</li></ul><p><strong>Eureka Client</strong></p><ul><li><p>Erueka Client是一个java客户端，用于简化与Eureka的交互。</p></li><li><p>微服务启动后，会周期性（默认30s）地向Eureka Server发送心跳以续约自己的“ 租期 ”。</p></li><li><p>如果Eureka server在一定的时间内没有接收到某个微服务实例的心跳，Eureka Server将注销该实例（默认90s）。</p></li><li><p>默认情况下，Eureka Server同时也是Eureka Client。 多个Eureka Server 实例互相之间通过复制的方式来实现服务注册表中数据的同步。</p></li><li><p>Eureka Client 会缓存服务注册表中的信息，这种方式有一定的优势——首先，无须每次请求都查询Eureka Server，从而降低了Eureka Server的压力；其次，即使Eureka Server所有节点都宕掉，服务消费者依然可以使用缓存中的信息找到服务提供者并完成调用。 综上，Eureka通过心跳检查、客户端缓存等机制，提高了系统的灵活性、可伸缩性和可用性。</p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;一、EnableDiscoveryClient与EnableEurekaClient的区别&quot;&gt;&lt;a href=&quot;#一、EnableDiscoveryClient与EnableEurekaClient的区别&quot; class=&quot;headerlink&quot; title=&quot;一、
      
    
    </summary>
    
    
      <category term="springCloud" scheme="http://yoursite.com/categories/springCloud/"/>
    
    
      <category term="eureka" scheme="http://yoursite.com/tags/eureka/"/>
    
  </entry>
  
  <entry>
    <title>RestTemplate使用</title>
    <link href="http://yoursite.com/2020/06/08/RestTemplate%E4%BD%BF%E7%94%A8/"/>
    <id>http://yoursite.com/2020/06/08/RestTemplate%E4%BD%BF%E7%94%A8/</id>
    <published>2020-06-08T13:05:44.000Z</published>
    <updated>2020-06-08T13:57:05.423Z</updated>
    
    <content type="html"><![CDATA[<h1 id="restTemplate详解"><a href="#restTemplate详解" class="headerlink" title="restTemplate详解"></a>restTemplate详解</h1><ul><li>该对象会使用ribbon的自动化配置，同时通过@LoadBalanced注解修饰还能开启客户端负载均衡</li></ul><h2 id="一、GET请求"><a href="#一、GET请求" class="headerlink" title="一、GET请求"></a>一、GET请求</h2><h3 id="1-1-getForEntity"><a href="#1-1-getForEntity" class="headerlink" title="1.1 getForEntity"></a>1.1 getForEntity</h3><ul><li>该方法返回的是ResponseEntity，是spring对HTTP响应的封装。</li></ul><blockquote><p>主要存储了HTTP的几个重要元素，如HttpStatus状态码。在HttpEntity中还存储着HttpHeaders以及范型类型的请求体对象。</p></blockquote><p><strong>三种常见的重载方式</strong></p><pre><code class="hljs java">getForEntity(String url, Class&lt;T&gt; responseType, Object... uriVariables) <span class="hljs-comment">// 如 restTemplate.getForEntity("http://MYCLOUD-PROVIDER/user?name=&#123;1&#125;", String.class, "orange");</span></code></pre><ul><li>url中使用占位符的方式进行参数绑定。</li><li>第二个参数为返回值的包装类型。</li></ul><hr><pre><code class="hljs java">RestTemplate restTemplate = <span class="hljs-keyword">new</span> RestTemplate();Map&lt;String, String&gt; params = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();params.put(<span class="hljs-string">"key"</span>, <span class="hljs-string">"orange"</span>);restTemplate.getForEntity(<span class="hljs-string">"http://MYCLOUD-PROVIDER/user?name=&#123;key&#125;"</span>, String<span class="hljs-class">.<span class="hljs-keyword">class</span>, <span class="hljs-title">params</span>)</span>;</code></pre><ul><li>参数绑定的方式稍有不同。</li></ul><hr><pre><code class="hljs java">RestTemplate restTemplate = <span class="hljs-keyword">new</span> RestTemplate();UriComponents uriComponents = UriComponentsBuilder  .fromUriString(<span class="hljs-string">"http://MYCLOUD-PROVIDER/user?name=&#123;key&#125;"</span>)  .build()  .expand(<span class="hljs-string">"orange"</span>)  .encode();URI uri = uriComponents.toUri();ResponseEntity&lt;String&gt; forEntity = restTemplate.getForEntity(uri, String<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;</code></pre><h3 id="1-2-getForObject"><a href="#1-2-getForObject" class="headerlink" title="1.2 getForObject"></a>1.2 getForObject</h3><ul><li>请求方式基本同getForEntity，可以理解是对其的进一步封装。</li><li>它通过HttpMessageConverterExtractor对body进行转换，实现请求直接返回包装好的对象内容。</li></ul><pre><code class="hljs java">restTemplate.getForObject(url, Orange<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;</code></pre><ul><li>当body是一个Orange对象时，可直接包装。</li></ul><blockquote><p>当不需要关注响应body之外的内容时，建议使用该方式，可以少一个从response中获取body的步骤。</p></blockquote><h2 id="二、POST请求"><a href="#二、POST请求" class="headerlink" title="二、POST请求"></a>二、POST请求</h2><pre><code class="hljs java">postForEntity(String url, <span class="hljs-meta">@Nullable</span> Object request, Class&lt;T&gt; responseType, Object... uriVariables)</code></pre><ul><li>基本用法与get类似，这里需要注意的是新增加的request参数。</li><li>request可以是一个普通对象，也可以是一个HttpEntity对象。</li><li>request普通对象会被隐式转换成HttpEntity对象。</li><li>这个request不仅包含了body内容，还包含了header内容。</li><li>第四个参数uriVariables用于对url中参数绑定。</li></ul><h2 id="三、PUT请求"><a href="#三、PUT请求" class="headerlink" title="三、PUT请求"></a>三、PUT请求</h2><pre><code class="hljs java">put(String url, <span class="hljs-meta">@Nullable</span> Object request, Object... uriVariables)</code></pre><h2 id="四、DELETE请求"><a href="#四、DELETE请求" class="headerlink" title="四、DELETE请求"></a>四、DELETE请求</h2><pre><code class="hljs java">delete(String url, Object... uriVariables)</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;restTemplate详解&quot;&gt;&lt;a href=&quot;#restTemplate详解&quot; class=&quot;headerlink&quot; title=&quot;restTemplate详解&quot;&gt;&lt;/a&gt;restTemplate详解&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;该对象会使用ribbon的自动化
      
    
    </summary>
    
    
      <category term="springCloud" scheme="http://yoursite.com/categories/springCloud/"/>
    
    
      <category term="restTemplate" scheme="http://yoursite.com/tags/restTemplate/"/>
    
  </entry>
  
  <entry>
    <title>ribbon使用</title>
    <link href="http://yoursite.com/2020/06/08/ribbon%E4%BD%BF%E7%94%A8/"/>
    <id>http://yoursite.com/2020/06/08/ribbon%E4%BD%BF%E7%94%A8/</id>
    <published>2020-06-08T12:17:27.000Z</published>
    <updated>2020-06-14T14:50:00.572Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、什么是ribbon"><a href="#一、什么是ribbon" class="headerlink" title="一、什么是ribbon"></a>一、什么是ribbon</h2><ul><li>Spring cloud ribbon是一个基于HTTP和TCP的客户端负载均衡工具，它基于netflix ribbon实现。</li><li>将面向服务的rest模版请求自动转换成客户端负载均衡的服务调用。</li><li>是一个工具类框架，例如API网关的请求转发、Feign的底层都是基于ribbon的。</li></ul><h2 id="二、客户端负载均衡"><a href="#二、客户端负载均衡" class="headerlink" title="二、客户端负载均衡"></a>二、客户端负载均衡</h2><h3 id="1、基础理论"><a href="#1、基础理论" class="headerlink" title="1、基础理论"></a>1、基础理论</h3><ul><li>负载均衡是系统高可用、缓解网络压力、处理能力扩容的重要手段之一。</li></ul><h4 id="1-1-服务端负载均衡"><a href="#1-1-服务端负载均衡" class="headerlink" title="1.1 服务端负载均衡"></a>1.1 服务端负载均衡</h4><ul><li>我们通常所说的负载均衡都是服务端负载均衡，硬件层面如F5，软件层面如nginx。</li><li>硬件负载均衡的设备或者软件负载均衡的软件，都会维护一个可用的服务清单，并通过心跳的方式来剔除故障的服务端节点。</li><li>当客户端发送请求到负载均衡设备时，该设备按照一定算法（轮询、权重、流量等）从服务端清单中取出一个地址，然后转发请求。</li></ul><h4 id="1-2-客户端负载均衡"><a href="#1-2-客户端负载均衡" class="headerlink" title="1.2 客户端负载均衡"></a>1.2 客户端负载均衡</h4><ul><li>在客户端负载均衡中，所有的客户端节点都维护着自己的服务端清单，并通过心跳维护清单的健康性。</li><li>即客户端负载和服务端负载最大的不同点在于清单所储存的位置。</li></ul><h3 id="2、使用方式"><a href="#2、使用方式" class="headerlink" title="2、使用方式"></a>2、使用方式</h3><ul><li>服务提供者启动多个实例并注册到一个或多个相关联的注册中心</li><li>服务消费者直接调用被@LoadBalanced注解修饰的RestTemplate进行服务调用。</li></ul><p><strong>pom文件</strong>中需要引入关于Ribbon的包，同时consumer也是一个Eureka Client要去拉 Eureka Server的配置，所以需要Eureka client的包。</p><pre><code class="hljs java">&lt;dependency&gt;    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;    &lt;artifactId&gt;spring-cloud-starter-netflix-ribbon&lt;/artifactId&gt;    &lt;version&gt;2.2.3.RELEASE&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt;    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;    &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt;    &lt;version&gt;2.2.3.RELEASE&lt;/version&gt;&lt;/dependency&gt;</code></pre><p>java中配置<strong>负载均衡策略</strong>和<strong>@LoadBalanced</strong>修饰的<strong>RestTemplate</strong></p><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RestTemplateConfig</span> </span>&#123;  <span class="hljs-comment">// 负载均衡策略，定义了一个随机方式的服务调用方式，即随即调用某个服务的提供者</span>  <span class="hljs-meta">@Bean</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> IRule <span class="hljs-title">ribbonRule</span><span class="hljs-params">()</span></span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> RandomRule();    &#125;<span class="hljs-comment">// 定义一个负载均衡的 RestTemplate，该注解配合负载均衡策略一起使用， RestTemplate 发出的请求才能生效。</span>    <span class="hljs-meta">@Bean</span>    <span class="hljs-meta">@LoadBalanced</span>    <span class="hljs-function">RestTemplate <span class="hljs-title">restTemplate</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> RestTemplate();    &#125;&#125;</code></pre><p>接下来就可以进行调用了</p><pre><code class="hljs java"><span class="hljs-comment">// 根据服务名去访问，需要将restTemplate注解为@LoadBalanced才会生效</span><span class="hljs-keyword">private</span> String service = <span class="hljs-string">"http://MYCLOUD-PROVIDER"</span>;<span class="hljs-meta">@RequestMapping</span>(<span class="hljs-string">"/consumer/corps/&#123;id&#125;"</span>)<span class="hljs-function">Corp <span class="hljs-title">getCorp</span><span class="hljs-params">(@PathVariable(<span class="hljs-string">"id"</span>)</span> String id) </span>&#123;String url = service + <span class="hljs-string">"/corps/"</span> + id;<span class="hljs-keyword">return</span> restTemplate.getForObject(url, Corp<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;&#125;</code></pre><h2 id="3、自动装配方式解读"><a href="#3、自动装配方式解读" class="headerlink" title="3、自动装配方式解读"></a>3、自动装配方式解读</h2><p>在springCloud实现的服务治理框架中，默认对ribbon自动化整合配置。如eureka中<code>spring.factories</code>:</p><pre><code class="hljs yaml"><span class="hljs-string">org.springframework.boot.autoconfigure.EnableAutoConfiguration=\</span><span class="hljs-string">···</span><span class="hljs-string">org.springframework.cloud.netflix.eureka.EurekaClientAutoConfiguration,\</span><span class="hljs-comment"># 自动整合ribbon相关配置，通过这个类来了解它的配置详情</span><span class="hljs-string">org.springframework.cloud.netflix.ribbon.eureka.RibbonEurekaAutoConfiguration,\</span><span class="hljs-string">org.springframework.cloud.netflix.eureka.EurekaDiscoveryClientConfiguration,\</span><span class="hljs-string">···</span></code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;一、什么是ribbon&quot;&gt;&lt;a href=&quot;#一、什么是ribbon&quot; class=&quot;headerlink&quot; title=&quot;一、什么是ribbon&quot;&gt;&lt;/a&gt;一、什么是ribbon&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;Spring cloud ribbon是一个基于HTTP
      
    
    </summary>
    
    
      <category term="springCloud" scheme="http://yoursite.com/categories/springCloud/"/>
    
    
      <category term="ribbon" scheme="http://yoursite.com/tags/ribbon/"/>
    
  </entry>
  
  <entry>
    <title>eureka使用</title>
    <link href="http://yoursite.com/2020/06/07/eureka%E4%BD%BF%E7%94%A8/"/>
    <id>http://yoursite.com/2020/06/07/eureka%E4%BD%BF%E7%94%A8/</id>
    <published>2020-06-07T15:20:49.000Z</published>
    <updated>2020-06-09T15:29:48.178Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、eureka是什么"><a href="#一、eureka是什么" class="headerlink" title="一、eureka是什么"></a>一、eureka是什么</h2><ul><li>服务治理可以说是微服务架构中核心的模块，它主要用来实现各个微服务实例之间的自动化注册与发现。</li></ul><p><strong>1、服务注册：</strong></p><p>每个服务单元将自己的主机号、版本号、通信协议等告知注册中心，注册中心维护服务清单，并通过心跳的方式监测清单中的服务是否可用，并剔除不可用的服务。</p><p><strong>2、服务发现：</strong></p><p>各服务单元通过服务名进行相互调用。</p><p><strong>3、eureka服务端：</strong></p><p>即服务注册中心，提供服务治理，即服务注册与发现的功能。</p><blockquote><p>若eureka以集群方式部署，当集群中有分片出现故障时，eureka进入自我保护模式。它允许再分片故障期间继续提供服务注册与发现，等故障恢复后，其他分片会把它们的状态再次同步回来。</p></blockquote><blockquote><p>不同服务端通过异步的方式相互复制各自的状态，这意味着在任意时间点，每个实例关于所有服务的状态是有细微差异的。也就是我们通常所说的AP原则。</p></blockquote><p><strong>4、eureka客户端</strong></p><p>向注册中心注册自身提供的服务，并周期性的发送心跳来更新服务租约。</p><p>将服务端已注册的服务信息缓存到本地，并周期性的刷新。</p><h2 id="二、单机配置方式"><a href="#二、单机配置方式" class="headerlink" title="二、单机配置方式"></a>二、单机配置方式</h2><h3 id="1、服务端"><a href="#1、服务端" class="headerlink" title="1、服务端"></a>1、服务端</h3><h4 id="1）pom中引入："><a href="#1）pom中引入：" class="headerlink" title="1）pom中引入："></a>1）pom中引入：</h4><pre><code class="hljs java">&lt;dependencies&gt;  &lt;dependency&gt;  &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;  &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-server&lt;/artifactId&gt;  &lt;version&gt;2.2.3.RELEASE&lt;/version&gt;  &lt;/dependency&gt;&lt;/dependencies&gt;</code></pre><h4 id="2）配置文件："><a href="#2）配置文件：" class="headerlink" title="2）配置文件："></a>2）配置文件：</h4><pre><code class="hljs yaml"><span class="hljs-attr">server:</span>  <span class="hljs-attr">port:</span> <span class="hljs-number">8003</span><span class="hljs-attr">eureka:</span>  <span class="hljs-attr">instance:</span>    <span class="hljs-attr">hostname:</span> <span class="hljs-string">localhost</span> <span class="hljs-comment"># eureka服务端的实例名字</span>  <span class="hljs-attr">client:</span>    <span class="hljs-attr">service-url:</span>      <span class="hljs-attr">defaultZone:</span> <span class="hljs-string">http://$&#123;eureka.instance.hostname&#125;:$&#123;server.port&#125;/eureka/</span>    <span class="hljs-attr">register-with-eureka:</span> <span class="hljs-literal">false</span> <span class="hljs-comment"># 是否向注册中心注册自己，默认true，server应设置为false</span>    <span class="hljs-attr">fetch-registry:</span> <span class="hljs-literal">false</span> <span class="hljs-comment"># 服务端本身就是维护服务实例的，所以并不需要去检索服务，默认true，server应设置为false</span></code></pre><h4 id="3）启动类"><a href="#3）启动类" class="headerlink" title="3）启动类:"></a>3）启动类:</h4><pre><code class="hljs java"><span class="hljs-meta">@SpringBootApplication</span><span class="hljs-meta">@EnableEurekaServer</span> <span class="hljs-comment">//开启Eureka服务端，接受其它微服务注册进来</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">EurekaServer8003</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        SpringApplication.run(EurekaServer8003<span class="hljs-class">.<span class="hljs-keyword">class</span>, <span class="hljs-title">args</span>)</span>;    &#125;&#125;</code></pre><h3 id="2、客户端"><a href="#2、客户端" class="headerlink" title="2、客户端"></a>2、客户端</h3><h4 id="1）pom中引入"><a href="#1）pom中引入" class="headerlink" title="1）pom中引入"></a>1）pom中引入</h4><pre><code class="hljs java">&lt;dependency&gt;&lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;&lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt;&lt;version&gt;2.2.3.RELEASE&lt;/version&gt;&lt;/dependency&gt;</code></pre><h4 id="2）配置文件"><a href="#2）配置文件" class="headerlink" title="2）配置文件"></a>2）配置文件</h4><pre><code class="hljs yaml"><span class="hljs-attr">spring:</span>  <span class="hljs-attr">application:</span>    <span class="hljs-attr">name:</span> <span class="hljs-string">mycloud-provider</span> <span class="hljs-comment"># eureka页面 application显示的名称。EurekaServer中服务名默认转成大写的。</span><span class="hljs-attr">eureka:</span>  <span class="hljs-attr">client:</span>    <span class="hljs-attr">service-url:</span>      <span class="hljs-attr">defaultZone:</span> <span class="hljs-string">http://localhost:8003/eureka/</span>  <span class="hljs-attr">instance:</span>    <span class="hljs-attr">instance-id:</span> <span class="hljs-string">$&#123;spring.application.name&#125;:$&#123;server.port&#125;</span> <span class="hljs-comment"># eureka页面status显示的内容</span></code></pre><h4 id="3）启动类-1"><a href="#3）启动类-1" class="headerlink" title="3）启动类"></a>3）启动类</h4><pre><code class="hljs java"><span class="hljs-meta">@SpringBootApplication</span><span class="hljs-comment">// 可不加该配置，Dalston之后的版本中（不含Dalston），只要开启了springboot的自动配置，服务注册发现功能就会启用</span><span class="hljs-comment">// 使用配置项`spring.cloud.service-registry.auto-registration.enabled=false`即可禁止服务注册发现功能。</span><span class="hljs-comment">// eureka.client.register-with-eureka: false 也可禁止服务注册功能。</span><span class="hljs-comment">// @EnableEurekaClient </span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CorpProvider8001</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        SpringApplication.run(CorpProvider8001<span class="hljs-class">.<span class="hljs-keyword">class</span>, <span class="hljs-title">args</span>)</span>;    &#125;&#125;</code></pre><blockquote><p>如果不想用主机名作为自定义注册中心的地址，也可以使用IP的形式。在配置文件中配置eureka.instance.prefer-ip-address=true，改值默认为false。</p></blockquote><h3 id="三、info信息完善"><a href="#三、info信息完善" class="headerlink" title="三、info信息完善"></a>三、info信息完善</h3><h4 id="1）引入依赖"><a href="#1）引入依赖" class="headerlink" title="1）引入依赖"></a>1）引入依赖</h4><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-actuator<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre><h4 id="2）yml中配置"><a href="#2）yml中配置" class="headerlink" title="2）yml中配置"></a>2）yml中配置</h4><pre><code class="hljs yaml"><span class="hljs-attr">info:</span> <span class="hljs-comment"># eureka页面status点击跳转监控页面 显示的内容</span>  <span class="hljs-attr">app.name:</span> <span class="hljs-string">$&#123;spring.application.name&#125;</span>  <span class="hljs-attr">company.name:</span> <span class="hljs-string">www.orange.com</span>  <span class="hljs-attr">build.artifactId:</span> <span class="hljs-string">mycloud-provider</span>  <span class="hljs-attr">build.version:</span> <span class="hljs-number">1.0</span></code></pre><h3 id="四、高可用集群配置方式"><a href="#四、高可用集群配置方式" class="headerlink" title="四、高可用集群配置方式"></a>四、高可用集群配置方式</h3><p>eureka server的高可用实际上就是将自己作为服务向其他注册中心注册自己。</p><h4 id="1）创建server1"><a href="#1）创建server1" class="headerlink" title="1）创建server1"></a>1）创建server1</h4><pre><code class="hljs yaml"><span class="hljs-attr">spring:</span>  <span class="hljs-attr">application:</span>    <span class="hljs-attr">name:</span> <span class="hljs-string">eureka-server</span><span class="hljs-attr">server:</span>  <span class="hljs-attr">port:</span> <span class="hljs-number">8003</span><span class="hljs-attr">eureka:</span>  <span class="hljs-attr">instance:</span>    <span class="hljs-attr">hostname:</span> <span class="hljs-string">server-1</span>  <span class="hljs-attr">client:</span>    <span class="hljs-attr">service-url:</span>      <span class="hljs-attr">defaultZone:</span> <span class="hljs-string">http://server-2:8004/eureka/</span></code></pre><h4 id="2-创建server2"><a href="#2-创建server2" class="headerlink" title="2) 创建server2"></a>2) 创建server2</h4><pre><code class="hljs yaml"><span class="hljs-attr">spring:</span>  <span class="hljs-attr">application:</span>    <span class="hljs-attr">name:</span> <span class="hljs-string">eureka-server</span><span class="hljs-attr">server:</span>  <span class="hljs-attr">port:</span> <span class="hljs-number">8004</span><span class="hljs-attr">eureka:</span>  <span class="hljs-attr">instance:</span>    <span class="hljs-attr">hostname:</span> <span class="hljs-string">server-2</span>  <span class="hljs-attr">client:</span>    <span class="hljs-attr">service-url:</span>      <span class="hljs-attr">defaultZone:</span> <span class="hljs-string">http://server-1:8003/eureka/</span></code></pre><h4 id="3）客户端配置"><a href="#3）客户端配置" class="headerlink" title="3）客户端配置"></a>3）客户端配置</h4><pre><code class="hljs yaml"><span class="hljs-attr">spring:</span>  <span class="hljs-attr">application:</span>    <span class="hljs-attr">name:</span> <span class="hljs-string">client</span><span class="hljs-attr">eureka:</span>  <span class="hljs-attr">client:</span>    <span class="hljs-attr">service-url:</span>      <span class="hljs-attr">defaultZone:</span> <span class="hljs-string">http://server-1:8003/eureka/,http://server-2:8004/eureka/</span> <span class="hljs-comment"># 分别向两个服务端注入</span></code></pre><h3 id="五、基础架构"><a href="#五、基础架构" class="headerlink" title="五、基础架构"></a>五、基础架构</h3><p>服务治理的3个核心要素：服务提供者、服务消费者、服务注册中心。</p><blockquote><p>很多时候，客户端既是服务提供者又是服务消费者</p></blockquote><h4 id="1）服务提供者"><a href="#1）服务提供者" class="headerlink" title="1）服务提供者"></a>1）服务提供者</h4><p><strong>服务注册：</strong></p><p>服务提供者在启动的时候，通过rest请求将自己注册到eureka server，同时附带一些元数据信息。eureka server将它储存在一个双层map中，第一层key是服务名，第二层key是实例名。</p><blockquote><p>在服务注册时，需确认一下eureka.client.register-with-eureka=true参数是否正确。改值默认为true，若设置为false将不会注册。</p></blockquote><p><strong>服务同步：</strong></p><p>服务提供者的服务信息可以通过注册中心集群中任意一个获取到。</p><p><strong>服务续约renew</strong></p><p>服务提供者维持一个心跳用来持续告诉eureka server，防止被server从服务列表清除。</p><pre><code class="hljs yaml"><span class="hljs-comment"># 续约任务的调用隔离时间，默认30s</span><span class="hljs-string">eureka.instance.lease-renewal-interval-in-seconds=30</span><span class="hljs-comment"># 服务失效时间，默认90s</span><span class="hljs-string">eureka.instance.lease-expiration-duration-in-seconds=30</span></code></pre><h4 id="2）服务消费者"><a href="#2）服务消费者" class="headerlink" title="2）服务消费者"></a>2）服务消费者</h4><p><strong>获取服务：</strong></p><p>客户端通过rest请求，访问获取服务列表，eureka server会维护一份只读的服务清单返回给客户端</p><pre><code class="hljs yaml"><span class="hljs-comment"># 是否需要获取服务列表，默认为true，客户端需要开启</span><span class="hljs-string">eureka.client.fetch-registry=true</span><span class="hljs-comment"># 缓存清单的更新时间，默认30s</span><span class="hljs-string">eureka.client.registry-fetch-interval-seconds=30</span></code></pre><p><strong>服务调用：</strong></p><p>服务消费者在获取到服务清单到，通过服务名根据一定的策略选择一个服务实例进行调用。</p><p><strong>服务下线：</strong></p><p>客户端正常关闭时，会触发一个rest请求给server，server接收到该请求后，将该服务状态置为下线DOWN，并把该下线事件传播出去。</p><h4 id="3）服务注册中心"><a href="#3）服务注册中心" class="headerlink" title="3）服务注册中心"></a>3）服务注册中心</h4><p><strong>失效剔除：</strong></p><p>server在启动的时候会创建一个定时任务，默认每隔60s将服务清单中超时（默认90s）没有续约的服务剔除。</p><p><strong>自我保护：</strong></p><p>默认在15分钟内，若心跳失败的比例低于85%，server会将当前的服务实例清单保护起来，让这些实例不会过期。但是假设保护期内服务异常，客户端拿到失效的实例，就会出现调用失败的情况，所以客户端需要有容错机制。如请求重试、断路器机制。</p><pre><code class="hljs ini"><span class="hljs-comment"># 关闭保护机制</span><span class="hljs-attr">eureka.server.enable-self-preservation</span>=<span class="hljs-literal">false</span></code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;一、eureka是什么&quot;&gt;&lt;a href=&quot;#一、eureka是什么&quot; class=&quot;headerlink&quot; title=&quot;一、eureka是什么&quot;&gt;&lt;/a&gt;一、eureka是什么&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;服务治理可以说是微服务架构中核心的模块，它主要用来实现各
      
    
    </summary>
    
    
      <category term="springCloud" scheme="http://yoursite.com/categories/springCloud/"/>
    
    
      <category term="eureka" scheme="http://yoursite.com/tags/eureka/"/>
    
  </entry>
  
  <entry>
    <title>【并发】3大JUC工具类</title>
    <link href="http://yoursite.com/2020/06/07/%E3%80%90%E5%B9%B6%E5%8F%91%E3%80%913%E5%A4%A7JUC%E5%B7%A5%E5%85%B7%E7%B1%BB/"/>
    <id>http://yoursite.com/2020/06/07/%E3%80%90%E5%B9%B6%E5%8F%91%E3%80%913%E5%A4%A7JUC%E5%B7%A5%E5%85%B7%E7%B1%BB/</id>
    <published>2020-06-07T07:40:08.000Z</published>
    <updated>2020-06-07T10:33:45.445Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、减法计数器countDownLatch"><a href="#一、减法计数器countDownLatch" class="headerlink" title="一、减法计数器countDownLatch"></a>一、减法计数器countDownLatch</h2><p>CountDownLatch用于监听某些初始化操作，等待初始化执行完毕，通知主线程继续工作，允许一个或者多个线程等待其他线程完成操作。</p><p>通俗的讲就是<strong>实现线程等待</strong>，主线程<code>countDown.await();</code>进行阻塞，其他线程<code>countDown.countDown();</code>进行计数器-1操作，当计数器归零后，主线程唤醒继续操作。</p><blockquote><p> 要实现线程等待还有一个方法就是jion方法。Join用于让当前执行线程等待“Join线程”执行结束，实现原理是，不停的检查Join线程是否存活，如果存活则让当前线程永远等待下去，如果Join线程终止，则调用this.notifyAll方法唤醒等待的线程。</p></blockquote><blockquote><p>CountDownLatch其实也是来做这件事的，而且比Join更强大，使用起来也很轻便。</p></blockquote><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyCountDownLatch</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        CountDownLatch countDownLatch = <span class="hljs-keyword">new</span> CountDownLatch(<span class="hljs-number">2</span>);<span class="hljs-comment">// 线程a在执行后，经过await进行阻塞，当其他线程将countDownLatch减为0后，a继续执行</span>        <span class="hljs-keyword">new</span> Thread(()-&gt;&#123;            System.out.println(Thread.currentThread().getName() + <span class="hljs-string">"开始执行"</span>);            <span class="hljs-keyword">try</span> &#123;                countDownLatch.await();            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;                e.printStackTrace();            &#125;            System.out.println(Thread.currentThread().getName() + <span class="hljs-string">"执行完成"</span>);        &#125;, <span class="hljs-string">"a"</span>).start();        <span class="hljs-keyword">new</span> Thread(()-&gt;&#123;            System.out.println(Thread.currentThread().getName() + <span class="hljs-string">"开始执行"</span>);            countDownLatch.countDown();            System.out.println(Thread.currentThread().getName() + <span class="hljs-string">"执行完成"</span>);        &#125;, <span class="hljs-string">"b"</span>).start();        <span class="hljs-keyword">new</span> Thread(()-&gt;&#123;            System.out.println(Thread.currentThread().getName() + <span class="hljs-string">"开始执行"</span>);            countDownLatch.countDown();            System.out.println(Thread.currentThread().getName() + <span class="hljs-string">"执行完成"</span>);        &#125;, <span class="hljs-string">"c"</span>).start();    &#125;&#125;</code></pre><blockquote><p>CountDownLatch是通过一个计数器来实现的，当我们在new 一个CountDownLatch对象的时候需要带入该计数器值，该值就表示了线程的数量。每当一个线程完成自己的任务后，计数器的值就会减1。当计数器的值变为0时，就表示所有的线程均已经完成了任务，然后就可以恢复等待的线程继续执行了。</p></blockquote><h2 id="二、加法计数器Cyclicbarrier"><a href="#二、加法计数器Cyclicbarrier" class="headerlink" title="二、加法计数器Cyclicbarrier"></a>二、加法计数器Cyclicbarrier</h2><p>Cyclicbarrier指的是可循环使用的屏障，主要是让一组线程到达一个屏障之后被阻塞，当最后一个线程到达时，屏障才会开门，所有被屏障拦截的线程才会继续干活。</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyCyclicBarrier</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<span class="hljs-comment">//        CyclicBarrier cyclicBarrier = new CyclicBarrier(5);</span>        <span class="hljs-comment">// 线程都ready后，会先执行该 barrierAction ，再执行各子线程的下一步任务</span>        CyclicBarrier cyclicBarrier = <span class="hljs-keyword">new</span> CyclicBarrier(<span class="hljs-number">5</span>, ()-&gt; System.out.println(<span class="hljs-string">"all is ready"</span>));        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++) &#123;            <span class="hljs-keyword">new</span> Thread(()-&gt;&#123;                System.out.println(Thread.currentThread().getName()+<span class="hljs-string">" is ready"</span>);<span class="hljs-comment">//                int numberWaiting = cyclicBarrier.getNumberWaiting();</span>                <span class="hljs-keyword">try</span> &#123;                    cyclicBarrier.await();                &#125; <span class="hljs-keyword">catch</span> (InterruptedException | BrokenBarrierException e) &#123;                    e.printStackTrace();                &#125;                System.out.println(Thread.currentThread().getName()+<span class="hljs-string">" is going"</span>);            &#125;, <span class="hljs-string">"线程"</span>+i).start();        &#125;        System.out.println(<span class="hljs-string">"this is main"</span>);    &#125;&#125;</code></pre><h3 id="1、区别"><a href="#1、区别" class="headerlink" title="1、区别"></a>1、区别</h3><ul><li>CountDownLatch的计数器只能使用一次。而CyclicBarrier的计数器可以使用reset() 方法重置。</li><li>CountDownLatch的作用是允许1或N个线程等待其他线程完成执行；而CyclicBarrier则是允许N个线程相互等待。</li><li>CountDownLatch的计数器无法被重置；CyclicBarrier的计数器可以被重置后使用，因此它被称为是循环的barrier。</li></ul><h3 id="2、使用场景"><a href="#2、使用场景" class="headerlink" title="2、使用场景"></a>2、使用场景</h3><ul><li>确保某个计算在其需要的所有的资源都被初始化之后才继续执行。</li><li>确保某个服务在其依赖的所有其他服务都已经启动之后才启动。</li><li>等待直到某个操作所有参与者都准备就绪再继续执行。</li></ul><p><a href="https://www.javazhiyin.com/14737.html" target="_blank" rel="noopener">J.U.C之并发工具类：CyclicBarrier</a></p><p><a href="https://www.javazhiyin.com/14681.html" target="_blank" rel="noopener">J.U.C之并发工具类：CountDownLatch</a></p><h2 id="三、信号量semaphore"><a href="#三、信号量semaphore" class="headerlink" title="三、信号量semaphore"></a>三、信号量semaphore</h2><ul><li>信号量维护了一个许可集，线程通过acquire()获得许可，在达到许可上限时，会阻塞其他acquire()的线程。已获得许可的线程进行 release() 后，被阻塞的线程才可获得许可。</li><li>信号量，一般用于限流，或者限制访问某些资源的线程数目。</li><li>Semaphore默认选择非公平锁。可通过构造函数传入true，声明为公平锁。</li><li>当信号量Semaphore = 1 时，它可以当作互斥锁使用。其中0、1就相当于它的状态，当=1时表示其他线程可以获取，当=0时，排他，即其他线程必须要等待。</li></ul><pre><code class="hljs livescript">public <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MySemaphore</span> &#123;</span>    public static <span class="hljs-literal">void</span> main(String[] args) &#123;        Semaphore semaphore = <span class="hljs-keyword">new</span> Semaphore(<span class="hljs-number">3</span>);        <span class="hljs-keyword">for</span> (int i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;            <span class="hljs-keyword">new</span> Thread<span class="hljs-function"><span class="hljs-params">(()-&gt;&#123;</span></span><span class="hljs-function"><span class="hljs-params">                <span class="hljs-keyword">try</span> &#123;</span></span><span class="hljs-function"><span class="hljs-params">                    semaphore.acquire();</span></span><span class="hljs-function"><span class="hljs-params">                    System.out.println(Thread.currentThread().getName()+<span class="hljs-string">"进行占位"</span>);</span></span><span class="hljs-function"><span class="hljs-params">                    TimeUnit.SECONDS.sleep(<span class="hljs-number">1</span>);</span></span><span class="hljs-function"><span class="hljs-params">                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;</span></span><span class="hljs-function"><span class="hljs-params">                    e.printStackTrace();</span></span><span class="hljs-function"><span class="hljs-params">                &#125; <span class="hljs-keyword">finally</span> &#123;</span></span><span class="hljs-function"><span class="hljs-params">                    semaphore.release();</span></span><span class="hljs-function"><span class="hljs-params">                    System.out.println(Thread.currentThread().getName()+<span class="hljs-string">"释放位置"</span>);</span></span><span class="hljs-function"><span class="hljs-params">                &#125;</span></span><span class="hljs-function"><span class="hljs-params">            &#125;, <span class="hljs-string">"thread-"</span>+i)</span>.<span class="hljs-title">start</span><span class="hljs-params">()</span>;</span><span class="hljs-function">        &#125;</span><span class="hljs-function"></span><span class="hljs-function">    &#125;</span><span class="hljs-function">&#125;</span></code></pre><p><a href="https://www.javazhiyin.com/14648.html" target="_blank" rel="noopener">J.U.C之并发工具类：Semaphore</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;一、减法计数器countDownLatch&quot;&gt;&lt;a href=&quot;#一、减法计数器countDownLatch&quot; class=&quot;headerlink&quot; title=&quot;一、减法计数器countDownLatch&quot;&gt;&lt;/a&gt;一、减法计数器countDownLatch&lt;/
      
    
    </summary>
    
    
      <category term="java" scheme="http://yoursite.com/categories/java/"/>
    
    
      <category term="thread" scheme="http://yoursite.com/tags/thread/"/>
    
  </entry>
  
  <entry>
    <title>【并发】阻塞队列（BlockingQueue）</title>
    <link href="http://yoursite.com/2020/06/07/%E3%80%90%E5%B9%B6%E5%8F%91%E3%80%91%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97/"/>
    <id>http://yoursite.com/2020/06/07/%E3%80%90%E5%B9%B6%E5%8F%91%E3%80%91%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97/</id>
    <published>2020-06-07T01:43:26.000Z</published>
    <updated>2020-06-07T07:41:03.947Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、什么是阻塞队列"><a href="#一、什么是阻塞队列" class="headerlink" title="一、什么是阻塞队列"></a>一、什么是阻塞队列</h2><p>阻塞队列是一种特殊的支持阻塞的插入和移除的特殊容器。</p><p>阻塞插入：</p><ul><li>当队列满时，向队列中插入元素的线程会被阻塞，直到队列中有元素被移除。</li><li>即队列不满时，才能插入元素，否则阻塞。</li></ul><p>阻塞移除：</p><ul><li>当队列为空时，从队列中移除数据的线程会被阻塞，直到队列中有新的元素被添加。</li><li>即队列不为空时，才能取出元素，否则阻塞。</li></ul><h2 id="二、常见方法"><a href="#二、常见方法" class="headerlink" title="二、常见方法"></a>二、常见方法</h2><table><thead><tr><th>方法</th><th>备注</th></tr></thead><tbody><tr><td>add/remove</td><td>增删元素，失败抛出异常</td></tr><tr><td>offer/poll</td><td>增删元素，可设置等待时间，失败或超时返回false</td></tr><tr><td>put/take</td><td>增删元素，一直等待</td></tr></tbody></table><h2 id="三、常见阻塞队列"><a href="#三、常见阻塞队列" class="headerlink" title="三、常见阻塞队列"></a>三、常见阻塞队列</h2><p><code>BlockingQueue</code>是一个接口，主要有下面7种实现类：</p><table><thead><tr><th>实现</th><th>备注</th></tr></thead><tbody><tr><td>ArrayBlockingQueue</td><td>基于数组的阻塞队列实现，在其内部，维护了一个定长数组，以便缓存队列中的数据对象；<br>其内部没实现读写分离，也就意味着生产和消费不能完全并行；<br>长度是需要自己定义的，可以指定先进先出或者先进后出，也被称为“有界队列”</td></tr><tr><td>LinkedBlockingQueue</td><td>基于链表的阻塞队列，其内部维持着一个数据缓冲队列（该队列由一个链表构成）；<br>LinkedBlockingQueue之所以能够高效的处理并发数据，是因为其内部实现采用分离锁（读写分离两个锁），从而实现生产者和消费者操作完全并发执行，也是一个“无界队列”</td></tr><tr><td>PriorityBlockingQueue</td><td>基于优先级的阻塞队列（优先级的判断通过构造函数传入的Compator（比较器）对象决定，也就是说传入队列的对象必须实现Comparable接口），<br>在实现PriorityBlockingQueue时，内部控制线程同步的锁采用的是公平锁，是一个“无界队列”<br>PriorityBlockingQueue调用take后需要重新排序，调一次重新排一次</td></tr><tr><td>DelayQueue</td><td>带有延迟时间的无界阻塞Queue，其中的元素只有当指定的延迟时间到了，才能够从队列中获取该元素。<br>DelayQueue中的元素必须实现Delayed接口，DelayQueue是一个没有大小限制的队列，<br>应用场景比较多，比如对缓存超时的数据进行移除，任务超时处理，空间连接的关闭等等</td></tr><tr><td>SynchronousQueue</td><td>不存储任何元素的队列，生产者产生的数据直接会被消费者获取并消费，<br>即每一个put操作必须等待一个take操作，否则不能继续添加元素，<br>或者可以理解为是只能存储一个元素的队列，存一个就满了，该元素必须被移除掉，才能继续添加</td></tr><tr><td>LinkedTransferQueue</td><td>一个由链表结构组成的无界阻塞传输队列，主要体现在LinkedTransferQueue多2个方法<br>transfer(E)：如果当前有消费者正在等待消费，则生产者直接把元素传输给消费者，如果当前没有消费者正在等待消费，则生产者将元素存放在队列的tail节点上，并等到该元素被消费才返回（采用自旋等待）；<br>tryTransfer(E,long,TimeUnit)：将元素立刻给消费者，如果没有消费者就等待指定时间。时间到时，如果还没有消费者则失败返回false；</td></tr><tr><td>LinkedBlockingDeque</td><td>由链表结构组成的双向阻塞队列，即可以从队列的两端插入和移出元素</td></tr></tbody></table><h2 id="四、阻塞队列的底层实现"><a href="#四、阻塞队列的底层实现" class="headerlink" title="四、阻塞队列的底层实现"></a>四、阻塞队列的底层实现</h2><p>阻塞队列的底层是<strong>等待通知机制</strong>来实现的：</p><p>当生产者往一个满队列中添加元素时，生产者会被阻塞；等消费者从该队列中消费了一个元素后，会通知阻塞的插入操作的生产者线程，可以继续执行添加操作。</p><p>当消费者从一个空队列中移除元素时，消费者会被阻塞；等生产者向队列中增加了一个元素后，会通知阻塞的移除操作的消费者线程，可以继续执行移除操作。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;一、什么是阻塞队列&quot;&gt;&lt;a href=&quot;#一、什么是阻塞队列&quot; class=&quot;headerlink&quot; title=&quot;一、什么是阻塞队列&quot;&gt;&lt;/a&gt;一、什么是阻塞队列&lt;/h2&gt;&lt;p&gt;阻塞队列是一种特殊的支持阻塞的插入和移除的特殊容器。&lt;/p&gt;
&lt;p&gt;阻塞插入：&lt;/p
      
    
    </summary>
    
    
      <category term="java" scheme="http://yoursite.com/categories/java/"/>
    
    
      <category term="thread blockingQueue" scheme="http://yoursite.com/tags/thread-blockingQueue/"/>
    
  </entry>
  
  <entry>
    <title>【并发】生产者消费者</title>
    <link href="http://yoursite.com/2020/06/05/%E3%80%90%E5%B9%B6%E5%8F%91%E3%80%91%E7%94%9F%E4%BA%A7%E8%80%85%E6%B6%88%E8%B4%B9%E8%80%85/"/>
    <id>http://yoursite.com/2020/06/05/%E3%80%90%E5%B9%B6%E5%8F%91%E3%80%91%E7%94%9F%E4%BA%A7%E8%80%85%E6%B6%88%E8%B4%B9%E8%80%85/</id>
    <published>2020-06-05T13:44:03.000Z</published>
    <updated>2020-06-07T07:40:54.141Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、生产者消费者"><a href="#一、生产者消费者" class="headerlink" title="一、生产者消费者"></a>一、生产者消费者</h2><p>生产者和消费者在同一时间段内共用同一段存储空间，生产者put数据，消费者take数据</p><p>阻塞队列就相当于一个缓冲区，平衡了生产者和消费者的处理能力，将他们解耦。</p><h2 id="二、四种实现生产者消费者模型"><a href="#二、四种实现生产者消费者模型" class="headerlink" title="二、四种实现生产者消费者模型"></a>二、四种实现生产者消费者模型</h2><h3 id="1、Object的wait-notify-方法"><a href="#1、Object的wait-notify-方法" class="headerlink" title="1、Object的wait() / notify()方法"></a>1、Object的wait() / notify()方法</h3><p>wait/notify 是Object的方法，因此我们可以给任何对象实现同步机制。</p><p>wait：当缓冲区满时，生产者/消费者放弃锁，让度cpu，使自己处于等待状态。</p><p>notify：当生产者/消费者 生产/消费 时，放弃锁，向其他线程发出可执行的通知，使自己处于等待状态。</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ProducerConsumer</span> </span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> CAPACITY = <span class="hljs-number">5</span>;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Queue&lt;Integer&gt; queue = <span class="hljs-keyword">new</span> LinkedList&lt;Integer&gt;();    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        <span class="hljs-comment">// 模拟生产者</span>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">3</span>; i++) &#123;            <span class="hljs-keyword">new</span> Thread(()-&gt; produce(),<span class="hljs-string">"procuder-"</span>+ i).start();        &#125;        <span class="hljs-comment">// 模拟消费者</span>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++) &#123;            <span class="hljs-keyword">new</span> Thread(()-&gt; consume(),<span class="hljs-string">"consumer-"</span>+ i).start();        &#125;        <span class="hljs-comment">// 主线程睡眠，便于看效果</span>        <span class="hljs-keyword">try</span> &#123;            TimeUnit.SECONDS.sleep(<span class="hljs-number">2</span>);        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;            e.printStackTrace();        &#125;        System.exit(<span class="hljs-number">0</span>);    &#125;    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">consume</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>) &#123;            <span class="hljs-keyword">synchronized</span> (queue) &#123;                <span class="hljs-keyword">while</span> (queue.isEmpty()) &#123;                    <span class="hljs-keyword">try</span> &#123;                        <span class="hljs-comment">// 空队列，则不能消费</span>                        System.out.println(Thread.currentThread().getName() + <span class="hljs-string">" 等待生产"</span>);                        queue.wait();                    &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;                        e.printStackTrace();                    &#125;                &#125;                <span class="hljs-comment">// 队列不为空，则正常消费</span>                Integer poll = queue.poll();                System.out.println(Thread.currentThread().getName() + <span class="hljs-string">" 消费了"</span> + poll);                queue.notifyAll();                <span class="hljs-comment">// 线程睡眠，便于看效果</span>                <span class="hljs-keyword">try</span> &#123;                    TimeUnit.MILLISECONDS.sleep(<span class="hljs-number">100</span>);                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;                    e.printStackTrace();                &#125;            &#125;        &#125;    &#125;    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">produce</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">int</span> k = <span class="hljs-number">0</span>;        <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>) &#123;            <span class="hljs-keyword">synchronized</span> (queue) &#123;                <span class="hljs-keyword">while</span> (queue.size() == CAPACITY) &#123;                    <span class="hljs-keyword">try</span> &#123;                        <span class="hljs-comment">// 满了则wait</span>                        System.out.println(Thread.currentThread().getName() + <span class="hljs-string">" 等待消费"</span>);                        queue.wait();                    &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;                        e.printStackTrace();                    &#125;                &#125;                <span class="hljs-comment">// 没满则往queue中添加元素</span>                System.out.println(Thread.currentThread().getName() + <span class="hljs-string">" 生产了"</span> + k);                queue.offer(k++);                queue.notifyAll();                <span class="hljs-comment">// 线程睡眠，便于看效果</span>                <span class="hljs-keyword">try</span> &#123;                    TimeUnit.MILLISECONDS.sleep(<span class="hljs-number">100</span>);                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;                    e.printStackTrace();                &#125;            &#125;        &#125;    &#125;&#125;</code></pre><blockquote><p>使用while进行size=queueSize、isEmpty的判断，使用if会造成虚假唤醒。</p></blockquote><h3 id="2、Lock中condition的await-signal-方法"><a href="#2、Lock中condition的await-signal-方法" class="headerlink" title="2、Lock中condition的await()/signal()方法"></a>2、Lock中condition的await()/signal()方法</h3><p>通过在lock对象上调用newCondition()，将变量和锁对象进行绑定，进而控制并发资源的安全。</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LockCondition</span> </span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> CAPACITY = <span class="hljs-number">5</span>;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> ReentrantLock lock = <span class="hljs-keyword">new</span> ReentrantLock();    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Condition fullCondition = lock.newCondition();    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Condition emptyCondition = lock.newCondition();    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Queue&lt;Integer&gt; queue = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">3</span>; i++) &#123;            <span class="hljs-keyword">new</span> Thread(() -&gt; produce(), <span class="hljs-string">"product-"</span> + i).start();        &#125;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">3</span>; i++) &#123;            <span class="hljs-keyword">new</span> Thread(() -&gt; consume(), <span class="hljs-string">"consumer-"</span> + i).start();        &#125;        <span class="hljs-comment">// 主线程睡眠，便于看效果</span>        <span class="hljs-keyword">try</span> &#123;            TimeUnit.SECONDS.sleep(<span class="hljs-number">2</span>);        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;            e.printStackTrace();        &#125;        System.exit(<span class="hljs-number">0</span>);    &#125;    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">consume</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>) &#123;            <span class="hljs-keyword">if</span> (lock.tryLock()) &#123;                <span class="hljs-keyword">try</span> &#123;                    <span class="hljs-keyword">while</span> (queue.isEmpty()) &#123;                        <span class="hljs-comment">// 队列为空，释放锁，通知生产者去生产</span>                        System.out.println(Thread.currentThread().getName() + <span class="hljs-string">" 队列为空，等待生产"</span>);                        emptyCondition.await();                    &#125;                    Integer poll = queue.poll();                    System.out.println(Thread.currentThread().getName() + <span class="hljs-string">" 消费了 "</span> + poll);                    <span class="hljs-comment">//唤醒其他所有生产者、消费者</span>                    fullCondition.signalAll();                    emptyCondition.signalAll();                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;                    e.printStackTrace();                &#125; <span class="hljs-keyword">finally</span> &#123;                    <span class="hljs-keyword">if</span> (lock.isHeldByCurrentThread()) &#123;                        lock.unlock();                    &#125;                &#125;            &#125;            <span class="hljs-comment">// 线程睡眠，便于看效果</span>            <span class="hljs-keyword">try</span> &#123;                TimeUnit.MILLISECONDS.sleep(<span class="hljs-keyword">new</span> Random().nextInt(<span class="hljs-number">100</span>));            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;                e.printStackTrace();            &#125;        &#125;    &#125;    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">produce</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>) &#123;            <span class="hljs-keyword">int</span> k = <span class="hljs-number">0</span>;            <span class="hljs-keyword">if</span> (lock.tryLock()) &#123;                <span class="hljs-keyword">try</span> &#123;                    <span class="hljs-keyword">while</span> (queue.size() == CAPACITY) &#123;                        <span class="hljs-comment">// 队列满了，释放锁，通知消费者去消费</span>                        System.out.println(Thread.currentThread().getName() + <span class="hljs-string">" 队列满了，等待消费"</span>);                        fullCondition.await();                    &#125;                    System.out.println(Thread.currentThread().getName() + <span class="hljs-string">" 生产了"</span> + k);                    queue.offer(k++);                    <span class="hljs-comment">//唤醒其他所有生产者、消费者</span>                    emptyCondition.signalAll();                    fullCondition.signalAll();                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;                    e.printStackTrace();                &#125; <span class="hljs-keyword">finally</span> &#123;                    <span class="hljs-keyword">if</span> (lock.isHeldByCurrentThread()) &#123;                        lock.unlock();                    &#125;                &#125;            &#125;            <span class="hljs-comment">// 线程睡眠，便于看效果</span>            <span class="hljs-keyword">try</span> &#123;                TimeUnit.MILLISECONDS.sleep(<span class="hljs-keyword">new</span> Random().nextInt(<span class="hljs-number">100</span>));            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;                e.printStackTrace();            &#125;        &#125;    &#125;&#125;</code></pre><blockquote><p><strong>await和signal需组合使用</strong>。在案例中阻塞时用了await，但是唤醒时用的notify，导致运行过程中一直报错<code>IllegalMonitorStateException</code></p></blockquote><h3 id="3、使用blockQueue阻塞队列方法"><a href="#3、使用blockQueue阻塞队列方法" class="headerlink" title="3、使用blockQueue阻塞队列方法"></a>3、使用blockQueue阻塞队列方法</h3><p>jdk对2方式的一种封装，可直接使用。</p><p>在juc下，有ArrayBlockingQueue、LinkedBlockingQueue、SynchronousQueue、PriorityBlockingQueue四种实现。</p><p>实现生产者-消费者模型使用 ArrayBlockingQueue或者 LinkedBlockingQueue即可。</p><pre><code class="hljs livescript">public <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyBlockingQueue</span> &#123;</span>    private static final int CAPICITY = <span class="hljs-number">3</span>;    private static final int MAX = <span class="hljs-number">30</span>;    private static final LinkedBlockingQueue&lt;Integer&gt; queue = <span class="hljs-keyword">new</span> LinkedBlockingQueue&lt;&gt;(CAPICITY);    public static <span class="hljs-literal">void</span> main(String[] args) &#123;        <span class="hljs-keyword">for</span> (int i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">3</span>; i++) &#123;            <span class="hljs-keyword">new</span> Thread<span class="hljs-function"><span class="hljs-params">(() -&gt; produce(), <span class="hljs-string">"product-"</span> + i)</span>.<span class="hljs-title">start</span><span class="hljs-params">()</span>;</span><span class="hljs-function">        &#125;</span><span class="hljs-function"></span><span class="hljs-function">        <span class="hljs-title">for</span> <span class="hljs-params">(int i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">3</span>; i++)</span> &#123;</span><span class="hljs-function">            <span class="hljs-title">new</span> <span class="hljs-title">Thread</span><span class="hljs-params">(() -&gt; consume(), <span class="hljs-string">"consumer-"</span> + i)</span>.<span class="hljs-title">start</span><span class="hljs-params">()</span>;</span><span class="hljs-function">        &#125;</span><span class="hljs-function"></span><span class="hljs-function">        // 主线程睡眠，便于看效果</span><span class="hljs-function">        <span class="hljs-title">try</span> &#123;</span><span class="hljs-function">            <span class="hljs-title">TimeUnit</span>.<span class="hljs-title">SECONDS</span>.<span class="hljs-title">sleep</span><span class="hljs-params">(<span class="hljs-number">2</span>)</span>;</span><span class="hljs-function">        &#125; <span class="hljs-title">catch</span> <span class="hljs-params">(InterruptedException e)</span> &#123;</span><span class="hljs-function">            <span class="hljs-title">e</span>.<span class="hljs-title">printStackTrace</span><span class="hljs-params">()</span>;</span><span class="hljs-function">        &#125;</span><span class="hljs-function"></span><span class="hljs-function">        <span class="hljs-title">System</span>.<span class="hljs-title">exit</span><span class="hljs-params">(<span class="hljs-number">0</span>)</span>;</span><span class="hljs-function">    &#125;</span><span class="hljs-function"></span><span class="hljs-function">    <span class="hljs-title">static</span> <span class="hljs-title">void</span> <span class="hljs-title">produce</span><span class="hljs-params">()</span> &#123;</span><span class="hljs-function">        <span class="hljs-title">int</span> <span class="hljs-title">k</span> = 0;</span><span class="hljs-function">        <span class="hljs-title">while</span> <span class="hljs-params">(k &lt; MAX)</span> &#123;</span><span class="hljs-function">            <span class="hljs-title">try</span> &#123;</span><span class="hljs-function">                <span class="hljs-title">System</span>.<span class="hljs-title">out</span>.<span class="hljs-title">println</span><span class="hljs-params">(Thread.currentThread().getName() + <span class="hljs-string">" 生产了"</span> + k)</span>;</span><span class="hljs-function">                <span class="hljs-title">queue</span>.<span class="hljs-title">put</span><span class="hljs-params">(k++)</span>;</span><span class="hljs-function">            &#125; <span class="hljs-title">catch</span> <span class="hljs-params">(InterruptedException e)</span> &#123;</span><span class="hljs-function">                <span class="hljs-title">e</span>.<span class="hljs-title">printStackTrace</span><span class="hljs-params">()</span>;</span><span class="hljs-function">            &#125;</span><span class="hljs-function"></span><span class="hljs-function">            // 线程睡眠，便于看效果</span><span class="hljs-function">            <span class="hljs-title">try</span> &#123;</span><span class="hljs-function">                <span class="hljs-title">TimeUnit</span>.<span class="hljs-title">MILLISECONDS</span>.<span class="hljs-title">sleep</span><span class="hljs-params">(<span class="hljs-keyword">new</span> Random().nextInt(<span class="hljs-number">100</span>))</span>;</span><span class="hljs-function">            &#125; <span class="hljs-title">catch</span> <span class="hljs-params">(InterruptedException e)</span> &#123;</span><span class="hljs-function">                <span class="hljs-title">e</span>.<span class="hljs-title">printStackTrace</span><span class="hljs-params">()</span>;</span><span class="hljs-function">            &#125;</span><span class="hljs-function">        &#125;</span><span class="hljs-function">    &#125;</span><span class="hljs-function"></span><span class="hljs-function">    <span class="hljs-title">static</span> <span class="hljs-title">void</span> <span class="hljs-title">consume</span><span class="hljs-params">()</span> &#123;</span><span class="hljs-function">        <span class="hljs-title">while</span> <span class="hljs-params">(<span class="hljs-literal">true</span>)</span> &#123;</span><span class="hljs-function">            <span class="hljs-title">try</span> &#123;</span><span class="hljs-function">                <span class="hljs-title">Integer</span> <span class="hljs-title">take</span> = <span class="hljs-title">queue</span>.<span class="hljs-title">take</span><span class="hljs-params">()</span>;</span><span class="hljs-function">                <span class="hljs-title">System</span>.<span class="hljs-title">out</span>.<span class="hljs-title">println</span><span class="hljs-params">(Thread.currentThread().getName() + <span class="hljs-string">"消费了"</span> + take)</span>;</span><span class="hljs-function">            &#125; <span class="hljs-title">catch</span> <span class="hljs-params">(InterruptedException e)</span> &#123;</span><span class="hljs-function">                <span class="hljs-title">e</span>.<span class="hljs-title">printStackTrace</span><span class="hljs-params">()</span>;</span><span class="hljs-function">            &#125;</span><span class="hljs-function"></span><span class="hljs-function">            // 线程睡眠，便于看效果</span><span class="hljs-function">            <span class="hljs-title">try</span> &#123;</span><span class="hljs-function">                <span class="hljs-title">TimeUnit</span>.<span class="hljs-title">MILLISECONDS</span>.<span class="hljs-title">sleep</span><span class="hljs-params">(<span class="hljs-keyword">new</span> Random().nextInt(<span class="hljs-number">100</span>))</span>;</span><span class="hljs-function">            &#125; <span class="hljs-title">catch</span> <span class="hljs-params">(InterruptedException e)</span> &#123;</span><span class="hljs-function">                <span class="hljs-title">e</span>.<span class="hljs-title">printStackTrace</span><span class="hljs-params">()</span>;</span><span class="hljs-function">            &#125;</span><span class="hljs-function"></span><span class="hljs-function">        &#125;</span><span class="hljs-function">    &#125;</span><span class="hljs-function"></span><span class="hljs-function">&#125;</span></code></pre><blockquote><p><code>put()</code>方法：类似于我们上面的生产者线程，容量达到最大时，自动阻塞。</p></blockquote><blockquote><p><code>take()</code>方法：类似于我们上面的消费者线程，容量为0时，自动阻塞。</p></blockquote><h2 id="4、PipedInputStream-PipedOutputStream"><a href="#4、PipedInputStream-PipedOutputStream" class="headerlink" title="4、PipedInputStream / PipedOutputStream"></a>4、<strong>PipedInputStream</strong> / PipedOutputStream</h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;一、生产者消费者&quot;&gt;&lt;a href=&quot;#一、生产者消费者&quot; class=&quot;headerlink&quot; title=&quot;一、生产者消费者&quot;&gt;&lt;/a&gt;一、生产者消费者&lt;/h2&gt;&lt;p&gt;生产者和消费者在同一时间段内共用同一段存储空间，生产者put数据，消费者take数据&lt;/p&gt;
      
    
    </summary>
    
    
      <category term="java" scheme="http://yoursite.com/categories/java/"/>
    
    
      <category term="thread queue" scheme="http://yoursite.com/tags/thread-queue/"/>
    
  </entry>
  
  <entry>
    <title>springboot自定义starter</title>
    <link href="http://yoursite.com/2020/06/03/springboot%E8%87%AA%E5%AE%9A%E4%B9%89starter/"/>
    <id>http://yoursite.com/2020/06/03/springboot%E8%87%AA%E5%AE%9A%E4%B9%89starter/</id>
    <published>2020-06-03T14:46:40.000Z</published>
    <updated>2020-06-03T15:02:44.539Z</updated>
    
    <content type="html"><![CDATA[<h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>按照约定，官方的为spring-boot-xxx-starter ，非官方的为 xxx-spring-boot-starter</p><h2 id="一、Spring-Boot-starter机制"><a href="#一、Spring-Boot-starter机制" class="headerlink" title="一、Spring Boot starter机制"></a>一、Spring Boot starter机制</h2><ul><li><p>Spring Boot中的starter是一种非常重要的机制，应用者只需要在maven中引入starter依赖，Spring Boot就能自动扫描到要加载的信息并启动相应的默认配置。</p></li><li><p>starter让我们摆脱了各种依赖库的处理，需要配置各种信息的困扰。</p></li><li><p>Spring Boot会自动通过classpath路径下的类发现需要的Bean，并注册进IOC容器。</p></li><li><p>Spring Boot提供了针对日常企业应用研发各种场景的spring-boot-starter依赖模块。所有这些依赖模块都遵循着约定成俗的默认配置，并允许我们调整这些配置，即遵循“约定大于配置”的理念。</p></li></ul><h2 id="二、自定义starter的条件"><a href="#二、自定义starter的条件" class="headerlink" title="二、自定义starter的条件"></a>二、自定义starter的条件</h2><p>如果想自定义Starter，首选需要实现自动化配置，而要实现自动化配置需要满足以下两个条件：</p><ol><li>能够自动配置项目所需要的配置信息，也就是自动加载依赖环境；</li><li>能够根据项目提供的信息自动生成Bean，并且注册到Bean管理容器中；</li></ol><h2 id="三、自定义starter代码部分"><a href="#三、自定义starter代码部分" class="headerlink" title="三、自定义starter代码部分"></a>三、自定义starter代码部分</h2><h3 id="1、pom文件"><a href="#1、pom文件" class="headerlink" title="1、pom文件"></a>1、pom文件</h3><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">project</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">"http://maven.apache.org/POM/4.0.0"</span></span><span class="hljs-tag">         <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">"http://www.w3.org/2001/XMLSchema-instance"</span></span><span class="hljs-tag">         <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">modelVersion</span>&gt;</span>4.0.0<span class="hljs-tag">&lt;/<span class="hljs-name">modelVersion</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.ztf<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>orange-spring-boot-starter<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.0-SNAPSHOT<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span>        <span class="hljs-comment">&lt;!-- https://mvnrepository.com/artifact/org.springframework.boot/spring-boot-autoconfigure --&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-autoconfigure<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.3.0.RELEASE<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-configuration-processor<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.3.0.RELEASE<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>            <span class="hljs-comment">&lt;!--该依赖只能在本项目中传递，不会传递到引用该项目的父项目中，父项目有需要需主动引用该依赖。--&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">optional</span>&gt;</span>true<span class="hljs-tag">&lt;/<span class="hljs-name">optional</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.projectlombok<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>lombok<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.18.6<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">optional</span>&gt;</span>true<span class="hljs-tag">&lt;/<span class="hljs-name">optional</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">project</span>&gt;</span></code></pre><h3 id="2、定义XxxProperties-属性配置类，"><a href="#2、定义XxxProperties-属性配置类，" class="headerlink" title="2、定义XxxProperties 属性配置类，"></a>2、定义XxxProperties 属性配置类，</h3><ul><li>设置属性前缀，用于在application.properties中配置。</li></ul><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.ztf;<span class="hljs-keyword">import</span> lombok.Data;<span class="hljs-keyword">import</span> org.springframework.boot.context.properties.ConfigurationProperties;<span class="hljs-meta">@ConfigurationProperties</span>(prefix = <span class="hljs-string">"local.orange"</span>)<span class="hljs-meta">@Data</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyProperties</span> </span>&#123;    <span class="hljs-keyword">private</span> String id;    <span class="hljs-keyword">private</span> String name;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> age;&#125;</code></pre><h3 id="3、定义XxxService逻辑操作类"><a href="#3、定义XxxService逻辑操作类" class="headerlink" title="3、定义XxxService逻辑操作类"></a>3、定义XxxService逻辑操作类</h3><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.ztf;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyService</span> </span>&#123;    MyProperties myProperties;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setMyProperties</span><span class="hljs-params">(MyProperties myProperties)</span> </span>&#123;        <span class="hljs-keyword">this</span>.myProperties = myProperties;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">MyService</span><span class="hljs-params">(MyProperties myProperties)</span> </span>&#123;        <span class="hljs-keyword">this</span>.myProperties = myProperties;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">helloWorld</span><span class="hljs-params">()</span> </span>&#123;        System.out.println(<span class="hljs-string">"hi, 我叫: "</span> + myProperties.getName() +                <span class="hljs-string">", id:"</span> + myProperties.getId() + <span class="hljs-string">"岁"</span>                + <span class="hljs-string">", 年龄: "</span> + myProperties.getAge());    &#125;&#125;</code></pre><h3 id="4、定义XxxAutoConfiguration自动配置类"><a href="#4、定义XxxAutoConfiguration自动配置类" class="headerlink" title="4、定义XxxAutoConfiguration自动配置类"></a>4、定义XxxAutoConfiguration自动配置类</h3><ul><li>用于完成Bean创建等工作。</li></ul><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.ztf;<span class="hljs-keyword">import</span> org.springframework.beans.factory.annotation.Autowired;<span class="hljs-keyword">import</span> org.springframework.boot.autoconfigure.condition.ConditionalOnClass;<span class="hljs-keyword">import</span> org.springframework.boot.autoconfigure.condition.ConditionalOnMissingBean;<span class="hljs-keyword">import</span> org.springframework.boot.autoconfigure.condition.ConditionalOnProperty;<span class="hljs-keyword">import</span> org.springframework.boot.context.properties.EnableConfigurationProperties;<span class="hljs-keyword">import</span> org.springframework.context.annotation.Bean;<span class="hljs-keyword">import</span> org.springframework.context.annotation.Configuration;<span class="hljs-meta">@Configuration</span><span class="hljs-meta">@EnableConfigurationProperties</span>(MyProperties<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span><span class="hljs-class">@<span class="hljs-title">ConditionalOnClass</span>(<span class="hljs-title">MyService</span>.<span class="hljs-title">class</span>)</span><span class="hljs-class">@<span class="hljs-title">ConditionalOnProperty</span>(<span class="hljs-title">prefix</span> </span>= <span class="hljs-string">"local.orange"</span>, value = <span class="hljs-string">"enabled"</span>, matchIfMissing = <span class="hljs-keyword">true</span>)<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyServiceAutoConfiguration</span> </span>&#123;    <span class="hljs-meta">@Autowired</span>    MyProperties myProperties;    <span class="hljs-meta">@Bean</span>    <span class="hljs-meta">@ConditionalOnMissingBean</span>(MyService<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span><span class="hljs-class">    <span class="hljs-title">public</span> <span class="hljs-title">MyService</span> <span class="hljs-title">myService</span>() </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> MyService(myProperties);    &#125;&#125;</code></pre><h3 id="5、在spring-factories中声明"><a href="#5、在spring-factories中声明" class="headerlink" title="5、在spring.factories中声明"></a>5、在spring.factories中声明</h3><ul><li><p>在resources下创建目录META-INF，在 META-INF 目录下创建 spring.factories，在SpringBoot启动时会根据此文件来加载项目的自动化配置类。</p></li><li><p>spring.factories内容如下：</p></li></ul><pre><code class="hljs java">org.springframework.boot.autoconfigure.EnableAutoConfiguration=com.ztf.MyServiceAutoConfiguration</code></pre><h2 id="四、自定义starter使用"><a href="#四、自定义starter使用" class="headerlink" title="四、自定义starter使用"></a>四、自定义starter使用</h2><h3 id="1、pom中引用自定义starter的jar"><a href="#1、pom中引用自定义starter的jar" class="headerlink" title="1、pom中引用自定义starter的jar"></a>1、pom中引用自定义starter的jar</h3><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.ztf<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>orange-spring-boot-starter<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.0-SNAPSHOT<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre><h3 id="2、yml配置文件中声明参数"><a href="#2、yml配置文件中声明参数" class="headerlink" title="2、yml配置文件中声明参数"></a>2、yml配置文件中声明参数</h3><pre><code class="hljs yaml"><span class="hljs-comment">## 自定义的一个starter</span><span class="hljs-attr">local:</span>  <span class="hljs-attr">orange:</span>    <span class="hljs-attr">id:</span> <span class="hljs-number">007</span>    <span class="hljs-attr">name:</span> <span class="hljs-string">myorange</span>    <span class="hljs-attr">age:</span> <span class="hljs-number">18</span></code></pre><h3 id="3、项目中使用"><a href="#3、项目中使用" class="headerlink" title="3、项目中使用"></a>3、项目中使用</h3><pre><code class="hljs java"><span class="hljs-meta">@Autowired</span>MyService myService;<span class="hljs-meta">@GetMapping</span>(<span class="hljs-string">"/test"</span>)<span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">testMyStarter</span><span class="hljs-params">()</span> </span>&#123;  myService.helloWorld();  <span class="hljs-keyword">return</span> <span class="hljs-string">"ok"</span>;&#125;</code></pre><h2 id="六、总结"><a href="#六、总结" class="headerlink" title="六、总结"></a>六、总结</h2><ol><li>Spring Boot在启动时扫描项目所依赖的JAR包，寻找包含spring.factories文件的JAR包，</li><li>然后读取spring.factories文件获取配置的自动配置类AutoConfiguration，</li><li>然后将自动配置类下满足条件(@ConditionalOnXxx)的@Bean放入到Spring容器中(Spring Context)</li><li>这样使用者就可以直接用来注入，因为该类已经在容器中了</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;写在前面&quot;&gt;&lt;a href=&quot;#写在前面&quot; class=&quot;headerlink&quot; title=&quot;写在前面&quot;&gt;&lt;/a&gt;写在前面&lt;/h2&gt;&lt;p&gt;按照约定，官方的为spring-boot-xxx-starter ，非官方的为 xxx-spring-boot-starte
      
    
    </summary>
    
    
      <category term="java" scheme="http://yoursite.com/categories/java/"/>
    
    
      <category term="springboot" scheme="http://yoursite.com/tags/springboot/"/>
    
  </entry>
  
  <entry>
    <title>mac环境变量配置</title>
    <link href="http://yoursite.com/2020/06/03/mac%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E9%85%8D%E7%BD%AE/"/>
    <id>http://yoursite.com/2020/06/03/mac%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E9%85%8D%E7%BD%AE/</id>
    <published>2020-06-03T13:10:43.000Z</published>
    <updated>2020-06-03T13:13:25.334Z</updated>
    
    <content type="html"><![CDATA[<h2 id="gradle环境变量配置"><a href="#gradle环境变量配置" class="headerlink" title="gradle环境变量配置"></a>gradle环境变量配置</h2><pre><code class="hljs xml">vi ~/.bash_profile# 增加gradle环境变量，如下：export GRADLE_HOME=/Users/orange/Documents/gradle-6.4export PATH=$PATH:$GRADLE_HOME/bin# 刷新source ~/.bash_profile# 查看版本gradle -version</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;gradle环境变量配置&quot;&gt;&lt;a href=&quot;#gradle环境变量配置&quot; class=&quot;headerlink&quot; title=&quot;gradle环境变量配置&quot;&gt;&lt;/a&gt;gradle环境变量配置&lt;/h2&gt;&lt;pre&gt;&lt;code class=&quot;hljs xml&quot;&gt;vi ~/
      
    
    </summary>
    
    
      <category term="idea" scheme="http://yoursite.com/categories/idea/"/>
    
    
      <category term="环境变量" scheme="http://yoursite.com/tags/%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/"/>
    
  </entry>
  
  <entry>
    <title>mybatis-generator</title>
    <link href="http://yoursite.com/2020/06/02/mybatis-generator/"/>
    <id>http://yoursite.com/2020/06/02/mybatis-generator/</id>
    <published>2020-06-02T13:36:54.000Z</published>
    <updated>2020-06-03T12:18:35.200Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-作用"><a href="#1-作用" class="headerlink" title="1.作用"></a>1.作用</h2><p>用来自动生成MyBatis的 mapper、dao、entity </p><h2 id="2-使用"><a href="#2-使用" class="headerlink" title="2.使用"></a>2.使用</h2><p>MyBatis Generator的使用方式有4种：</p><ul><li>命令行生成</li><li>Maven方式生成</li><li>使用Ant任务生成</li><li>使用Java代码生成</li></ul><p>其中推荐使用Maven方式进行代码生成，因为集成和使用比较简单。</p><h2 id="3-代码自动生成配置"><a href="#3-代码自动生成配置" class="headerlink" title="3.代码自动生成配置"></a>3.代码自动生成配置</h2><h3 id="Step1：配置pom中plugin依赖"><a href="#Step1：配置pom中plugin依赖" class="headerlink" title="Step1：配置pom中plugin依赖"></a>Step1：配置pom中plugin依赖</h3><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">plugin</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.mybatis.generator<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mybatis-generator-maven-plugin<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.4.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">executions</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">execution</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">id</span>&gt;</span>Generate MyBatis Artifacts<span class="hljs-tag">&lt;/<span class="hljs-name">id</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">phase</span>&gt;</span>package<span class="hljs-tag">&lt;/<span class="hljs-name">phase</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">goals</span>&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">goal</span>&gt;</span>generate<span class="hljs-tag">&lt;/<span class="hljs-name">goal</span>&gt;</span>            <span class="hljs-tag">&lt;/<span class="hljs-name">goals</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">execution</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">executions</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">configuration</span>&gt;</span>        <span class="hljs-comment">&lt;!--允许移动生成的文件 --&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">verbose</span>&gt;</span>true<span class="hljs-tag">&lt;/<span class="hljs-name">verbose</span>&gt;</span>        <span class="hljs-comment">&lt;!-- 是否覆盖 --&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">overwrite</span>&gt;</span>true<span class="hljs-tag">&lt;/<span class="hljs-name">overwrite</span>&gt;</span>        <span class="hljs-comment">&lt;!-- 自动生成的配置 --&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">configurationFile</span>&gt;</span>src/main/resources/generatorConfig.xml<span class="hljs-tag">&lt;/<span class="hljs-name">configurationFile</span>&gt;</span>        <span class="hljs-comment">&lt;!--将当前pom的依赖项添加到生成器的类路径中--&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">includeCompileDependencies</span>&gt;</span>true<span class="hljs-tag">&lt;/<span class="hljs-name">includeCompileDependencies</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">configuration</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">plugin</span>&gt;</span></code></pre><h3 id="Step2：配置generatorConfig-xml文件"><a href="#Step2：配置generatorConfig-xml文件" class="headerlink" title="Step2：配置generatorConfig.xml文件"></a>Step2：配置generatorConfig.xml文件</h3><pre><code class="hljs dust"><span class="xml"><span class="hljs-meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><span class="xml"><span class="hljs-comment">&lt;!--mybatis的代码生成器相关配置--&gt;</span></span><span class="xml"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">generatorConfiguration</span></span></span><span class="xml">        PUBLIC "-//mybatis.org//DTD MyBatis Generator Configuration 1.0//EN"</span><span class="xml">        "http://mybatis.org/dtd/mybatis-generator-config_1_0.dtd"&gt;</span><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">generatorConfiguration</span>&gt;</span></span><span class="xml">    <span class="hljs-comment">&lt;!-- 引入配置文件 --&gt;</span></span><span class="xml">    <span class="hljs-tag">&lt;<span class="hljs-name">properties</span> <span class="hljs-attr">resource</span>=<span class="hljs-string">"application.yml"</span>/&gt;</span>   </span><span class="xml">    <span class="hljs-tag">&lt;<span class="hljs-name">context</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"Mysql"</span> <span class="hljs-attr">targetRuntime</span>=<span class="hljs-string">"MyBatis3Simple"</span> <span class="hljs-attr">defaultModelType</span>=<span class="hljs-string">"flat"</span>&gt;</span></span><span class="xml">        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"autoDelimitKeywords"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"true"</span> /&gt;</span></span><span class="xml">        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"beginningDelimiter"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"`"</span> /&gt;</span></span><span class="xml">        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"endingDelimiter"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"`"</span> /&gt;</span></span><span class="xml">        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"javaFileEncoding"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"utf-8"</span> /&gt;</span></span><span class="xml">        <span class="hljs-tag">&lt;<span class="hljs-name">plugin</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"org.mybatis.generator.plugins.SerializablePlugin"</span> /&gt;</span></span><span class="xml">        <span class="hljs-tag">&lt;<span class="hljs-name">commentGenerator</span> &gt;</span></span><span class="xml">            <span class="hljs-comment">&lt;!-- 不生成注释 --&gt;</span></span><span class="xml">            <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"suppressAllComments"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"true"</span>/&gt;</span></span><span class="xml">            <span class="hljs-comment">&lt;!-- 不生成注释代时间戳--&gt;</span></span><span class="xml">            <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"suppressDate"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"true"</span> /&gt;</span></span><span class="xml">        <span class="hljs-tag">&lt;/<span class="hljs-name">commentGenerator</span>&gt;</span></span><span class="xml">        <span class="hljs-comment">&lt;!--数据库链接地址账号密码--&gt;</span></span><span class="xml">        <span class="hljs-comment">&lt;!--&lt;jdbcConnection driverClass="$</span></span><span class="hljs-template-variable">&#123;spring.datasource.driver-class-name&#125;</span><span class="xml"><span class="hljs-comment">"--&gt;</span></span><span class="xml">                        <span class="hljs-comment">&lt;!--connectionURL="$</span></span><span class="hljs-template-variable">&#123;spring.datasource.url&#125;</span><span class="xml"><span class="hljs-comment">"--&gt;</span></span><span class="xml">                        <span class="hljs-comment">&lt;!--userId="$</span></span><span class="hljs-template-variable">&#123;spring.datasource.username&#125;</span><span class="xml"><span class="hljs-comment">"--&gt;</span></span><span class="xml">                        <span class="hljs-comment">&lt;!--password="$</span></span><span class="hljs-template-variable">&#123;spring.datasource.password&#125;</span><span class="xml"><span class="hljs-comment">"&gt;--&gt;</span></span><span class="xml">        <span class="hljs-comment">&lt;!--&lt;/jdbcConnection&gt;--&gt;</span></span><span class="xml">        <span class="hljs-tag">&lt;<span class="hljs-name">jdbcConnection</span> <span class="hljs-attr">driverClass</span>=<span class="hljs-string">"com.mysql.cj.jdbc.Driver"</span></span></span><span class="xml">            connectionURL="jdbc:mysql://localhost:3306/display"</span><span class="xml">            userId="root"</span><span class="xml">            password="P@ssw0rd"&gt;</span><span class="xml">        <span class="hljs-tag">&lt;/<span class="hljs-name">jdbcConnection</span>&gt;</span></span><span class="xml">        <span class="hljs-comment">&lt;!-- 类型转换 --&gt;</span></span><span class="xml">        <span class="hljs-tag">&lt;<span class="hljs-name">javaTypeResolver</span>&gt;</span></span><span class="xml">            <span class="hljs-comment">&lt;!-- 是否使用bigDecimal， false可自动转化以下类型（Long, Integer, Short, etc.） --&gt;</span></span><span class="xml">            <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"forceBigDecimals"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"false"</span>/&gt;</span></span><span class="xml">        <span class="hljs-tag">&lt;/<span class="hljs-name">javaTypeResolver</span>&gt;</span></span><span class="xml">        <span class="hljs-comment">&lt;!--生成Model类存放位置--&gt;</span></span><span class="xml">        <span class="hljs-tag">&lt;<span class="hljs-name">javaModelGenerator</span> <span class="hljs-attr">targetPackage</span>=<span class="hljs-string">"com.ztf.mybatisplus.bean"</span> <span class="hljs-attr">targetProject</span>=<span class="hljs-string">"src/main/java"</span>&gt;</span></span><span class="xml">            <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"enableSubPackages"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"true"</span>/&gt;</span></span><span class="xml">            <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"trimStrings"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"true"</span>/&gt;</span></span><span class="xml">        <span class="hljs-tag">&lt;/<span class="hljs-name">javaModelGenerator</span>&gt;</span></span><span class="xml">        <span class="hljs-comment">&lt;!-- 生成mapxml文件 --&gt;</span></span><span class="xml">        <span class="hljs-tag">&lt;<span class="hljs-name">sqlMapGenerator</span> <span class="hljs-attr">targetPackage</span>=<span class="hljs-string">"mapper"</span> <span class="hljs-attr">targetProject</span>=<span class="hljs-string">"src/main/resources/mybatis"</span> &gt;</span></span><span class="xml">            <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"enableSubPackages"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"false"</span> /&gt;</span></span><span class="xml">        <span class="hljs-tag">&lt;/<span class="hljs-name">sqlMapGenerator</span>&gt;</span></span><span class="xml">        <span class="hljs-comment">&lt;!-- 生成mapper java文件 --&gt;</span></span><span class="xml">        <span class="hljs-tag">&lt;<span class="hljs-name">javaClientGenerator</span> <span class="hljs-attr">targetPackage</span>=<span class="hljs-string">"com.ztf.mybatisplus.dao"</span> <span class="hljs-attr">targetProject</span>=<span class="hljs-string">"src/main/java"</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"XMLMAPPER"</span> &gt;</span></span><span class="xml">            <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"enableSubPackages"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"false"</span> /&gt;</span></span><span class="xml">        <span class="hljs-tag">&lt;/<span class="hljs-name">javaClientGenerator</span>&gt;</span></span><span class="xml"><span class="hljs-comment">&lt;!--具体解析的表，建议配置domainObjectName属性，避免带上表前缀T_--&gt;</span></span><span class="xml">        <span class="hljs-tag">&lt;<span class="hljs-name">table</span> <span class="hljs-attr">tableName</span>=<span class="hljs-string">"t_corp"</span> <span class="hljs-attr">enableCountByExample</span>=<span class="hljs-string">"true"</span> <span class="hljs-attr">domainObjectName</span>=<span class="hljs-string">"Corp"</span></span></span><span class="xml">               enableUpdateByExample="true" enableDeleteByExample="true"</span><span class="xml">               enableSelectByExample="true" selectByExampleQueryId="true"&gt;</span><span class="xml">            <span class="hljs-comment">&lt;!--&lt;generatedKey column="id" sqlStatement="Mysql" identity="true" /&gt;--&gt;</span></span><span class="xml">        <span class="hljs-tag">&lt;/<span class="hljs-name">table</span>&gt;</span></span><span class="xml">        <span class="hljs-comment">&lt;!--&lt;table tableName="user_log" enableCountByExample="true" --&gt;</span></span><span class="xml">               <span class="hljs-comment">&lt;!--enableUpdateByExample="true" enableDeleteByExample="true" --&gt;</span></span><span class="xml">               <span class="hljs-comment">&lt;!--enableSelectByExample="true" selectByExampleQueryId="true"&gt;--&gt;</span></span><span class="xml">            <span class="hljs-comment">&lt;!--&lt;generatedKey column="id" sqlStatement="Mysql" identity="true" /&gt;--&gt;</span></span><span class="xml">        <span class="hljs-comment">&lt;!--&lt;/table&gt;--&gt;</span></span><span class="xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">context</span>&gt;</span></span><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">generatorConfiguration</span>&gt;</span></span></code></pre><h2 id="4-注意事项"><a href="#4-注意事项" class="headerlink" title="4.注意事项"></a>4.注意事项</h2><ul><li>MyBatis Generator 只会覆盖旧的 po、dao、而 mapper.xml 不会覆盖，而是追加，这样做的目的是防止用户自己写的 sql 语句一不小心都被 MyBatis Generator 给覆盖了</li></ul><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- 是否覆盖 --&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">overwrite</span>&gt;</span>true<span class="hljs-tag">&lt;/<span class="hljs-name">overwrite</span>&gt;</span></code></pre><ul><li>一般配置了 <strong>includeCompileDependencies</strong> 后就不需要配置其他依赖了，因为 <strong>includeCompileDependencies</strong> 会将当前 pom 的 <strong>dependencies</strong> 中所有 <strong>Compile</strong> 期的依赖全部添加到生成器的类路径中。</li></ul><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--将当前pom的依赖项添加到生成器的类路径中--&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">includeCompileDependencies</span>&gt;</span>true<span class="hljs-tag">&lt;/<span class="hljs-name">includeCompileDependencies</span>&gt;</span></code></pre><ul><li>数据库文件yml方式加载不进来配置，写成<code>application.properties&quot;</code>方式就可以</li></ul><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- 引入配置文件 --&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">properties</span> <span class="hljs-attr">resource</span>=<span class="hljs-string">"application-dev.properties"</span>/&gt;</span></code></pre><ul><li>context属性</li></ul><pre><code class="hljs xml">id : 随便填，保证多个 context id 不重复就行defaultModelType ： 可以不填，默认值 conditional，flat表示一张表对应一个potargetRuntime ：可以不填，默认值 MyBatis3，常用的还有 MyBatis3Simple。MyBatis3Simple生成的 dao 和 mapper.xml 内容较少，但也包含了最常用的。</code></pre><ul><li>context的子元素要求有序</li></ul><pre><code class="hljs angelscript"><span class="hljs-number">1.</span> **<span class="hljs-keyword">property</span>** (<span class="hljs-number">0.</span>.N)<span class="hljs-number">2.</span> **plugin** (<span class="hljs-number">0.</span>.N)<span class="hljs-number">3.</span> **commentGenerator** (<span class="hljs-number">0</span> <span class="hljs-keyword">or</span> <span class="hljs-number">1</span>)<span class="hljs-number">4.</span> **jdbcConnection** (需要connectionFactory 或 jdbcConnection)<span class="hljs-number">5.</span> **javaTypeResolver** (<span class="hljs-number">0</span> <span class="hljs-keyword">or</span> <span class="hljs-number">1</span>)<span class="hljs-number">6.</span> **javaModelGenerator** (至少<span class="hljs-number">1</span>个)<span class="hljs-number">7.</span> **sqlMapGenerator** (<span class="hljs-number">0</span> <span class="hljs-keyword">or</span> <span class="hljs-number">1</span>)<span class="hljs-number">8.</span> **javaClientGenerator** (<span class="hljs-number">0</span> <span class="hljs-keyword">or</span> <span class="hljs-number">1</span>)<span class="hljs-number">9.</span> **table** (<span class="hljs-number">1.</span>.N)</code></pre><ul><li>commentGenerator 默认生成注释和时间戳，可显式的声明某一项不生成。<strong>建议全部显式不生成。</strong></li></ul><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">commentGenerator</span>&gt;</span>    <span class="hljs-comment">&lt;!-- 不希望生成的注释中包含时间戳 --&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"suppressDate"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"true"</span>/&gt;</span>    <span class="hljs-comment">&lt;!-- 不希望生成的注释中包含注释 --&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"suppressAllComments"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"true"</span>/&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">commentGenerator</span>&gt;</span></code></pre><ul><li><code>type=&quot;XMLMAPPER&quot;</code> 会将接口的实现放在 mapper.xml中，也推荐这样配置。也可以设置  <code>type=&quot;ANNOTATEDMAPPER&quot;</code>，接口的实现通过注解写在接口上面</li><li>一个 table 对应一张表，如果想同时生成多张表，需要配置多个 table</li><li><strong>domainObjectName</strong> 不配置时，它会按照帕斯卡命名法将表名转换成类名，建议配置该属性，避免带上表前缀T_</li></ul><pre><code class="hljs routeros">&lt;domainObjectRenamingRule <span class="hljs-attribute">searchString</span>=<span class="hljs-string">"^T"</span> <span class="hljs-attribute">replaceString</span>=<span class="hljs-string">""</span> /&gt;</code></pre><ul><li>表字段也会默认带上<code>c_</code>、<code>d_</code>，可设置去掉</li></ul><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- 这个意思就是匹配，开头的任意个非下划线(_)的字符，也就是这种如：c_，d_ 等等 --&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">columnRenamingRule</span> <span class="hljs-attr">searchString</span>=<span class="hljs-string">"^[^_]+"</span> <span class="hljs-attr">replaceString</span>=<span class="hljs-string">""</span>/&gt;</span>  <span class="hljs-comment">&lt;!-- 也可如下只去掉c_--&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">columnRenamingRule</span> <span class="hljs-attr">searchString</span>=<span class="hljs-string">"^c_"</span> <span class="hljs-attr">replaceString</span>=<span class="hljs-string">""</span> /&gt;</span></code></pre><ul><li><strong>enableXXXByExample</strong> 默认为true，但只有在<code>targetRuntime=&quot;MyBatis3&quot;</code>时才生效。当 <code>targetRuntime=&quot;MyBatis3Simple&quot;</code>时，<strong>enableXXXByExample</strong> 不管为true、还是false 都不生效。一般建议全设置为false，true的话会生成很多Example帮助类，造成很多sonar问题。</li></ul><h2 id="4-参考"><a href="#4-参考" class="headerlink" title="4.参考"></a>4.参考</h2><p><a href="https://segmentfault.com/a/1190000016570268" target="_blank" rel="noopener">Spring Boot （七）MyBatis代码自动生成和辅助插件</a></p><p><a href="https://juejin.im/post/5db694e3e51d452a2e25ba45" target="_blank" rel="noopener">MyBatis Generator 超详细配置</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;1-作用&quot;&gt;&lt;a href=&quot;#1-作用&quot; class=&quot;headerlink&quot; title=&quot;1.作用&quot;&gt;&lt;/a&gt;1.作用&lt;/h2&gt;&lt;p&gt;用来自动生成MyBatis的 mapper、dao、entity &lt;/p&gt;
&lt;h2 id=&quot;2-使用&quot;&gt;&lt;a href=&quot;#
      
    
    </summary>
    
    
      <category term="mybatis" scheme="http://yoursite.com/categories/mybatis/"/>
    
    
      <category term="mybatis-generator" scheme="http://yoursite.com/tags/mybatis-generator/"/>
    
  </entry>
  
  <entry>
    <title>性能优化策略</title>
    <link href="http://yoursite.com/2020/06/01/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E7%AD%96%E7%95%A5/"/>
    <id>http://yoursite.com/2020/06/01/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E7%AD%96%E7%95%A5/</id>
    <published>2020-06-01T12:42:04.000Z</published>
    <updated>2020-06-01T13:25:08.525Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、时空转换"><a href="#一、时空转换" class="headerlink" title="一、时空转换"></a>一、时空转换</h2><h3 id="1-1-时间换空间"><a href="#1-1-时间换空间" class="headerlink" title="1.1 时间换空间"></a>1.1 时间换空间</h3><ul><li>场景1: 降低内存空间的占用。</li><li>场景2: 降低数据的大小来方便网络传输和外部存储。</li></ul><p>具体方式：</p><p>1、改变数据结构或者数据格式，减少要存储的数据大小。</p><p>2、使用压缩算法，压缩内存中的数据，使用时解压。</p><p>3、把内存中的数据存储到外部的、更便宜的存储设备中，需要时再取回来。</p><blockquote><p>这些节省内存空间的方法，一般都需要付出时间的代价。</p></blockquote><blockquote><p>衡量任何压缩算法，基本上看三个指标：压缩比例、压缩速度以及使用内存。</p></blockquote><blockquote><p>如果系统的瓶颈在<strong>网络传输速度或者存储空间大小</strong>上，那就尽量采取高压缩比的算法。</p></blockquote><h3 id="1-2-空间换时间"><a href="#1-2-空间换时间" class="headerlink" title="1.2 空间换时间"></a>1.2 空间换时间</h3><ul><li>场景：要求快速响应。</li></ul><p>具体方式：</p><p>1、对数据和服务进行多份拷贝，尽大可能的覆盖更多的用户。</p><blockquote><p>典型案例：集群</p></blockquote><h2 id="二、预处理和延后处理"><a href="#二、预处理和延后处理" class="headerlink" title="二、预处理和延后处理"></a>二、预处理和延后处理</h2><h3 id="2-1-预处理-提前处理"><a href="#2-1-预处理-提前处理" class="headerlink" title="2.1 预处理/提前处理"></a>2.1 预处理/提前处理</h3><p>使用场景：</p><p>1、web静态资源提前加载，preload 和 prefetch。</p><p>2、文件系统预读功能。提前从磁盘读取下一次的数据。</p><blockquote><p>这个功能对顺序读取十分有效，可以减少磁盘请求的数量</p></blockquote><h3 id="2-2-延后-惰性处理"><a href="#2-2-延后-惰性处理" class="headerlink" title="2.2 延后/惰性处理"></a>2.2 延后/惰性处理</h3><ul><li>尽量将操作推迟到必须执行的时刻。</li></ul><p>使用场景：</p><p>1、COW（copy on write）写时复制。多线程读取共享资源时，不进行复制操作，当某个线程需要对资源进行修改时，才拷贝一份到工作内存，使其不会影响其他线程。</p><h2 id="三、并行和并发"><a href="#三、并行和并发" class="headerlink" title="三、并行和并发"></a>三、并行和并发</h2><h2 id="四、缓存-批量合并"><a href="#四、缓存-批量合并" class="headerlink" title="四、缓存/批量合并"></a>四、缓存/批量合并</h2><h3 id="4-1-缓存"><a href="#4-1-缓存" class="headerlink" title="4.1 缓存"></a>4.1 缓存</h3><ul><li>缓存的本质是加速访问。</li></ul><p>使用场景：</p><p>1、对于一个基于 Web 的应用服务，前端会有浏览器缓存，有 CDN 存放在边缘服务器上，有反向代理提供的静态内容缓存；后端则还会有服务器本地缓存。</p><p>2、程序设计中，对于可能重复创建和销毁，且创建销毁代价很大的对象（比如套接字和线程），也可以缓存，对应的缓存形式，就是连接池和线程池等。</p><p>3、对于消耗较大的计算，也可以将计算结果缓存起来，下次可以直接读取结果。比如对递归代码的一个有效优化手段，就是缓存中间结果。</p><h3 id="4-2批量合并"><a href="#4-2批量合并" class="headerlink" title="4.2批量合并"></a>4.2批量合并</h3><ul><li>在有 IO（比如网络 IO 和磁盘 IO）的时候，合并操作和批量操作往往能提升吞吐量，提高性能。</li></ul><p>使用场景：</p><p>1、批量 IO 读写。就是在有多次 IO 的时候，可以把它们合并成一次读写数据。这样可以减少读写时间和协议负担。</p><p>2、对数据库的读写操作，也可以尽量合并。比如，对键值数据库的查询，最好一次查询多个键，而不要分成多次。</p><p>3、涉及到网络请求的时候，网络传输的时间可能远大于请求的处理时间，因此合并网络请求也很有必要。</p><h2 id="五、更高效的算法和数据结构"><a href="#五、更高效的算法和数据结构" class="headerlink" title="五、更高效的算法和数据结构"></a>五、更高效的算法和数据结构</h2><h2 id="附录："><a href="#附录：" class="headerlink" title="附录："></a>附录：</h2><p><a href="https://www.toutiao.com/i6832247243278385671/" target="_blank" rel="noopener">参考文档</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;一、时空转换&quot;&gt;&lt;a href=&quot;#一、时空转换&quot; class=&quot;headerlink&quot; title=&quot;一、时空转换&quot;&gt;&lt;/a&gt;一、时空转换&lt;/h2&gt;&lt;h3 id=&quot;1-1-时间换空间&quot;&gt;&lt;a href=&quot;#1-1-时间换空间&quot; class=&quot;headerlink
      
    
    </summary>
    
    
      <category term="总结" scheme="http://yoursite.com/categories/%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="性能优化" scheme="http://yoursite.com/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>服务熔断</title>
    <link href="http://yoursite.com/2020/05/31/%E6%9C%8D%E5%8A%A1%E7%86%94%E6%96%AD/"/>
    <id>http://yoursite.com/2020/05/31/%E6%9C%8D%E5%8A%A1%E7%86%94%E6%96%AD/</id>
    <published>2020-05-31T14:43:58.000Z</published>
    <updated>2020-05-31T15:45:41.762Z</updated>
    
    <content type="html"><![CDATA[<h1 id="服务熔断"><a href="#服务熔断" class="headerlink" title="服务熔断"></a>服务熔断</h1><ul><li>hystrix，是一个用于处理分布式系统延迟和容错的库，它能够保证在一个子服务出问题的情况下，不会导致整体服务失败，避免级联雪崩，以提高分布式系统的弹性。</li><li>“断路器”本身是一个开关装置，当某个服务单元发生故障后，向调用方返回一个服务预期的、可处理的备选响应，而不是长时间等待或者抛出一个服务端无法处理的异常。这样就保证了调用方线程不会被长时间占用，从而避免故障在分布式系统中蔓延，甚至雪崩。</li></ul><h2 id="1、服务降级（客户端提供异常响应）"><a href="#1、服务降级（客户端提供异常响应）" class="headerlink" title="1、服务降级（客户端提供异常响应）"></a>1、服务降级（客户端提供异常响应）</h2><ul><li>限制其他低相关服务的访问，使他们占用计算机较少的资源，从而保障主服务拥有更多的资源，使其能正常访问。</li></ul><pre><code class="hljs java"><span class="hljs-comment">// 配置文件默认关闭，需手动开启</span>feign:  hystrix:    enabled: true # 启用服务降级<span class="hljs-meta">@FeignClient</span>(name = <span class="hljs-string">"MYCLOUD-PROVIDER"</span>, fallback = HystrixConsumerService<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span><span class="hljs-class"><span class="hljs-title">public</span> <span class="hljs-title">interface</span> <span class="hljs-title">CorpConsumerService</span> </span>&#123;    <span class="hljs-meta">@GetMapping</span>(<span class="hljs-string">"/corps/&#123;id&#125;"</span>)    <span class="hljs-function">Corp <span class="hljs-title">getCorp</span><span class="hljs-params">(@PathVariable(<span class="hljs-string">"id"</span>)</span> String id)</span>;    <span class="hljs-meta">@GetMapping</span>(<span class="hljs-string">"/corps"</span>)    <span class="hljs-function">List&lt;Corp&gt; <span class="hljs-title">getCorps</span><span class="hljs-params">()</span></span>;&#125;<span class="hljs-comment">// 客户端熔断回调缺省值处理</span><span class="hljs-comment">// 假设服务端未启动，即这么处理</span><span class="hljs-meta">@Service</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HystrixConsumerService</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">CorpConsumerService</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> Corp <span class="hljs-title">getCorp</span><span class="hljs-params">(String id)</span> </span>&#123;        <span class="hljs-keyword">return</span> Corp.builder().id(id).name(<span class="hljs-string">"HystrixConsumerService"</span>).age(<span class="hljs-number">40</span>).build();    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;Corp&gt; <span class="hljs-title">getCorps</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;    &#125;&#125;</code></pre><h2 id="2、服务熔断（服务端返回合适的异常响应）"><a href="#2、服务熔断（服务端返回合适的异常响应）" class="headerlink" title="2、服务熔断（服务端返回合适的异常响应）"></a>2、服务熔断（服务端返回合适的异常响应）</h2><ul><li>熔断机制是对微服务雪崩效应的一种链路保护机制。</li><li>当扇出链路的某个微服务不可用或者响应时间太长时，会进行服务的降级，<strong>进而熔断该节点的微服务调用，快速返回错误的响应信息，当检测到该微服务调用响应正常后恢复调用链路。</strong></li><li>hystrix会监控微服务之间的调用状况，当失败的调用到一定阈值，缺省是5s内20ci调用失败就会触发。熔断机制的注解是@HystrixCommand。</li></ul><pre><code class="hljs java"><span class="hljs-comment">// 启动类配置enable</span><span class="hljs-meta">@SpringBootApplication</span><span class="hljs-meta">@EnableEurekaClient</span><span class="hljs-meta">@EnableHystrix</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CorpProvider8005</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        SpringApplication.run(CorpProvider8005<span class="hljs-class">.<span class="hljs-keyword">class</span>, <span class="hljs-title">args</span>)</span>;    &#125;&#125;<span class="hljs-comment">// 添加@HystrixCommand注解</span><span class="hljs-comment">// 发生异常时，会调用hystrixCorp方法，控制台无异常堆栈</span><span class="hljs-meta">@GetMapping</span>(<span class="hljs-string">"/corps/&#123;id&#125;"</span>)<span class="hljs-meta">@HystrixCommand</span>(fallbackMethod = <span class="hljs-string">"hystrixCorp"</span>)<span class="hljs-function">Corp <span class="hljs-title">getCorp</span><span class="hljs-params">(@PathVariable(<span class="hljs-string">"id"</span>)</span> String id) </span>&#123;  Corp corp = corpService.getCorp(id);  <span class="hljs-keyword">if</span> (corp == <span class="hljs-keyword">null</span>) &#123;    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(<span class="hljs-string">"id "</span> + id + <span class="hljs-string">" 不存在"</span>);  &#125;  <span class="hljs-keyword">return</span> corp;&#125;<span class="hljs-function">Corp <span class="hljs-title">hystrixCorp</span><span class="hljs-params">(@PathVariable(<span class="hljs-string">"id"</span>)</span> String id) </span>&#123;  <span class="hljs-keyword">return</span> Corp.builder().id(id).name(<span class="hljs-string">"hystrix"</span>).age(<span class="hljs-number">30</span>).build();&#125;</code></pre><h2 id="3、服务限流"><a href="#3、服务限流" class="headerlink" title="3、服务限流"></a>3、服务限流</h2><h2 id="4、实时监控"><a href="#4、实时监控" class="headerlink" title="4、实时监控"></a>4、实时监控</h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;服务熔断&quot;&gt;&lt;a href=&quot;#服务熔断&quot; class=&quot;headerlink&quot; title=&quot;服务熔断&quot;&gt;&lt;/a&gt;服务熔断&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;hystrix，是一个用于处理分布式系统延迟和容错的库，它能够保证在一个子服务出问题的情况下，不会导致整体服务失
      
    
    </summary>
    
    
      <category term="java" scheme="http://yoursite.com/categories/java/"/>
    
    
      <category term="springCloud hystrix" scheme="http://yoursite.com/tags/springCloud-hystrix/"/>
    
  </entry>
  
  <entry>
    <title>负载均衡</title>
    <link href="http://yoursite.com/2020/05/31/%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/"/>
    <id>http://yoursite.com/2020/05/31/%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/</id>
    <published>2020-05-31T13:32:48.000Z</published>
    <updated>2020-05-31T14:47:12.805Z</updated>
    
    <content type="html"><![CDATA[<h1 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h1><ul><li><p>LB（load balance）：简单的说就是将用户请求平摊分配到多个服务器上，从而达到系统的高可用。</p></li><li><p>常见的负载均衡软件有nginx、lvx</p></li><li><p>常见分类</p><ul><li>集中式LB：在服务的消费方和服务方使用独立的Lb方式，如nginx，由它负责请求转发。</li><li>进程式LB：将LB逻辑集成到消费方，消费方从注册中心获取可用的服务，再从这里面选一个进行访问，如ribbon。</li></ul></li></ul><h2 id="ribbon-负载均衡"><a href="#ribbon-负载均衡" class="headerlink" title="ribbon 负载均衡"></a>ribbon 负载均衡</h2><pre><code class="hljs java"><span class="hljs-comment">// 配置类</span><span class="hljs-meta">@Configuration</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RestTemplateConfig</span> </span>&#123;    <span class="hljs-meta">@Bean</span>    <span class="hljs-meta">@LoadBalanced</span>    <span class="hljs-function">RestTemplate <span class="hljs-title">restTemplate</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> RestTemplate();    &#125;&#125;<span class="hljs-comment">// controller调用</span><span class="hljs-comment">// 第二版根据服务名去访问，需要将restTemplate注解为@LoadBalanced才会生效</span><span class="hljs-keyword">private</span> String service = <span class="hljs-string">"http://MYCLOUD-PROVIDER"</span>;<span class="hljs-meta">@RequestMapping</span>(<span class="hljs-string">"/consumer/corps/&#123;id&#125;"</span>)<span class="hljs-function">Corp <span class="hljs-title">getCorp</span><span class="hljs-params">(@PathVariable(<span class="hljs-string">"id"</span>)</span> String id) </span>&#123;  String url = service + <span class="hljs-string">"/corps/"</span>;  <span class="hljs-keyword">return</span> restTemplate.getForObject(url + id, Corp<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;&#125;</code></pre><blockquote><p>使用服务名去调用，restful风格</p></blockquote><h2 id="feign-负载均衡"><a href="#feign-负载均衡" class="headerlink" title="feign 负载均衡"></a>feign 负载均衡</h2><ul><li>feign是声明式的web service客户端，只需提供一个接口，添加注解就可以了。</li><li>feign是ribbon的封装，以面向对象方式的去访问。</li><li>feign不需要去显式的声明restTemplate</li></ul><blockquote><p>使用接口注解去调用</p></blockquote><pre><code class="hljs java"><span class="hljs-comment">// 逻辑处理类，映射路径为实际接口路径</span><span class="hljs-meta">@FeignClient</span>(name = <span class="hljs-string">"MYCLOUD-PROVIDER"</span>)<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">CorpConsumerService</span> </span>&#123;    <span class="hljs-meta">@GetMapping</span>(<span class="hljs-string">"/corps/&#123;id&#125;"</span>)    <span class="hljs-function">Corp <span class="hljs-title">getCorp</span><span class="hljs-params">(@PathVariable(<span class="hljs-string">"id"</span>)</span> String id)</span>;    <span class="hljs-meta">@GetMapping</span>(<span class="hljs-string">"/corps"</span>)    <span class="hljs-function">List&lt;Corp&gt; <span class="hljs-title">getCorps</span><span class="hljs-params">()</span></span>;&#125;<span class="hljs-comment">// 启动类配置enable</span><span class="hljs-meta">@SpringBootApplication</span><span class="hljs-meta">@EnableEurekaClient</span><span class="hljs-meta">@EnableFeignClients</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CorpConsumer8002</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        SpringApplication.run(CorpConsumer8002<span class="hljs-class">.<span class="hljs-keyword">class</span>, <span class="hljs-title">args</span>)</span>;    &#125;&#125;</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;负载均衡&quot;&gt;&lt;a href=&quot;#负载均衡&quot; class=&quot;headerlink&quot; title=&quot;负载均衡&quot;&gt;&lt;/a&gt;负载均衡&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;LB（load balance）：简单的说就是将用户请求平摊分配到多个服务器上，从而达到系统的高可用。&lt;/
      
    
    </summary>
    
    
      <category term="java" scheme="http://yoursite.com/categories/java/"/>
    
    
      <category term="springCloud ribbon" scheme="http://yoursite.com/tags/springCloud-ribbon/"/>
    
  </entry>
  
  <entry>
    <title>eureka对比zookeeper</title>
    <link href="http://yoursite.com/2020/05/31/eureka%E5%AF%B9%E6%AF%94zookeeper/"/>
    <id>http://yoursite.com/2020/05/31/eureka%E5%AF%B9%E6%AF%94zookeeper/</id>
    <published>2020-05-31T13:09:42.000Z</published>
    <updated>2020-06-09T14:52:36.481Z</updated>
    
    <content type="html"><![CDATA[<h1 id="cap原则"><a href="#cap原则" class="headerlink" title="cap原则"></a>cap原则</h1><h2 id="一、回顾"><a href="#一、回顾" class="headerlink" title="一、回顾"></a>一、回顾</h2><ul><li><p>ACID 原则</p><ul><li>关系数据库管理系统（Relational Database Management System：<em>RDBMS</em>），如mysql、oracle、sqlserver</li><li>A（atomicity）原子性</li><li>C（consistency）一致性</li><li>I（Isolation）隔离性</li><li>D（durability）持久性</li></ul></li><li><p>CAP原则</p><ul><li><p>一般用于redis、mongdb</p></li><li><p>C（consistency）一致性：</p><p>分布式环境下，一致性主要指数据在多个副本之间是否一致，（等同于所有节点访问同一份最新的数据副本）。</p><p>通过某个节点的写操作结果对后面通过其他节点的读操作可见，如果数据更新后并发访问情况下可立即感知其更新， 称为强一致性，如果允许之后部分或者全部感知不到该更新，称为弱一致性，若在之后一段时间后，一定可以感知该更新，称为最终一致性。</p></li><li><p>A（avaibility）可用性：</p><p>在集群中一部分节点故障后，集群整体是否还能响应客户端的读写请求。（对数据更新具备高可用性）</p></li><li><p>P（partition tolerance）分区容错性：</p><p>集群出现网络割裂时，集群还能继续提供一定的可用性和一致性，除非整个网络不可用，也即部分节点宕机或者无法与其他节点通信时，各分区间还可保持分布式系统的功能。</p></li></ul></li></ul><p><strong>著名的CAP理论指出，一个分布式系统不可能同时满足C(一致性)、A(可用性)和P(分区容错性)。由于分区容错性在是分布式系统中必须要保证的，因此我们只能在A和C之间进行权衡。zookeeper保证的是CP， 而eureka则是AP。</strong></p><ul><li><p>BASE理论</p><ul><li><p>BASE是Basically Available（基本可用）、Soft state（软状态）和Eventually consistent（最终一致性）三个短语的简写，BASE是对CAP中一致性和可用性权衡的结果，其来源于对大规模互联网系统分布式实践的结论，是基于CAP定理逐步演化而来的，其核心思想是即使无法做到强一致性（Strong consistency），但每个应用都可以根据自身的业务特点，采用适当的方式来使系统达到最终一致性（Eventual consistency）。</p></li><li><p>BASE之基本可用体现在两个方面： 1、响应时间上的损失：比如某些请求1秒内给出响应，有些请求可能会在5秒内给出响应 2、功能上的损失：例如对于电商系统来说，某些区域可能不能购买某些商品，又或者大促时，部分消费者被引流到降级页面。</p></li><li><p>BASE之弱状态： 也称为软状态，是指允许系统中的数据存在中间状态，并认为该状态不会影响系统的整体可用性，即允许系统在不同节点的数据副本之间存在一定的延时。</p></li><li><p>BASE之最终一致性： 系统中的数据副本在经过一段时间同步后，组中能够达到一个一致的状态。</p></li></ul></li></ul><h2 id="二、集群环境下如何保障数据一致性"><a href="#二、集群环境下如何保障数据一致性" class="headerlink" title="二、集群环境下如何保障数据一致性"></a>二、集群环境下如何保障数据一致性</h2><p>集群环境下有三种方式保障数据一致性：数据复制、WNR和集中存储。</p><p>1、数据复制：先向单节点写入，再复制到其他节点，zookeeper是这样实现的。或者多节点同时写入，但只适合多节点写入的数据不是相同数据的应用场景。在master-slave场景中， 同步复制（slave从master全部复制完成才给客户端返回写入成功）可保证强一致性，但会影响可用性；异步复制（数据写入master就返回写入成功，不需要等到slave复制完成， 之后master通过push向slave推送数据或者slave通过ull方式从master拉数据）可提供可用性但会降低一致性。</p><p>2、WNR：N代表总副本数，W代表每次写操作要保证的最少写成功的副本数，R代表每次读操作最少读取的副本数，当W+R&gt;N时，可保证每次读取的数据至少有一个副本具有最新的更新 （例如可以通过版本号或者时间戳判断是哪个副本的数据是最新的），多个写操作的顺序难以保证，可能导致多副本的写操作顺序不一致，Dynamo通过箱量时钟在保证最终一致性。</p><p>3、集中存储：借助可靠性较高的集中存储，比如NAS存储，分布式缓存（Redis）等。</p><h2 id="二、zookeeper保证的是CP"><a href="#二、zookeeper保证的是CP" class="headerlink" title="二、zookeeper保证的是CP"></a>二、zookeeper保证的是CP</h2><ul><li>放弃可用性，并不是完全没有可用性，是指允许响应超时的时间可以更长，比如报表可以运行10分钟左右，甚至在某些情况下允许超时。</li><li>Zookeeper会出现这样一种情况，当master节点因为网络故障与其他节点失去联系时，剩余节点会重新进行leader选举。问题在于，选举leader的时间太长，30 ~ 120s, 且选举期间整个Zookeeper集群都是不可用的，这就导致在选举期间注册服务瘫痪。在云部署的环境下，因网络问题使得Zookeeper集群失去master节点是较大概率会发生的事，虽然服务能够最终恢复，但是漫长的选举时间导致的注册长期不可用是不能容忍的。</li></ul><p><strong>zk集群：</strong></p><p>1、zk集群是一种对等集群，所有节点（机器）数据都一样。</p><p>2、集群节点之间靠心跳感知彼此的存在。 </p><p>3、所有写操作都在主节点，其他节点只能读，虽然也可以接收写请求，但是内部会把写操作转给主节点。 </p><p>4、通过选举机制选出主节点，从而保障了主节点的高可用，这样主节点就不是固定的，万一主节点宕机还可以重新选举出主节点。 </p><p>5、至少需要三个节点，而且节点个数必须是奇数。 </p><p>6、当一半以上的数据写入成功后，则返回写入成功，是最终一致性策略。</p><h2 id="三、eureka保证的是AP"><a href="#三、eureka保证的是AP" class="headerlink" title="三、eureka保证的是AP"></a>三、eureka保证的是AP</h2><ul><li><p>放弃一致性是放弃数据的强一致性，而保留数据的最终一致性，即数据最终是完全一致的，但有一个时间窗口的问题，这需要根据不同的业务来定义。</p></li><li><p>当向注册中心查询服务列表时，我们可以容忍注册中心返回的是几分钟以前的注册信息，但不能接受服务直接down掉不可用。也就是说，服务注册功能对可用性的要求要高于一致性。</p></li><li><p>Eureka在设计时就优先保证可用性。Eureka各个节点都是平等的，几个节点挂掉不会影响正常节点的工作，剩余的节点依然可以提供注册和查询服务。而Eureka的客户端在向某个Eureka注册或时如果发现连接失败，则会自动切换至其它节点，只要有一台Eureka还在，就能保证注册服务可用(保证可用性)，只不过查到的信息可能不是最新的(不保证强一致性)。</p></li><li><p>除此之外，Eureka还有一种自我保护机制，如果在15分钟内超过85%的节点都没有正常的心跳，那么Eureka就认为客户端与注册中心出现了网络故障，此时会出现以下几种情况：</p><ol><li>Eureka不再从注册列表中移除因为长时间没收到心跳而应该过期的服务。</li><li>Eureka仍然能够接受新服务的注册和查询请求，但是不会被同步到其它节点上(即保证当前节点依然可用) 。</li><li>当网络稳定时，当前实例新的注册信息会被同步到其它节点中。因此， Eureka可以很好的应对因网络故障导致部分节点失去联系的情况，而不会像zookeeper那样使整个注册服务瘫痪。</li></ol></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;cap原则&quot;&gt;&lt;a href=&quot;#cap原则&quot; class=&quot;headerlink&quot; title=&quot;cap原则&quot;&gt;&lt;/a&gt;cap原则&lt;/h1&gt;&lt;h2 id=&quot;一、回顾&quot;&gt;&lt;a href=&quot;#一、回顾&quot; class=&quot;headerlink&quot; title=&quot;一、回顾&quot;
      
    
    </summary>
    
    
      <category term="springCloud" scheme="http://yoursite.com/categories/springCloud/"/>
    
    
      <category term="eureka zookeeper" scheme="http://yoursite.com/tags/eureka-zookeeper/"/>
    
  </entry>
  
</feed>

<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>mybatis-generator</title>
    <link href="/blog/2020/06/02/mybatis-generator/"/>
    <url>/blog/2020/06/02/mybatis-generator/</url>
    
    <content type="html"><![CDATA[<h2 id="1-作用"><a href="#1-作用" class="headerlink" title="1.作用"></a>1.作用</h2><p>用来自动生成MyBatis的 mapper、dao、entity </p><h2 id="2-使用"><a href="#2-使用" class="headerlink" title="2.使用"></a>2.使用</h2><p>MyBatis Generator的使用方式有4种：</p><ul><li>命令行生成</li><li>Maven方式生成</li><li>使用Ant任务生成</li><li>使用Java代码生成</li></ul><p>其中推荐使用Maven方式进行代码生成，因为集成和使用比较简单。</p><h2 id="3-代码自动生成配置"><a href="#3-代码自动生成配置" class="headerlink" title="3.代码自动生成配置"></a>3.代码自动生成配置</h2><h3 id="Step1：配置pom中plugin依赖"><a href="#Step1：配置pom中plugin依赖" class="headerlink" title="Step1：配置pom中plugin依赖"></a>Step1：配置pom中plugin依赖</h3><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">plugin</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.mybatis.generator<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mybatis-generator-maven-plugin<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.4.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">executions</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">execution</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">id</span>&gt;</span>Generate MyBatis Artifacts<span class="hljs-tag">&lt;/<span class="hljs-name">id</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">phase</span>&gt;</span>package<span class="hljs-tag">&lt;/<span class="hljs-name">phase</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">goals</span>&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">goal</span>&gt;</span>generate<span class="hljs-tag">&lt;/<span class="hljs-name">goal</span>&gt;</span>            <span class="hljs-tag">&lt;/<span class="hljs-name">goals</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">execution</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">executions</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">configuration</span>&gt;</span>        <span class="hljs-comment">&lt;!--允许移动生成的文件 --&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">verbose</span>&gt;</span>true<span class="hljs-tag">&lt;/<span class="hljs-name">verbose</span>&gt;</span>        <span class="hljs-comment">&lt;!-- 是否覆盖 --&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">overwrite</span>&gt;</span>true<span class="hljs-tag">&lt;/<span class="hljs-name">overwrite</span>&gt;</span>        <span class="hljs-comment">&lt;!-- 自动生成的配置 --&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">configurationFile</span>&gt;</span>src/main/resources/generatorConfig.xml<span class="hljs-tag">&lt;/<span class="hljs-name">configurationFile</span>&gt;</span>        <span class="hljs-comment">&lt;!--将当前pom的依赖项添加到生成器的类路径中--&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">includeCompileDependencies</span>&gt;</span>true<span class="hljs-tag">&lt;/<span class="hljs-name">includeCompileDependencies</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">configuration</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">plugin</span>&gt;</span></code></pre><h3 id="Step2：配置generatorConfig-xml文件"><a href="#Step2：配置generatorConfig-xml文件" class="headerlink" title="Step2：配置generatorConfig.xml文件"></a>Step2：配置generatorConfig.xml文件</h3><pre><code class="hljs dust"><span class="xml"><span class="hljs-meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><span class="xml"><span class="hljs-comment">&lt;!--mybatis的代码生成器相关配置--&gt;</span></span><span class="xml"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">generatorConfiguration</span></span></span><span class="xml">        PUBLIC "-//mybatis.org//DTD MyBatis Generator Configuration 1.0//EN"</span><span class="xml">        "http://mybatis.org/dtd/mybatis-generator-config_1_0.dtd"&gt;</span><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">generatorConfiguration</span>&gt;</span></span><span class="xml">    <span class="hljs-comment">&lt;!-- 引入配置文件 --&gt;</span></span><span class="xml">    <span class="hljs-tag">&lt;<span class="hljs-name">properties</span> <span class="hljs-attr">resource</span>=<span class="hljs-string">"application.yml"</span>/&gt;</span>   </span><span class="xml">    <span class="hljs-tag">&lt;<span class="hljs-name">context</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"Mysql"</span> <span class="hljs-attr">targetRuntime</span>=<span class="hljs-string">"MyBatis3Simple"</span> <span class="hljs-attr">defaultModelType</span>=<span class="hljs-string">"flat"</span>&gt;</span></span><span class="xml">        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"autoDelimitKeywords"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"true"</span> /&gt;</span></span><span class="xml">        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"beginningDelimiter"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"`"</span> /&gt;</span></span><span class="xml">        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"endingDelimiter"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"`"</span> /&gt;</span></span><span class="xml">        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"javaFileEncoding"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"utf-8"</span> /&gt;</span></span><span class="xml">        <span class="hljs-tag">&lt;<span class="hljs-name">plugin</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"org.mybatis.generator.plugins.SerializablePlugin"</span> /&gt;</span></span><span class="xml">        <span class="hljs-tag">&lt;<span class="hljs-name">commentGenerator</span> &gt;</span></span><span class="xml">            <span class="hljs-comment">&lt;!-- 不生成注释 --&gt;</span></span><span class="xml">            <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"suppressAllComments"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"true"</span>/&gt;</span></span><span class="xml">            <span class="hljs-comment">&lt;!-- 不生成注释代时间戳--&gt;</span></span><span class="xml">            <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"suppressDate"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"true"</span> /&gt;</span></span><span class="xml">        <span class="hljs-tag">&lt;/<span class="hljs-name">commentGenerator</span>&gt;</span></span><span class="xml">        <span class="hljs-comment">&lt;!--数据库链接地址账号密码--&gt;</span></span><span class="xml">        <span class="hljs-comment">&lt;!--&lt;jdbcConnection driverClass="$</span></span><span class="hljs-template-variable">&#123;spring.datasource.driver-class-name&#125;</span><span class="xml"><span class="hljs-comment">"--&gt;</span></span><span class="xml">                        <span class="hljs-comment">&lt;!--connectionURL="$</span></span><span class="hljs-template-variable">&#123;spring.datasource.url&#125;</span><span class="xml"><span class="hljs-comment">"--&gt;</span></span><span class="xml">                        <span class="hljs-comment">&lt;!--userId="$</span></span><span class="hljs-template-variable">&#123;spring.datasource.username&#125;</span><span class="xml"><span class="hljs-comment">"--&gt;</span></span><span class="xml">                        <span class="hljs-comment">&lt;!--password="$</span></span><span class="hljs-template-variable">&#123;spring.datasource.password&#125;</span><span class="xml"><span class="hljs-comment">"&gt;--&gt;</span></span><span class="xml">        <span class="hljs-comment">&lt;!--&lt;/jdbcConnection&gt;--&gt;</span></span><span class="xml">        <span class="hljs-tag">&lt;<span class="hljs-name">jdbcConnection</span> <span class="hljs-attr">driverClass</span>=<span class="hljs-string">"com.mysql.cj.jdbc.Driver"</span></span></span><span class="xml">            connectionURL="jdbc:mysql://localhost:3306/display"</span><span class="xml">            userId="root"</span><span class="xml">            password="P@ssw0rd"&gt;</span><span class="xml">        <span class="hljs-tag">&lt;/<span class="hljs-name">jdbcConnection</span>&gt;</span></span><span class="xml">        <span class="hljs-comment">&lt;!-- 类型转换 --&gt;</span></span><span class="xml">        <span class="hljs-tag">&lt;<span class="hljs-name">javaTypeResolver</span>&gt;</span></span><span class="xml">            <span class="hljs-comment">&lt;!-- 是否使用bigDecimal， false可自动转化以下类型（Long, Integer, Short, etc.） --&gt;</span></span><span class="xml">            <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"forceBigDecimals"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"false"</span>/&gt;</span></span><span class="xml">        <span class="hljs-tag">&lt;/<span class="hljs-name">javaTypeResolver</span>&gt;</span></span><span class="xml">        <span class="hljs-comment">&lt;!--生成Model类存放位置--&gt;</span></span><span class="xml">        <span class="hljs-tag">&lt;<span class="hljs-name">javaModelGenerator</span> <span class="hljs-attr">targetPackage</span>=<span class="hljs-string">"com.ztf.mybatisplus.bean"</span> <span class="hljs-attr">targetProject</span>=<span class="hljs-string">"src/main/java"</span>&gt;</span></span><span class="xml">            <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"enableSubPackages"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"true"</span>/&gt;</span></span><span class="xml">            <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"trimStrings"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"true"</span>/&gt;</span></span><span class="xml">        <span class="hljs-tag">&lt;/<span class="hljs-name">javaModelGenerator</span>&gt;</span></span><span class="xml">        <span class="hljs-comment">&lt;!-- 生成mapxml文件 --&gt;</span></span><span class="xml">        <span class="hljs-tag">&lt;<span class="hljs-name">sqlMapGenerator</span> <span class="hljs-attr">targetPackage</span>=<span class="hljs-string">"mapper"</span> <span class="hljs-attr">targetProject</span>=<span class="hljs-string">"src/main/resources/mybatis"</span> &gt;</span></span><span class="xml">            <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"enableSubPackages"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"false"</span> /&gt;</span></span><span class="xml">        <span class="hljs-tag">&lt;/<span class="hljs-name">sqlMapGenerator</span>&gt;</span></span><span class="xml">        <span class="hljs-comment">&lt;!-- 生成mapper java文件 --&gt;</span></span><span class="xml">        <span class="hljs-tag">&lt;<span class="hljs-name">javaClientGenerator</span> <span class="hljs-attr">targetPackage</span>=<span class="hljs-string">"com.ztf.mybatisplus.dao"</span> <span class="hljs-attr">targetProject</span>=<span class="hljs-string">"src/main/java"</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"XMLMAPPER"</span> &gt;</span></span><span class="xml">            <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"enableSubPackages"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"false"</span> /&gt;</span></span><span class="xml">        <span class="hljs-tag">&lt;/<span class="hljs-name">javaClientGenerator</span>&gt;</span></span><span class="xml"><span class="hljs-comment">&lt;!--具体解析的表，建议配置domainObjectName属性，避免带上表前缀T_--&gt;</span></span><span class="xml">        <span class="hljs-tag">&lt;<span class="hljs-name">table</span> <span class="hljs-attr">tableName</span>=<span class="hljs-string">"t_corp"</span> <span class="hljs-attr">enableCountByExample</span>=<span class="hljs-string">"true"</span> <span class="hljs-attr">domainObjectName</span>=<span class="hljs-string">"Corp"</span></span></span><span class="xml">               enableUpdateByExample="true" enableDeleteByExample="true"</span><span class="xml">               enableSelectByExample="true" selectByExampleQueryId="true"&gt;</span><span class="xml">            <span class="hljs-comment">&lt;!--&lt;generatedKey column="id" sqlStatement="Mysql" identity="true" /&gt;--&gt;</span></span><span class="xml">        <span class="hljs-tag">&lt;/<span class="hljs-name">table</span>&gt;</span></span><span class="xml">        <span class="hljs-comment">&lt;!--&lt;table tableName="user_log" enableCountByExample="true" --&gt;</span></span><span class="xml">               <span class="hljs-comment">&lt;!--enableUpdateByExample="true" enableDeleteByExample="true" --&gt;</span></span><span class="xml">               <span class="hljs-comment">&lt;!--enableSelectByExample="true" selectByExampleQueryId="true"&gt;--&gt;</span></span><span class="xml">            <span class="hljs-comment">&lt;!--&lt;generatedKey column="id" sqlStatement="Mysql" identity="true" /&gt;--&gt;</span></span><span class="xml">        <span class="hljs-comment">&lt;!--&lt;/table&gt;--&gt;</span></span><span class="xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">context</span>&gt;</span></span><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">generatorConfiguration</span>&gt;</span></span></code></pre><h2 id="4-注意事项"><a href="#4-注意事项" class="headerlink" title="4.注意事项"></a>4.注意事项</h2><ul><li>MyBatis Generator 只会覆盖旧的 po、dao、而 mapper.xml 不会覆盖，而是追加，这样做的目的是防止用户自己写的 sql 语句一不小心都被 MyBatis Generator 给覆盖了</li></ul><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- 是否覆盖 --&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">overwrite</span>&gt;</span>true<span class="hljs-tag">&lt;/<span class="hljs-name">overwrite</span>&gt;</span></code></pre><ul><li>一般配置了 <strong>includeCompileDependencies</strong> 后就不需要配置其他依赖了，因为 <strong>includeCompileDependencies</strong> 会将当前 pom 的 <strong>dependencies</strong> 中所有 <strong>Compile</strong> 期的依赖全部添加到生成器的类路径中。</li></ul><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--将当前pom的依赖项添加到生成器的类路径中--&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">includeCompileDependencies</span>&gt;</span>true<span class="hljs-tag">&lt;/<span class="hljs-name">includeCompileDependencies</span>&gt;</span></code></pre><ul><li>数据库文件yml方式加载不进来配置，写成<code>application.properties&quot;</code>方式就可以</li></ul><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- 引入配置文件 --&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">properties</span> <span class="hljs-attr">resource</span>=<span class="hljs-string">"application-dev.properties"</span>/&gt;</span></code></pre><ul><li>context属性</li></ul><pre><code class="hljs xml">id : 随便填，保证多个 context id 不重复就行defaultModelType ： 可以不填，默认值 conditional，flat表示一张表对应一个potargetRuntime ：可以不填，默认值 MyBatis3，常用的还有 MyBatis3Simple。MyBatis3Simple生成的 dao 和 mapper.xml 内容较少，但也包含了最常用的。</code></pre><ul><li>context的子元素要求有序</li></ul><pre><code class="hljs angelscript"><span class="hljs-number">1.</span> **<span class="hljs-keyword">property</span>** (<span class="hljs-number">0.</span>.N)<span class="hljs-number">2.</span> **plugin** (<span class="hljs-number">0.</span>.N)<span class="hljs-number">3.</span> **commentGenerator** (<span class="hljs-number">0</span> <span class="hljs-keyword">or</span> <span class="hljs-number">1</span>)<span class="hljs-number">4.</span> **jdbcConnection** (需要connectionFactory 或 jdbcConnection)<span class="hljs-number">5.</span> **javaTypeResolver** (<span class="hljs-number">0</span> <span class="hljs-keyword">or</span> <span class="hljs-number">1</span>)<span class="hljs-number">6.</span> **javaModelGenerator** (至少<span class="hljs-number">1</span>个)<span class="hljs-number">7.</span> **sqlMapGenerator** (<span class="hljs-number">0</span> <span class="hljs-keyword">or</span> <span class="hljs-number">1</span>)<span class="hljs-number">8.</span> **javaClientGenerator** (<span class="hljs-number">0</span> <span class="hljs-keyword">or</span> <span class="hljs-number">1</span>)<span class="hljs-number">9.</span> **table** (<span class="hljs-number">1.</span>.N)</code></pre><ul><li>commentGenerator 默认生成注释和时间戳，可显式的声明某一项不生成。<strong>建议全部显式不生成。</strong></li></ul><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">commentGenerator</span>&gt;</span>    <span class="hljs-comment">&lt;!-- 不希望生成的注释中包含时间戳 --&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"suppressDate"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"true"</span>/&gt;</span>    <span class="hljs-comment">&lt;!-- 不希望生成的注释中包含注释 --&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"suppressAllComments"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"true"</span>/&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">commentGenerator</span>&gt;</span></code></pre><ul><li><code>type=&quot;XMLMAPPER&quot;</code> 会将接口的实现放在 mapper.xml中，也推荐这样配置。也可以设置  <code>type=&quot;ANNOTATEDMAPPER&quot;</code>，接口的实现通过注解写在接口上面</li><li>一个 table 对应一张表，如果想同时生成多张表，需要配置多个 table</li><li><strong>domainObjectName</strong> 不配置时，它会按照帕斯卡命名法将表名转换成类名，建议配置该属性，避免带上表前缀T_</li></ul><pre><code class="hljs routeros">&lt;domainObjectRenamingRule <span class="hljs-attribute">searchString</span>=<span class="hljs-string">"^T"</span> <span class="hljs-attribute">replaceString</span>=<span class="hljs-string">""</span> /&gt;</code></pre><ul><li>表字段也会默认带上<code>c_</code>、<code>d_</code>，可设置去掉</li></ul><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- 这个意思就是匹配，开头的任意个非下划线(_)的字符，也就是这种如：c_，d_ 等等 --&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">columnRenamingRule</span> <span class="hljs-attr">searchString</span>=<span class="hljs-string">"^[^_]+"</span> <span class="hljs-attr">replaceString</span>=<span class="hljs-string">""</span>/&gt;</span>  <span class="hljs-comment">&lt;!-- 也可如下只去掉c_--&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">columnRenamingRule</span> <span class="hljs-attr">searchString</span>=<span class="hljs-string">"^c_"</span> <span class="hljs-attr">replaceString</span>=<span class="hljs-string">""</span> /&gt;</span></code></pre><ul><li><strong>enableXXXByExample</strong> 默认为true，但只有在<code>targetRuntime=&quot;MyBatis3&quot;</code>时才生效。当 <code>targetRuntime=&quot;MyBatis3Simple&quot;</code>时，<strong>enableXXXByExample</strong> 不管为true、还是false 都不生效。一般建议全设置为false，true的话会生成很多Example帮助类，造成很多sonar问题。</li></ul><h2 id="4-参考"><a href="#4-参考" class="headerlink" title="4.参考"></a>4.参考</h2><p><a href="https://segmentfault.com/a/1190000016570268" target="_blank" rel="noopener">Spring Boot （七）MyBatis代码自动生成和辅助插件</a></p><p><a href="https://juejin.im/post/5db694e3e51d452a2e25ba45" target="_blank" rel="noopener">MyBatis Generator 超详细配置</a></p>]]></content>
    
    
    <categories>
      
      <category>mybatis</category>
      
    </categories>
    
    
    <tags>
      
      <tag>mybatis-generator</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>性能优化策略</title>
    <link href="/blog/2020/06/01/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E7%AD%96%E7%95%A5/"/>
    <url>/blog/2020/06/01/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E7%AD%96%E7%95%A5/</url>
    
    <content type="html"><![CDATA[<h2 id="一、时空转换"><a href="#一、时空转换" class="headerlink" title="一、时空转换"></a>一、时空转换</h2><h3 id="1-1-时间换空间"><a href="#1-1-时间换空间" class="headerlink" title="1.1 时间换空间"></a>1.1 时间换空间</h3><ul><li>场景1: 降低内存空间的占用。</li><li>场景2: 降低数据的大小来方便网络传输和外部存储。</li></ul><p>具体方式：</p><p>1、改变数据结构或者数据格式，减少要存储的数据大小。</p><p>2、使用压缩算法，压缩内存中的数据，使用时解压。</p><p>3、把内存中的数据存储到外部的、更便宜的存储设备中，需要时再取回来。</p><blockquote><p>这些节省内存空间的方法，一般都需要付出时间的代价。</p></blockquote><blockquote><p>衡量任何压缩算法，基本上看三个指标：压缩比例、压缩速度以及使用内存。</p></blockquote><blockquote><p>如果系统的瓶颈在<strong>网络传输速度或者存储空间大小</strong>上，那就尽量采取高压缩比的算法。</p></blockquote><h3 id="1-2-空间换时间"><a href="#1-2-空间换时间" class="headerlink" title="1.2 空间换时间"></a>1.2 空间换时间</h3><ul><li>场景：要求快速响应。</li></ul><p>具体方式：</p><p>1、对数据和服务进行多份拷贝，尽大可能的覆盖更多的用户。</p><blockquote><p>典型案例：集群</p></blockquote><h2 id="二、预处理和延后处理"><a href="#二、预处理和延后处理" class="headerlink" title="二、预处理和延后处理"></a>二、预处理和延后处理</h2><h3 id="2-1-预处理-提前处理"><a href="#2-1-预处理-提前处理" class="headerlink" title="2.1 预处理/提前处理"></a>2.1 预处理/提前处理</h3><p>使用场景：</p><p>1、web静态资源提前加载，preload 和 prefetch。</p><p>2、文件系统预读功能。提前从磁盘读取下一次的数据。</p><blockquote><p>这个功能对顺序读取十分有效，可以减少磁盘请求的数量</p></blockquote><h3 id="2-2-延后-惰性处理"><a href="#2-2-延后-惰性处理" class="headerlink" title="2.2 延后/惰性处理"></a>2.2 延后/惰性处理</h3><ul><li>尽量将操作推迟到必须执行的时刻。</li></ul><p>使用场景：</p><p>1、COW（copy on write）写时复制。多线程读取共享资源时，不进行复制操作，当某个线程需要对资源进行修改时，才拷贝一份到工作内存，使其不会影响其他线程。</p><h2 id="三、并行和并发"><a href="#三、并行和并发" class="headerlink" title="三、并行和并发"></a>三、并行和并发</h2><h2 id="四、缓存-批量合并"><a href="#四、缓存-批量合并" class="headerlink" title="四、缓存/批量合并"></a>四、缓存/批量合并</h2><h3 id="4-1-缓存"><a href="#4-1-缓存" class="headerlink" title="4.1 缓存"></a>4.1 缓存</h3><ul><li>缓存的本质是加速访问。</li></ul><p>使用场景：</p><p>1、对于一个基于 Web 的应用服务，前端会有浏览器缓存，有 CDN 存放在边缘服务器上，有反向代理提供的静态内容缓存；后端则还会有服务器本地缓存。</p><p>2、程序设计中，对于可能重复创建和销毁，且创建销毁代价很大的对象（比如套接字和线程），也可以缓存，对应的缓存形式，就是连接池和线程池等。</p><p>3、对于消耗较大的计算，也可以将计算结果缓存起来，下次可以直接读取结果。比如对递归代码的一个有效优化手段，就是缓存中间结果。</p><h3 id="4-2批量合并"><a href="#4-2批量合并" class="headerlink" title="4.2批量合并"></a>4.2批量合并</h3><ul><li>在有 IO（比如网络 IO 和磁盘 IO）的时候，合并操作和批量操作往往能提升吞吐量，提高性能。</li></ul><p>使用场景：</p><p>1、批量 IO 读写。就是在有多次 IO 的时候，可以把它们合并成一次读写数据。这样可以减少读写时间和协议负担。</p><p>2、对数据库的读写操作，也可以尽量合并。比如，对键值数据库的查询，最好一次查询多个键，而不要分成多次。</p><p>3、涉及到网络请求的时候，网络传输的时间可能远大于请求的处理时间，因此合并网络请求也很有必要。</p><h2 id="五、更高效的算法和数据结构"><a href="#五、更高效的算法和数据结构" class="headerlink" title="五、更高效的算法和数据结构"></a>五、更高效的算法和数据结构</h2><h2 id="附录："><a href="#附录：" class="headerlink" title="附录："></a>附录：</h2><p><a href="https://www.toutiao.com/i6832247243278385671/" target="_blank" rel="noopener">参考文档</a></p>]]></content>
    
    
    <categories>
      
      <category>总结</category>
      
    </categories>
    
    
    <tags>
      
      <tag>性能优化</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>服务熔断</title>
    <link href="/blog/2020/05/31/%E6%9C%8D%E5%8A%A1%E7%86%94%E6%96%AD/"/>
    <url>/blog/2020/05/31/%E6%9C%8D%E5%8A%A1%E7%86%94%E6%96%AD/</url>
    
    <content type="html"><![CDATA[<h1 id="服务熔断"><a href="#服务熔断" class="headerlink" title="服务熔断"></a>服务熔断</h1><ul><li>hystrix，是一个用于处理分布式系统延迟和容错的库，它能够保证在一个子服务出问题的情况下，不会导致整体服务失败，避免级联雪崩，以提高分布式系统的弹性。</li><li>“断路器”本身是一个开关装置，当某个服务单元发生故障后，向调用方返回一个服务预期的、可处理的备选响应，而不是长时间等待或者抛出一个服务端无法处理的异常。这样就保证了调用方线程不会被长时间占用，从而避免故障在分布式系统中蔓延，甚至雪崩。</li></ul><h2 id="1、服务降级（客户端提供异常响应）"><a href="#1、服务降级（客户端提供异常响应）" class="headerlink" title="1、服务降级（客户端提供异常响应）"></a>1、服务降级（客户端提供异常响应）</h2><ul><li>限制其他低相关服务的访问，使他们占用计算机较少的资源，从而保障主服务拥有更多的资源，使其能正常访问。</li></ul><pre><code class="hljs java"><span class="hljs-comment">// 配置文件默认关闭，需手动开启</span>feign:  hystrix:    enabled: true # 启用服务降级<span class="hljs-meta">@FeignClient</span>(name = <span class="hljs-string">"MYCLOUD-PROVIDER"</span>, fallback = HystrixConsumerService<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span><span class="hljs-class"><span class="hljs-title">public</span> <span class="hljs-title">interface</span> <span class="hljs-title">CorpConsumerService</span> </span>&#123;    <span class="hljs-meta">@GetMapping</span>(<span class="hljs-string">"/corps/&#123;id&#125;"</span>)    <span class="hljs-function">Corp <span class="hljs-title">getCorp</span><span class="hljs-params">(@PathVariable(<span class="hljs-string">"id"</span>)</span> String id)</span>;    <span class="hljs-meta">@GetMapping</span>(<span class="hljs-string">"/corps"</span>)    <span class="hljs-function">List&lt;Corp&gt; <span class="hljs-title">getCorps</span><span class="hljs-params">()</span></span>;&#125;<span class="hljs-comment">// 客户端熔断回调缺省值处理</span><span class="hljs-comment">// 假设服务端未启动，即这么处理</span><span class="hljs-meta">@Service</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HystrixConsumerService</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">CorpConsumerService</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> Corp <span class="hljs-title">getCorp</span><span class="hljs-params">(String id)</span> </span>&#123;        <span class="hljs-keyword">return</span> Corp.builder().id(id).name(<span class="hljs-string">"HystrixConsumerService"</span>).age(<span class="hljs-number">40</span>).build();    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;Corp&gt; <span class="hljs-title">getCorps</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;    &#125;&#125;</code></pre><h2 id="2、服务熔断（服务端返回合适的异常响应）"><a href="#2、服务熔断（服务端返回合适的异常响应）" class="headerlink" title="2、服务熔断（服务端返回合适的异常响应）"></a>2、服务熔断（服务端返回合适的异常响应）</h2><ul><li>熔断机制是对微服务雪崩效应的一种链路保护机制。</li><li>当扇出链路的某个微服务不可用或者响应时间太长时，会进行服务的降级，<strong>进而熔断该节点的微服务调用，快速返回错误的响应信息，当检测到该微服务调用响应正常后恢复调用链路。</strong></li><li>hystrix会监控微服务之间的调用状况，当失败的调用到一定阈值，缺省是5s内20ci调用失败就会触发。熔断机制的注解是@HystrixCommand。</li></ul><pre><code class="hljs java"><span class="hljs-comment">// 启动类配置enable</span><span class="hljs-meta">@SpringBootApplication</span><span class="hljs-meta">@EnableEurekaClient</span><span class="hljs-meta">@EnableHystrix</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CorpProvider8005</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        SpringApplication.run(CorpProvider8005<span class="hljs-class">.<span class="hljs-keyword">class</span>, <span class="hljs-title">args</span>)</span>;    &#125;&#125;<span class="hljs-comment">// 添加@HystrixCommand注解</span><span class="hljs-comment">// 发生异常时，会调用hystrixCorp方法，控制台无异常堆栈</span><span class="hljs-meta">@GetMapping</span>(<span class="hljs-string">"/corps/&#123;id&#125;"</span>)<span class="hljs-meta">@HystrixCommand</span>(fallbackMethod = <span class="hljs-string">"hystrixCorp"</span>)<span class="hljs-function">Corp <span class="hljs-title">getCorp</span><span class="hljs-params">(@PathVariable(<span class="hljs-string">"id"</span>)</span> String id) </span>&#123;  Corp corp = corpService.getCorp(id);  <span class="hljs-keyword">if</span> (corp == <span class="hljs-keyword">null</span>) &#123;    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(<span class="hljs-string">"id "</span> + id + <span class="hljs-string">" 不存在"</span>);  &#125;  <span class="hljs-keyword">return</span> corp;&#125;<span class="hljs-function">Corp <span class="hljs-title">hystrixCorp</span><span class="hljs-params">(@PathVariable(<span class="hljs-string">"id"</span>)</span> String id) </span>&#123;  <span class="hljs-keyword">return</span> Corp.builder().id(id).name(<span class="hljs-string">"hystrix"</span>).age(<span class="hljs-number">30</span>).build();&#125;</code></pre><h2 id="3、服务限流"><a href="#3、服务限流" class="headerlink" title="3、服务限流"></a>3、服务限流</h2><h2 id="4、实时监控"><a href="#4、实时监控" class="headerlink" title="4、实时监控"></a>4、实时监控</h2>]]></content>
    
    
    <categories>
      
      <category>java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>springCloud hystrix</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>负载均衡</title>
    <link href="/blog/2020/05/31/%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/"/>
    <url>/blog/2020/05/31/%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/</url>
    
    <content type="html"><![CDATA[<h1 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h1><ul><li><p>LB（load balance）：简单的说就是将用户请求平摊分配到多个服务器上，从而达到系统的高可用。</p></li><li><p>常见的负载均衡软件有nginx、lvx</p></li><li><p>常见分类</p><ul><li>集中式LB：在服务的消费方和服务方使用独立的Lb方式，如nginx，由它负责请求转发。</li><li>进程式LB：将LB逻辑集成到消费方，消费方从注册中心获取可用的服务，再从这里面选一个进行访问，如ribbon。</li></ul></li></ul><h2 id="ribbon-负载均衡"><a href="#ribbon-负载均衡" class="headerlink" title="ribbon 负载均衡"></a>ribbon 负载均衡</h2><pre><code class="hljs java"><span class="hljs-comment">// 配置类</span><span class="hljs-meta">@Configuration</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RestTemplateConfig</span> </span>&#123;    <span class="hljs-meta">@Bean</span>    <span class="hljs-meta">@LoadBalanced</span>    <span class="hljs-function">RestTemplate <span class="hljs-title">restTemplate</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> RestTemplate();    &#125;&#125;<span class="hljs-comment">// controller调用</span><span class="hljs-comment">// 第二版根据服务名去访问，需要将restTemplate注解为@LoadBalanced才会生效</span><span class="hljs-keyword">private</span> String service = <span class="hljs-string">"http://MYCLOUD-PROVIDER"</span>;<span class="hljs-meta">@RequestMapping</span>(<span class="hljs-string">"/consumer/corps/&#123;id&#125;"</span>)<span class="hljs-function">Corp <span class="hljs-title">getCorp</span><span class="hljs-params">(@PathVariable(<span class="hljs-string">"id"</span>)</span> String id) </span>&#123;  String url = service + <span class="hljs-string">"/corps/"</span>;  <span class="hljs-keyword">return</span> restTemplate.getForObject(url + id, Corp<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;&#125;</code></pre><blockquote><p>使用服务名去调用，restful风格</p></blockquote><h2 id="feign-负载均衡"><a href="#feign-负载均衡" class="headerlink" title="feign 负载均衡"></a>feign 负载均衡</h2><ul><li>feign是声明式的web service客户端，只需提供一个接口，添加注解就可以了。</li><li>feign是ribbon的封装，以面向对象方式的去访问。</li><li>feign不需要去显式的声明restTemplate</li></ul><blockquote><p>使用接口注解去调用</p></blockquote><pre><code class="hljs java"><span class="hljs-comment">// 逻辑处理类，映射路径为实际接口路径</span><span class="hljs-meta">@FeignClient</span>(name = <span class="hljs-string">"MYCLOUD-PROVIDER"</span>)<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">CorpConsumerService</span> </span>&#123;    <span class="hljs-meta">@GetMapping</span>(<span class="hljs-string">"/corps/&#123;id&#125;"</span>)    <span class="hljs-function">Corp <span class="hljs-title">getCorp</span><span class="hljs-params">(@PathVariable(<span class="hljs-string">"id"</span>)</span> String id)</span>;    <span class="hljs-meta">@GetMapping</span>(<span class="hljs-string">"/corps"</span>)    <span class="hljs-function">List&lt;Corp&gt; <span class="hljs-title">getCorps</span><span class="hljs-params">()</span></span>;&#125;<span class="hljs-comment">// 启动类配置enable</span><span class="hljs-meta">@SpringBootApplication</span><span class="hljs-meta">@EnableEurekaClient</span><span class="hljs-meta">@EnableFeignClients</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CorpConsumer8002</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        SpringApplication.run(CorpConsumer8002<span class="hljs-class">.<span class="hljs-keyword">class</span>, <span class="hljs-title">args</span>)</span>;    &#125;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>springCloud ribbon</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>eureka对比zookeeper</title>
    <link href="/blog/2020/05/31/eureka%E5%AF%B9%E6%AF%94zookeeper/"/>
    <url>/blog/2020/05/31/eureka%E5%AF%B9%E6%AF%94zookeeper/</url>
    
    <content type="html"><![CDATA[<h1 id="cap原则"><a href="#cap原则" class="headerlink" title="cap原则"></a>cap原则</h1><h2 id="一、回顾"><a href="#一、回顾" class="headerlink" title="一、回顾"></a>一、回顾</h2><ul><li><p>ACID 原则</p><ul><li>关系数据库管理系统（Relational Database Management System：<em>RDBMS</em>），如mysql、oracle、sqlserver</li><li>A（atomicity）原子性</li><li>C（consistency）一致性</li><li>I（Isolation）隔离性</li><li>D（durability）持久性</li></ul></li><li><p>CAP原则</p><ul><li><p>一般用于redis、mongdb</p></li><li><p>C（consistency）一致性</p></li><li><p>A（avaibility）可用性</p></li><li><p>P（partition tolerance）分区容错性</p></li></ul></li></ul><blockquote><p>由于P 分区容错性在分布式系统中是必须要满足的，所以只能在c、a之间权衡</p></blockquote><h2 id="二、zookeeper保证的是CP"><a href="#二、zookeeper保证的是CP" class="headerlink" title="二、zookeeper保证的是CP"></a>二、zookeeper保证的是CP</h2><h2 id="三、eureka保证的是AP"><a href="#三、eureka保证的是AP" class="headerlink" title="三、eureka保证的是AP"></a>三、eureka保证的是AP</h2>]]></content>
    
    
    <categories>
      
      <category>java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>springCloud</tag>
      
      <tag>eureka</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>java8方法引用理解</title>
    <link href="/blog/2020/05/31/java8%E6%96%B9%E6%B3%95%E5%BC%95%E7%94%A8%E7%90%86%E8%A7%A3/"/>
    <url>/blog/2020/05/31/java8%E6%96%B9%E6%B3%95%E5%BC%95%E7%94%A8%E7%90%86%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[<h2 id="什么是方法引用"><a href="#什么是方法引用" class="headerlink" title="什么是方法引用?"></a>什么是方法引用?</h2><p>方法引用可用于在不调用方法的情况下引用方法。它将方法视为Lambda表达式。它们只能作为语法糖来减少一些lambdas的冗长。在方法引用中，将包含方法的对象（或类）放在::运算符之前，将方法的名称放在不带参数的方法之后。例如：</p><pre><code class="hljs asciidoc"><span class="hljs-bullet">Object :: </span>methodName</code></pre><h2 id="为什么会出现方法引用？"><a href="#为什么会出现方法引用？" class="headerlink" title="为什么会出现方法引用？"></a>为什么会出现方法引用？</h2><p>在Java中，我们可以通过创建新对象来使用对象的引用,或者引用已有的对象，例如：</p><pre><code class="hljs lasso"><span class="hljs-comment">//创建新对象来引用该对象</span><span class="hljs-built_in">List</span> <span class="hljs-built_in">list</span> = <span class="hljs-literal">new</span> ArrayList();dosth(<span class="hljs-built_in">list</span>);<span class="hljs-comment">//引用已有的对象</span><span class="hljs-built_in">List</span> list2 = <span class="hljs-built_in">list</span>;dosth(list2);</code></pre><p>如果我们只在另一个方法中使用对象的方法，我们仍然必须将完整的对象作为参数传递。那么将方法作为参数传递不是更有效吗？</p><h2 id="方法引用这种语法糖不能用于所有的方法，它们只能用于只有一个方法的lambda表达式"><a href="#方法引用这种语法糖不能用于所有的方法，它们只能用于只有一个方法的lambda表达式" class="headerlink" title="方法引用这种语法糖不能用于所有的方法，它们只能用于只有一个方法的lambda表达式"></a>方法引用这种语法糖不能用于所有的方法，它们只能用于只有一个方法的lambda表达式</h2><pre><code class="hljs arduino"><span class="hljs-comment">//lambda转方法引用</span>Consumer&lt;<span class="hljs-keyword">String</span>&gt; c = s -&gt; System.out.<span class="hljs-built_in">println</span>(s);Consumer&lt;<span class="hljs-keyword">String</span>&gt; c = System.out::<span class="hljs-built_in">println</span>;</code></pre><p>换句话说，可以使用lambda表达式去代替一个匿名类，如果这个匿名类只有一个方法，就可以用更简短的方法引用来代替lambda表达式。</p><h2 id="静态方法引用"><a href="#静态方法引用" class="headerlink" title="静态方法引用"></a>静态方法引用</h2><pre><code class="hljs livescript"><span class="hljs-keyword">from</span><span class="hljs-function"><span class="hljs-params">(args)</span> -&gt;</span> Class.staticMethod(args)<span class="hljs-keyword">to</span>Class::staticMethod</code></pre><p>如上所述，我们不需要显式的传递参数，方法引用中会自动传递参数</p><pre><code class="hljs arduino">Consumer&lt;<span class="hljs-keyword">String</span>&gt; c1 = (s) -&gt; System.out.<span class="hljs-built_in">println</span>(s);Consumer&lt;<span class="hljs-keyword">String</span>&gt; c2 = System.out::<span class="hljs-built_in">println</span>;c2.accept(<span class="hljs-string">"Hello"</span>);</code></pre><p>当我们所使用的lambda表达式仅仅调用了一个静态方法，我们就可以使用静态方法引用。如下所示，将lambda表达式（匿名类）中的值判断提取成isMoreThanFifty这个静态方法，就可以使用静态方法引用这种语法糖。</p><pre><code class="hljs reasonml">public <span class="hljs-keyword">class</span> Numbers &#123;    <span class="hljs-comment">//将值判断提取成静态方法</span>    public static boolean is<span class="hljs-constructor">MoreThanFifty(<span class="hljs-params">int</span> <span class="hljs-params">n1</span>, <span class="hljs-params">int</span> <span class="hljs-params">n2</span>)</span> &#123;        return (n1 + n2) &gt; <span class="hljs-number">50</span>;    &#125;    <span class="hljs-comment">//公共接口方法</span>    public static List&lt;Integer&gt; find<span class="hljs-constructor">Numbers(List&lt;Integer&gt; <span class="hljs-params">l</span>, BiPredicate&lt;Integer, Integer&gt; <span class="hljs-params">p</span>)</span> &#123;        List&lt;Integer&gt; newList = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;<span class="hljs-literal">()</span>;        for (Integer i : l) &#123;            <span class="hljs-keyword">if</span> (p.test(i, i + <span class="hljs-number">10</span>)) &#123;                newList.add(i);            &#125;        &#125;        return newList;    &#125;    public static void main(String<span class="hljs-literal">[]</span> args) &#123;        List&lt;Integer&gt; <span class="hljs-built_in">list</span> = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Arrays</span>.</span></span><span class="hljs-keyword">as</span><span class="hljs-constructor">List(12, 5, 45, 18, 33, 24, 40)</span>;        <span class="hljs-comment">// Using an anonymous class</span>        List&lt;Integer&gt; res = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Numbers</span>.</span></span>find<span class="hljs-constructor">Numbers(<span class="hljs-params">list</span>, <span class="hljs-params">new</span> BiPredicate&lt;Integer, Integer&gt;()</span> &#123;            @Override            public boolean test(Integer integer, Integer integer2) &#123;                return <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Numbers</span>.</span></span>is<span class="hljs-constructor">MoreThanFifty(<span class="hljs-params">integer</span>, <span class="hljs-params">integer2</span>)</span>;            &#125;        &#125;);        res.stream<span class="hljs-literal">()</span>.for<span class="hljs-constructor">Each(System.<span class="hljs-params">out</span> :: <span class="hljs-params">println</span>)</span>;<span class="hljs-comment">//        res.stream().peek(System.out :: println).collect(Collectors.toList());</span>        <span class="hljs-comment">// Using a lambda expression</span>        <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Numbers</span>.</span></span>find<span class="hljs-constructor">Numbers(<span class="hljs-params">list</span>, (<span class="hljs-params">i1</span>, <span class="hljs-params">i2</span>)</span> -&gt; <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Numbers</span>.</span></span>is<span class="hljs-constructor">MoreThanFifty(<span class="hljs-params">i1</span>, <span class="hljs-params">i2</span>)</span>);        <span class="hljs-comment">// Using a method reference</span>        <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Numbers</span>.</span></span>find<span class="hljs-constructor">Numbers(<span class="hljs-params">list</span>, Numbers::<span class="hljs-params">isMoreThanFifty</span>)</span>;    &#125;&#125;</code></pre><h2 id="特定类型的对象的实例方法的方法引用"><a href="#特定类型的对象的实例方法的方法引用" class="headerlink" title="特定类型的对象的实例方法的方法引用"></a>特定类型的对象的实例方法的方法引用</h2><pre><code class="hljs livescript"><span class="hljs-keyword">from</span><span class="hljs-function"><span class="hljs-params">(obj, args)</span> -&gt;</span> obj.instanceMethod(args)<span class="hljs-keyword">to</span>ObjectType::instanceMethod</code></pre><ul><li>我们使用实例的类型而非实例本身</li><li>参数隐式传递<pre><code class="hljs zephir"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">People</span> </span>&#123;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">double</span> calculateWeight() &#123;        <span class="hljs-keyword">double</span> weight = <span class="hljs-number">0</span>;        <span class="hljs-comment">// Calculate weight</span>        <span class="hljs-keyword">return</span> weight;    &#125;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">List</span>&lt;<span class="hljs-keyword">Double</span>&gt; calculateAllWeight(<span class="hljs-keyword">List</span>&lt;People&gt; l, <span class="hljs-function"><span class="hljs-keyword">Function</span>&lt;<span class="hljs-title">People</span>, <span class="hljs-title">Double</span>&gt; <span class="hljs-title">f</span>) </span>&#123;        <span class="hljs-keyword">List</span>&lt;<span class="hljs-keyword">Double</span>&gt; results = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();        <span class="hljs-keyword">for</span> (People s : l) &#123;            results.add(f.apply(s));        &#125;        <span class="hljs-keyword">return</span> results;    &#125;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PeopleClient</span> </span>&#123;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> void main(String[] args) &#123;        <span class="hljs-keyword">List</span>&lt;People&gt; <span class="hljs-keyword">list</span> = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();        People p = <span class="hljs-keyword">new</span> People();        <span class="hljs-comment">// Using an anonymous class</span>        p.calculateAllWeight(<span class="hljs-keyword">list</span>, <span class="hljs-keyword">new</span> <span class="hljs-function"><span class="hljs-keyword">Function</span>&lt;<span class="hljs-title">People</span>, <span class="hljs-title">Double</span>&gt;<span class="hljs-params">()</span> </span>&#123;            @Override            <span class="hljs-keyword">public</span> <span class="hljs-keyword">Double</span> apply(People people) &#123;<span class="hljs-comment">// The object</span>                <span class="hljs-keyword">return</span> people.calculateWeight();<span class="hljs-comment">// The method</span>            &#125;        &#125;);        <span class="hljs-comment">// Using a lambda expression</span>        p.calculateAllWeight(<span class="hljs-keyword">list</span>, people -&gt; people.calculateWeight());        <span class="hljs-comment">// Using a method reference</span>        p.calculateAllWeight(<span class="hljs-keyword">list</span>, People::calculateWeight);    &#125;&#125;</code></pre>在这个例子中，我们没有给方法传递任何参数，关键在于对象的实例是lambda表达式的一个参数，我们通过实例的类型来完成对实例方法的引用。下面是另一个例子，在这个例子中，我们向方法引用中传递了两个参数。<pre><code class="hljs lasso"><span class="hljs-comment">//java中有一个Function接口可以接收一个参数，BiFunction接口接受两个参数，没有接受三个参数的，所以我们自定义一个TriFunction</span>interface TriFunction&lt;T, U, V, R&gt; &#123;  R apply(T t, U u, V v);&#125;<span class="hljs-comment">//然后定义一个类，接收两个参数，并且有一个返回值</span>class <span class="hljs-keyword">Sum</span> &#123;  <span class="hljs-built_in">Integer</span> doSum(<span class="hljs-built_in">String</span> s1, <span class="hljs-built_in">String</span> s2) &#123;    <span class="hljs-keyword">return</span> <span class="hljs-built_in">Integer</span>.parseInt(s1) + <span class="hljs-built_in">Integer</span>.parseInt(s1);  &#125;&#125;<span class="hljs-comment">//用匿名类实现TriFunction，来包装doSum()</span>TriFunction&lt;<span class="hljs-keyword">Sum</span>, <span class="hljs-built_in">String</span>, <span class="hljs-built_in">String</span>, <span class="hljs-built_in">Integer</span>&gt; anonymous =  <span class="hljs-literal">new</span> TriFunction&lt;<span class="hljs-keyword">Sum</span>, <span class="hljs-built_in">String</span>, <span class="hljs-built_in">String</span>, <span class="hljs-built_in">Integer</span>&gt;() &#123;    @Override    <span class="hljs-keyword">public</span> <span class="hljs-built_in">Integer</span> apply(<span class="hljs-keyword">Sum</span> s, <span class="hljs-built_in">String</span> arg1, <span class="hljs-built_in">String</span> arg2) &#123;      <span class="hljs-keyword">return</span> s.doSum(arg1, arg2);    &#125;&#125;;System.out.println(anonymous.apply(<span class="hljs-literal">new</span> <span class="hljs-keyword">Sum</span>(), <span class="hljs-string">"1"</span>, <span class="hljs-string">"4"</span>));<span class="hljs-comment">//使用lambda表达式来包装</span>TriFunction&lt;<span class="hljs-keyword">Sum</span>, <span class="hljs-built_in">String</span>, <span class="hljs-built_in">String</span>, <span class="hljs-built_in">Integer</span>&gt; lambda =  (<span class="hljs-keyword">Sum</span> s, <span class="hljs-built_in">String</span> arg1, <span class="hljs-built_in">String</span> arg2) -&gt; s.doSum(arg1, arg2);System.out.println(lambda.apply(<span class="hljs-literal">new</span> <span class="hljs-keyword">Sum</span>(), <span class="hljs-string">"1"</span>, <span class="hljs-string">"4"</span>));<span class="hljs-comment">//使用方法引用</span>TriFunction&lt;<span class="hljs-keyword">Sum</span>, <span class="hljs-built_in">String</span>, <span class="hljs-built_in">String</span>, <span class="hljs-built_in">Integer</span>&gt; mRef = <span class="hljs-keyword">Sum</span><span class="hljs-type">::doSum</span>;System.out.println(mRef.apply(<span class="hljs-literal">new</span> <span class="hljs-keyword">Sum</span>(), <span class="hljs-string">"1"</span>, <span class="hljs-string">"4"</span>));</code></pre></li><li>第一个参数是要执行的方法的实例对象</li><li>第二、三个参数是传递的其他参数</li><li>最后一个参数是要执行的方法的返回值类型</li></ul><h2 id="已有对象的实例方法引用"><a href="#已有对象的实例方法引用" class="headerlink" title="已有对象的实例方法引用"></a>已有对象的实例方法引用</h2><pre><code class="hljs livescript"><span class="hljs-keyword">from</span><span class="hljs-function"><span class="hljs-params">(args)</span> -&gt;</span> obj.instanceMethod(args)<span class="hljs-keyword">to</span>obj::instanceMethod</code></pre><p>直接引用已经在其他地方实例化的对象的一个方法，本身不需要再实现一次</p><pre><code class="hljs arduino"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Car</span> &#123;</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> id;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">String</span> color;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getId</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> id;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setId</span><span class="hljs-params">(<span class="hljs-keyword">int</span> id)</span> </span>&#123;        <span class="hljs-keyword">this</span>.id = id;    &#125;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Mechanic</span> &#123;</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">fix</span><span class="hljs-params">(Car c)</span> </span>&#123;        System.out.<span class="hljs-built_in">println</span>(<span class="hljs-string">"Fixing car "</span> + c.getId());    &#125;&#125;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">InstanceRef</span> &#123;</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">String</span>[] args)</span> </span>&#123;        InstanceRef instanceRef = <span class="hljs-keyword">new</span> InstanceRef();        <span class="hljs-keyword">final</span> Mechanic mechanic = <span class="hljs-keyword">new</span> Mechanic();        Car car = <span class="hljs-keyword">new</span> Car();        <span class="hljs-comment">// Using an anonymous class</span>        instanceRef.execute(car, <span class="hljs-keyword">new</span> Consumer&lt;Car&gt;() &#123;            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> accept(Car c) &#123;                mechanic.fix(c);            &#125;        &#125;);        <span class="hljs-comment">// Using a lambda expression</span>        instanceRef.execute(car, car1 -&gt; mechanic.fix(car1));        <span class="hljs-comment">//Using a method reference</span>        instanceRef.execute(car, mechanic::fix);    &#125;    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">execute</span><span class="hljs-params">(Car car, Consumer&lt;Car&gt; c)</span> </span>&#123;        c.accept(car);    &#125;&#125;</code></pre><h2 id="构造方法引用"><a href="#构造方法引用" class="headerlink" title="构造方法引用"></a>构造方法引用</h2><pre><code class="hljs livescript"><span class="hljs-keyword">from</span><span class="hljs-function"><span class="hljs-params">(args)</span> -&gt;</span> <span class="hljs-keyword">new</span> ClassName(args)<span class="hljs-keyword">to</span>ClassName::<span class="hljs-keyword">new</span></code></pre><p>这个lambda表达式唯一能做的就是创建一个新对象，我们通过关键字new来引用类的构造函数。与其他情况一样，参数（如果有）不会在方法引用中传递。</p><p><strong>无参构造</strong></p><pre><code class="hljs dart"><span class="hljs-comment">// Using an anonymous class</span>Supplier&lt;<span class="hljs-built_in">List</span>&lt;<span class="hljs-built_in">String</span>&gt;&gt; s = <span class="hljs-keyword">new</span> Supplier() &#123;  public <span class="hljs-built_in">List</span>&lt;<span class="hljs-built_in">String</span>&gt; <span class="hljs-keyword">get</span>() &#123;    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ArrayList&lt;<span class="hljs-built_in">String</span>&gt;();  &#125;&#125;;<span class="hljs-built_in">List</span>&lt;<span class="hljs-built_in">String</span>&gt; l = s.<span class="hljs-keyword">get</span>();<span class="hljs-comment">// Using a lambda expression</span>Supplier&lt;<span class="hljs-built_in">List</span>&lt;<span class="hljs-built_in">String</span>&gt;&gt; s = () -&gt; <span class="hljs-keyword">new</span> ArrayList&lt;<span class="hljs-built_in">String</span>&gt;();<span class="hljs-built_in">List</span>&lt;<span class="hljs-built_in">String</span>&gt; l = s.<span class="hljs-keyword">get</span>();<span class="hljs-comment">// Using a method reference</span>Supplier&lt;<span class="hljs-built_in">List</span>&lt;<span class="hljs-built_in">String</span>&gt;&gt; s = ArrayList::<span class="hljs-keyword">new</span>;<span class="hljs-built_in">List</span>&lt;<span class="hljs-built_in">String</span>&gt; l = s.<span class="hljs-keyword">get</span>();</code></pre><p><strong>带参构造</strong></p><pre><code class="hljs lasso"><span class="hljs-comment">// Using a anonymous class</span>BiFunction&lt;<span class="hljs-built_in">String</span>, <span class="hljs-built_in">String</span>, <span class="hljs-built_in">Locale</span>&gt; f = <span class="hljs-literal">new</span> BiFunction&lt;<span class="hljs-built_in">String</span>, <span class="hljs-built_in">String</span>, <span class="hljs-built_in">Locale</span>&gt;() &#123;  <span class="hljs-keyword">public</span> <span class="hljs-built_in">Locale</span> apply(<span class="hljs-built_in">String</span> lang, <span class="hljs-built_in">String</span> country) &#123;    <span class="hljs-keyword">return</span> <span class="hljs-literal">new</span> <span class="hljs-built_in">Locale</span>(lang, country);  &#125;&#125;;<span class="hljs-built_in">Locale</span> loc = f.apply(<span class="hljs-string">"en"</span>,<span class="hljs-string">"UK"</span>);<span class="hljs-comment">// Using a lambda expression</span>BiFunction&lt;<span class="hljs-built_in">String</span>, <span class="hljs-built_in">String</span>, <span class="hljs-built_in">Locale</span>&gt; f = (lang, country) -&gt; <span class="hljs-literal">new</span> <span class="hljs-built_in">Locale</span>(lang, country);<span class="hljs-built_in">Locale</span> loc = f.apply(<span class="hljs-string">"en"</span>,<span class="hljs-string">"UK"</span>);<span class="hljs-comment">// Using a method reference</span>BiFunction&lt;<span class="hljs-built_in">String</span>, <span class="hljs-built_in">String</span>, <span class="hljs-built_in">Locale</span>&gt; f = <span class="hljs-built_in">Locale</span><span class="hljs-type">::new</span>;<span class="hljs-built_in">Locale</span> loc = f.apply(<span class="hljs-string">"en"</span>,<span class="hljs-string">"UK"</span>);</code></pre><p>如果有三个及以上的参数的构造函数，则必须创建自己的函数接口。引用构造函数与引用静态方法非常相似，区别在于构造函数“方法名称”是new。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>如果使用了方法引用之后能让代码变的更加整洁，就使用它。实际使用中，一种使用方式是将代码包裹在一个方法中，而非使用一个单独的类或者lambda表达式，然后使用方法引用的方式进行调用。方法引用常用于java8的另一种新特性Streams中，而基于方法引用的设计模式也会更加具有拓展性。</p>]]></content>
    
    
    <categories>
      
      <category>java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>stream</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>java8新特性之Stream</title>
    <link href="/blog/2020/05/31/java8%E6%96%B0%E7%89%B9%E6%80%A7%E4%B9%8BStream/"/>
    <url>/blog/2020/05/31/java8%E6%96%B0%E7%89%B9%E6%80%A7%E4%B9%8BStream/</url>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>Stream API与InputStream和OutputStream是完全不同的概念，<strong>Stream API是对Java中集合操作的增强，可以利用它进行各种过滤、排序、分组、聚合等操作</strong>。Stream API配合Lambda表达式可以加大的提高代码可读性和编码效率，Stream API也支持并行操作。</p><h3 id="流不是集合，它不关心数据的存放，只关注如何处理数据"><a href="#流不是集合，它不关心数据的存放，只关注如何处理数据" class="headerlink" title="流不是集合，它不关心数据的存放，只关注如何处理数据"></a>流不是集合，它不关心数据的存放，只关注如何处理数据</h3><p>Stream API主要用于处理集合操作，不过它的处理方式与传统的方式不同，称为“数据流处理”。流（Stream）类似于关系数据库的查询操作，是一种声明式操作。比如要从数据库中获取所有年龄大于20岁的用户的名称，并按照用户的创建时间进行排序，用一条SQL语句就可以搞定，不过使用Java程序实现就会显得有些繁琐，这时候可以使用流：</p><pre><code class="hljs lasso"><span class="hljs-built_in">List</span>&lt;<span class="hljs-built_in">String</span>&gt; userNames = users.stream()    .filter(user -&gt; user.getAge() &gt; <span class="hljs-number">20</span>)    .sorted(comparing(User<span class="hljs-type">::getCreationDate</span>))    .<span class="hljs-built_in">map</span>(User<span class="hljs-type">::getUserName</span>)    .collect(toList());</code></pre><p>在Java中，集合是一种数据结构，或者说是一种容器，用于存放数据，流不是容器，它不关心数据的存放，只关注如何处理。可以把流当做是Java中的Iterator，不过它比Iterator强大多了。</p><h3 id="流使用内部迭代方式处理数据"><a href="#流使用内部迭代方式处理数据" class="headerlink" title="流使用内部迭代方式处理数据"></a>流使用内部迭代方式处理数据</h3><p>流与集合另一个区别在于他们的遍历方式，遍历集合通常使用for-each方式，这种方式称为外部迭代，而流使用内部迭代方式，也就是说它帮你把迭代的工作做了，你只需要给出一个函数来告诉它接下来要干什么：</p><pre><code class="hljs reasonml"><span class="hljs-comment">// 外部迭代</span>List&lt;String&gt; <span class="hljs-built_in">list</span> = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Arrays</span>.</span></span><span class="hljs-keyword">as</span><span class="hljs-constructor">List(<span class="hljs-string">"A"</span>, <span class="hljs-string">"B"</span>, <span class="hljs-string">"C"</span>, <span class="hljs-string">"D"</span>)</span>;for (String str : <span class="hljs-built_in">list</span>) &#123;    <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(str);&#125;<span class="hljs-comment">// 内部迭代</span><span class="hljs-built_in">list</span>.stream<span class="hljs-literal">()</span>.for<span class="hljs-constructor">Each(System.<span class="hljs-params">out</span>::<span class="hljs-params">println</span>)</span>;</code></pre><p>外部迭代更像是作文题，我们不仅要控制元素的迭代方式，还需要定义怎么操作元素；内部迭代更像是填空题，我们只用关注如何操作元素就可以了。</p><h3 id="流只能遍历一次"><a href="#流只能遍历一次" class="headerlink" title="流只能遍历一次"></a>流只能遍历一次</h3><p>流只能遍历一次，遍历结束后，这个流就被关闭掉了。如果要重新遍历，可以从数据源（集合）中重新获取一个流。如果你对一个流遍历两次，就会抛出java.lang.IllegalStateException异常：</p><pre><code class="hljs reasonml">List&lt;String&gt; <span class="hljs-built_in">list</span> = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Arrays</span>.</span></span><span class="hljs-keyword">as</span><span class="hljs-constructor">List(<span class="hljs-string">"A"</span>, <span class="hljs-string">"B"</span>, <span class="hljs-string">"C"</span>, <span class="hljs-string">"D"</span>)</span>;Stream&lt;String&gt; stream = <span class="hljs-built_in">list</span>.stream<span class="hljs-literal">()</span>;stream.for<span class="hljs-constructor">Each(System.<span class="hljs-params">out</span>::<span class="hljs-params">println</span>)</span>;stream.for<span class="hljs-constructor">Each(System.<span class="hljs-params">out</span>::<span class="hljs-params">println</span>)</span>; <span class="hljs-comment">// 这里会抛出java.lang.IllegalStateException异常，因为流已经被关闭</span></code></pre><h3 id="流通常由三部分构成："><a href="#流通常由三部分构成：" class="headerlink" title="流通常由三部分构成："></a>流通常由三部分构成：</h3><ol><li>数据源：数据源一般用于流的获取，比如本文开头那个过滤用户的例子中users.stream()方法。</li><li>中间处理：中间处理包括对流中元素的一系列处理，如：过滤（filter()），映射（map()），排序（sorted()）。</li><li>终端处理：终端处理会生成结果，结果可以是任何不是流值，如List<String>；也可以不返回结果，如stream.forEach(System.out::println)就是将结果打印到控制台中，并没有返回。</li></ol><h2 id="创建流"><a href="#创建流" class="headerlink" title="创建流"></a>创建流</h2><h3 id="由值创建流"><a href="#由值创建流" class="headerlink" title="由值创建流"></a>由值创建流</h3><p>使用静态方法Stream.of()创建流，该方法接收一个变长参数：</p><pre><code class="hljs arduino"><span class="hljs-built_in">Stream</span>&lt;<span class="hljs-built_in">Stream</span>&gt; stream = <span class="hljs-built_in">Stream</span>.of(<span class="hljs-string">"A"</span>, <span class="hljs-string">"B"</span>, <span class="hljs-string">"C"</span>, <span class="hljs-string">"D"</span>);<span class="hljs-comment">//也可以使用静态方法Stream.empty()创建一个空的流：</span><span class="hljs-built_in">Stream</span>&lt;<span class="hljs-built_in">Stream</span>&gt; stream = <span class="hljs-built_in">Stream</span>.empty();</code></pre><h3 id="由数组、集合-创建流"><a href="#由数组、集合-创建流" class="headerlink" title="由数组、集合 创建流"></a>由数组、集合 创建流</h3><p>使用静态方法Arrays.stream()从数组创建一个流，该方法接收一个数组参数：</p><pre><code class="hljs armasm"><span class="hljs-keyword">String[] </span><span class="hljs-keyword">strs </span>= &#123;<span class="hljs-string">"A"</span>, <span class="hljs-string">"B"</span>, <span class="hljs-string">"C"</span>, <span class="hljs-string">"D"</span>&#125;<span class="hljs-comment">;</span><span class="hljs-keyword">Stream&lt;Stream&gt; </span><span class="hljs-keyword">stream </span>= Arrays.<span class="hljs-keyword">stream(strs);</span></code></pre><h3 id="通过文件生成流"><a href="#通过文件生成流" class="headerlink" title="通过文件生成流"></a>通过文件生成流</h3><p>使用java.nio.file.Files类中的很多静态方法都可以获取流，比如Files.lines()方法，该方法接收一个java.nio.file.Path对象，返回一个由文件行构成的字符串流：</p><pre><code class="hljs reasonml">Stream&lt;String&gt; stream = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Files</span>.</span></span>lines(<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Paths</span>.</span></span>get(<span class="hljs-string">"text.txt"</span>), <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Charset</span>.</span></span>default<span class="hljs-constructor">Charset()</span>);</code></pre><h3 id="通过函数创建流"><a href="#通过函数创建流" class="headerlink" title="通过函数创建流"></a>通过函数创建流</h3><p>java.util.stream.Stream中有两个静态方法用于从函数生成流，他们分别是Stream.generate()和Stream.iterate()：</p><pre><code class="hljs reasonml"><span class="hljs-comment">// iteartor 打印100以内的所有偶数</span><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Stream</span>.</span></span>iterate(<span class="hljs-number">0</span>, n -&gt; n + <span class="hljs-number">2</span>).limit(<span class="hljs-number">51</span>).for<span class="hljs-constructor">Each(System.<span class="hljs-params">out</span>::<span class="hljs-params">println</span>)</span>;<span class="hljs-comment">// generate 打印10个Hello Man!</span><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Stream</span>.</span></span>generate(<span class="hljs-literal">()</span> -&gt; <span class="hljs-string">"Hello Man!"</span>).limit(<span class="hljs-number">10</span>).for<span class="hljs-constructor">Each(System.<span class="hljs-params">out</span>::<span class="hljs-params">println</span>)</span>;</code></pre><p>值得注意的是，这两个方法生成的流都是无限流，没有固定大小，可以无穷的计算下去，可以使用limit()来限制边界。</p><pre><code class="hljs reasonml"><span class="hljs-comment">//一般来说，iterate()用于生成一系列值，比如生成以当前时间开始之后的10天的日期：</span><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Stream</span>.</span></span>iterate(<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">LocalDate</span>.</span></span>now<span class="hljs-literal">()</span>, date -&gt; date.plus<span class="hljs-constructor">Days(1)</span>).limit(<span class="hljs-number">10</span>).for<span class="hljs-constructor">Each(System.<span class="hljs-params">out</span>::<span class="hljs-params">println</span>)</span>;<span class="hljs-comment">//generate()方法用于生成一些随机数，比如生成10个UUID：</span><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Stream</span>.</span></span>generate(<span class="hljs-literal">()</span> -&gt; <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">UUID</span>.</span></span>random<span class="hljs-constructor">UUID()</span>.<span class="hljs-keyword">to</span><span class="hljs-constructor">String()</span>).limit(<span class="hljs-number">10</span>).for<span class="hljs-constructor">Each(System.<span class="hljs-params">out</span>::<span class="hljs-params">println</span>)</span>;</code></pre><h3 id="collect-toList-将流中的值转换为集合"><a href="#collect-toList-将流中的值转换为集合" class="headerlink" title="collect(toList())将流中的值转换为集合"></a>collect(toList())将流中的值转换为集合</h3><pre><code class="hljs reasonml"><span class="hljs-comment">//of从初识值生成新的stream，再通过collect(toList())生成新的集合</span>List&lt;String&gt; collect = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Stream</span>.</span></span><span class="hljs-keyword">of</span>(<span class="hljs-string">"aa"</span>, <span class="hljs-string">"bb"</span>, <span class="hljs-string">"cc"</span>, <span class="hljs-string">"aa"</span>, <span class="hljs-string">"bb"</span>).collect(<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Collectors</span>.</span></span><span class="hljs-keyword">to</span><span class="hljs-constructor">List()</span>);</code></pre><p>of是惰性求值，不生成新的集合，通过collect(toList())这种及早求值才生成新的集合。返回值是stream就是惰性求值，返回值为另一个值或者空就是及早求值。</p><h3 id="惰性求值与及早求值的区别"><a href="#惰性求值与及早求值的区别" class="headerlink" title="惰性求值与及早求值的区别"></a>惰性求值与及早求值的区别</h3><pre><code class="hljs processing"><span class="hljs-comment">//如下加count就是及早求值，会sout输出strs。不加count，程序不输出任何信息</span>strs.stream().<span class="hljs-built_in">filter</span>(<span class="hljs-built_in">str</span> -&gt; &#123;    System.out.<span class="hljs-built_in">println</span>(<span class="hljs-built_in">str</span>);    <span class="hljs-keyword">return</span> <span class="hljs-built_in">str</span>.startsWith(<span class="hljs-string">"a"</span>);&#125;).count();</code></pre><p>过滤+计数，只循环了一次。只执行fileter会返回一个stream，他不是一个新集合，仅仅是创建新集合的配方。</p><h2 id="流常用方法"><a href="#流常用方法" class="headerlink" title="流常用方法"></a>流常用方法</h2><h3 id="过滤和排序"><a href="#过滤和排序" class="headerlink" title="过滤和排序"></a>过滤和排序</h3><pre><code class="hljs angelscript">Stream.of(<span class="hljs-number">1</span>, <span class="hljs-number">8</span>, <span class="hljs-number">5</span>, <span class="hljs-number">2</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">9</span>, <span class="hljs-number">2</span>, <span class="hljs-number">0</span>, <span class="hljs-number">4</span>, <span class="hljs-number">8</span>)    .filter(n -&gt; n &gt; <span class="hljs-number">2</span>)     <span class="hljs-comment">// 对元素过滤，保留大于2的元素</span>    .distinct()             <span class="hljs-comment">// 去重，类似于SQL语句中的DISTINCT</span>    .skip(<span class="hljs-number">1</span>)                <span class="hljs-comment">// 跳过前面1个元素</span>    .limit(<span class="hljs-number">2</span>)               <span class="hljs-comment">// 返回开头2个元素，类似于SQL语句中的SELECT TOP</span>    .sorted()               <span class="hljs-comment">// 对结果排序</span>    .forEach(System.<span class="hljs-keyword">out</span>::println);</code></pre><p>filter 对集合的值进行过滤，必须返回true或者false</p><h3 id="查找和匹配"><a href="#查找和匹配" class="headerlink" title="查找和匹配"></a>查找和匹配</h3><pre><code class="hljs reasonml"><span class="hljs-comment">//检查流中的任意元素是否包含字符串"PHP"</span>boolean match1 = get<span class="hljs-constructor">Stream()</span>.any<span class="hljs-constructor">Match(<span class="hljs-params">s</span> -&gt; <span class="hljs-params">s</span>.<span class="hljs-params">equals</span>(<span class="hljs-string">"PHP"</span>)</span>);<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(match1);boolean match2 = get<span class="hljs-constructor">Stream()</span>.collect(<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Collectors</span>.</span></span><span class="hljs-keyword">to</span><span class="hljs-constructor">List()</span>).contains(<span class="hljs-string">"PHP"</span>);<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(match2);<span class="hljs-comment">// 检查流中的所有元素是否都包含字符串"#"</span>boolean hasAllMatch = get<span class="hljs-constructor">Stream()</span>.all<span class="hljs-constructor">Match(<span class="hljs-params">s</span> -&gt; <span class="hljs-params">s</span>.<span class="hljs-params">contains</span>(<span class="hljs-string">"#"</span>)</span>);<span class="hljs-comment">// 检查流中的任意元素是否没有以"C"开头的字符串</span>boolean hasNoneMatch = get<span class="hljs-constructor">Stream()</span>.none<span class="hljs-constructor">Match(<span class="hljs-params">s</span> -&gt; <span class="hljs-params">s</span>.<span class="hljs-params">startsWith</span>(<span class="hljs-string">"C"</span>)</span>);<span class="hljs-comment">// 查找元素</span>Optional&lt;String&gt; element = get<span class="hljs-constructor">Stream()</span>.ilter(s -&gt; s.contains(<span class="hljs-string">"C"</span>))    <span class="hljs-comment">// .findFirst()     // 查找第一个元素</span>    .find<span class="hljs-constructor">Any()</span>;         <span class="hljs-comment">// 查找任意元素</span> <span class="hljs-comment">//获取初始流   </span><span class="hljs-keyword">private</span> static Stream&lt;String&gt; get<span class="hljs-constructor">Stream()</span> &#123;    return <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Stream</span>.</span></span><span class="hljs-keyword">of</span>(<span class="hljs-string">"Java"</span>, <span class="hljs-string">"C#"</span>, <span class="hljs-string">"PHP"</span>, <span class="hljs-string">"C++"</span>, <span class="hljs-string">"Python"</span>);&#125;</code></pre><ol><li>每次都需要重新getStream()来获取新的流，因为之前的流已经使用并且关闭了。可以理解为若返回值不是stream，则表示已经结束了流操作</li><li>findAny的返回类型是一个Optional<T>类（java.util.Optional），它一个容器类，代表一个值存在或不存在，用来避免控制正异常。</li><li>findFirst()和findAny()返回的都是第一个元素，通过查看javadoc描述，大致意思是findAny()是为了提高并行操作时的性能。数据大时可findany。</li></ol><h3 id="归约"><a href="#归约" class="headerlink" title="归约"></a>归约</h3><p>归约操作就是将流中的元素进行合并，形成一个新的值，常见的归约操作包括求和，求最大值或最小值。归约操作一般使用reduce()方法，与map()方法搭配使用，可以处理一些很复杂的归约操作。</p><pre><code class="hljs lasso"><span class="hljs-comment">// 获取流</span><span class="hljs-built_in">List</span>&lt;Book&gt; books = Arrays.asList(   <span class="hljs-literal">new</span> Book(<span class="hljs-string">"Java编程思想"</span>, <span class="hljs-string">"Bruce Eckel"</span>, <span class="hljs-string">"机械工业出版社"</span>, <span class="hljs-number">108.00</span>D),   <span class="hljs-literal">new</span> Book(<span class="hljs-string">"Java 8实战"</span>, <span class="hljs-string">"Mario Fusco"</span>, <span class="hljs-string">"人民邮电出版社"</span>, <span class="hljs-number">79.00</span>D),   <span class="hljs-literal">new</span> Book(<span class="hljs-string">"MongoDB权威指南（第2版）"</span>, <span class="hljs-string">"Kristina Chodorow"</span>, <span class="hljs-string">"人民邮电出版社"</span>, <span class="hljs-number">69.00</span>D));<span class="hljs-comment">// 计算所有图书的总价</span>Optional&lt;Double&gt; totalPrice = books.stream()       .<span class="hljs-built_in">map</span>(Book<span class="hljs-type">::getPrice</span>)       .reduce((n, m) -&gt; n + m);<span class="hljs-comment">// 价格最高的图书</span>Optional&lt;Book&gt; expensive = books.stream().<span class="hljs-keyword">max</span>(Comparator.comparing(Book<span class="hljs-type">::getPrice</span>));<span class="hljs-comment">// 价格最低的图书</span>Optional&lt;Book&gt; cheapest = books.stream().<span class="hljs-keyword">min</span>(Comparator.comparing(Book<span class="hljs-type">::getPrice</span>));<span class="hljs-comment">// 计算总数</span>long count = books.stream().count()</code></pre><h3 id="reduce从一组值中生成一个值，如累加。"><a href="#reduce从一组值中生成一个值，如累加。" class="headerlink" title="reduce从一组值中生成一个值，如累加。"></a>reduce从一组值中生成一个值，如累加。</h3><pre><code class="hljs angelscript"><span class="hljs-comment">//0初始值，total总值，index循环的每一个值。</span>Integer num = Stream.of(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>).reduce(<span class="hljs-number">0</span>, (total, index) -&gt; total + index);</code></pre><h3 id="max-min-传入comparator进行大小比较，返回Optional对象"><a href="#max-min-传入comparator进行大小比较，返回Optional对象" class="headerlink" title="max(min) 传入comparator进行大小比较，返回Optional对象"></a>max(min) 传入comparator进行大小比较，返回Optional对象</h3><pre><code class="hljs maxima">//Optional对象(代表一个可能存在也可能不存在的值，NPE方案),通过<span class="hljs-built_in">get</span>拿到Optional对象中的值Integer <span class="hljs-built_in">integer</span> = Stream.of(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>).<span class="hljs-built_in">min</span>(Comparator.comparing(<span class="hljs-built_in">num</span> -&gt; <span class="hljs-built_in">num</span>)).<span class="hljs-built_in">get</span>();</code></pre><h3 id="map-将流中的值转换为新值"><a href="#map-将流中的值转换为新值" class="headerlink" title="map 将流中的值转换为新值"></a>map 将流中的值转换为新值</h3><pre><code class="hljs reasonml"><span class="hljs-comment">//将list小写处理成大写</span><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Stream</span>.</span></span><span class="hljs-keyword">of</span>(<span class="hljs-string">"aa"</span>, <span class="hljs-string">"bb"</span>, <span class="hljs-string">"cc"</span>, <span class="hljs-string">"aa"</span>, <span class="hljs-string">"bb"</span>).map(str -&gt; str.<span class="hljs-keyword">to</span><span class="hljs-constructor">UpperCase()</span>).collect(<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Collectors</span>.</span></span><span class="hljs-keyword">to</span><span class="hljs-constructor">List()</span>);</code></pre><h3 id="flatmap-把多个stream合并成一个stream并返回"><a href="#flatmap-把多个stream合并成一个stream并返回" class="headerlink" title="flatmap 把多个stream合并成一个stream并返回"></a>flatmap 把多个stream合并成一个stream并返回</h3><p>与map()方法类似的还有一个flatMap()，flatMap()方法让你把一个流中的每个值都换成另一个流，然后把所有的流连接起来成为一个新的流。</p><pre><code class="hljs reasonml"><span class="hljs-comment">//传统for循环</span>List&lt;String&gt; names0 = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;<span class="hljs-literal">()</span>;for (Company company : data) &#123;    List&lt;User&gt; users = company.get<span class="hljs-constructor">Uesrs()</span>;    for (User user : users) &#123;        <span class="hljs-keyword">if</span> (user.get<span class="hljs-constructor">Age()</span> &gt; <span class="hljs-number">30</span>) &#123;            names0.add(user.get<span class="hljs-constructor">Name()</span>);        &#125;    &#125;&#125;<span class="hljs-comment">//lambda方式1</span>List&lt;String&gt; names1 = data.stream<span class="hljs-literal">()</span>    .flat<span class="hljs-constructor">Map(<span class="hljs-params">company</span> -&gt; <span class="hljs-params">company</span>.<span class="hljs-params">getUesrs</span>()</span>.stream<span class="hljs-literal">()</span>)    .filter(user -&gt; user.get<span class="hljs-constructor">Age()</span> &gt; <span class="hljs-number">30</span>)    .map(user -&gt; user.get<span class="hljs-constructor">Name()</span>)    .collect(<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Collectors</span>.</span></span><span class="hljs-keyword">to</span><span class="hljs-constructor">List()</span>);<span class="hljs-comment">//lambda方式2</span>List&lt;String&gt; names2 = data.stream<span class="hljs-literal">()</span>    .map(Company::getUesrs)    .flat<span class="hljs-constructor">Map(Collection::<span class="hljs-params">stream</span>)</span>    .filter(user -&gt; user.get<span class="hljs-constructor">Age()</span> &gt; <span class="hljs-number">30</span>)    .map(User::getName)    .collect(<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Collectors</span>.</span></span><span class="hljs-keyword">to</span><span class="hljs-constructor">List()</span>);</code></pre><p>使用flatMap()方法的效果是，各个数组并不是分别映射成一个流，而是映射成流的内容。所有使用map(Arrays::stream)时生成的单个流都被合并起来，也就是对流扁平化操作。</p><h3 id="peek-用于记录中间值（输出流中的值），不会改变流。一般用作日志输出，断点调试。"><a href="#peek-用于记录中间值（输出流中的值），不会改变流。一般用作日志输出，断点调试。" class="headerlink" title="peek 用于记录中间值（输出流中的值），不会改变流。一般用作日志输出，断点调试。"></a>peek 用于记录中间值（输出流中的值），不会改变流。一般用作日志输出，断点调试。</h3><pre><code class="hljs reasonml">List&lt;Integer&gt; nums = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Stream</span>.</span></span><span class="hljs-keyword">of</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>).collect(<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Collectors</span>.</span></span><span class="hljs-keyword">to</span><span class="hljs-constructor">List()</span>);nums.stream<span class="hljs-literal">()</span>.filter(num -&gt; num &gt; <span class="hljs-number">3</span>).peek(num -&gt; &#123;    <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(num);&#125;).collect(<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Collectors</span>.</span></span><span class="hljs-keyword">to</span><span class="hljs-constructor">List()</span>);</code></pre><h2 id="数据收集"><a href="#数据收集" class="headerlink" title="数据收集"></a>数据收集</h2><p>前面总结了如何创建流以及流处理，接下来总结下数据收集。数据收集是流式数据处理的终端处理，<strong>与中间处理不同的是，终端处理会消耗流，也就是说，终端处理之后，这个流就会被关闭，如果再进行中间处理，就会抛出异常</strong>。数据收集主要使用collect方法，该方法也属于归约操作，像reduce()方法那样可以接收各种做法作为参数，将流中的元素累积成一个汇总结果，具体的做法是通过定义新的Collector接口来定义的。</p><h3 id="可以静态导入Collectors和Comparator两个类，这样就不用再去写Collectors-counting-和Comparator-comparing-。"><a href="#可以静态导入Collectors和Comparator两个类，这样就不用再去写Collectors-counting-和Comparator-comparing-。" class="headerlink" title="可以静态导入Collectors和Comparator两个类，这样就不用再去写Collectors.counting()和Comparator.comparing()。"></a>可以静态导入Collectors和Comparator两个类，这样就不用再去写Collectors.counting()和Comparator.comparing()。</h3><pre><code class="hljs gradle"><span class="hljs-keyword">import</span> <span class="hljs-keyword">static</span> java.util.stream.Collectors.*;<span class="hljs-keyword">import</span> <span class="hljs-keyword">static</span> java.util.Comparator.*;<span class="hljs-comment">// 求和</span><span class="hljs-keyword">long</span> <span class="hljs-keyword">count</span> = books.stream().<span class="hljs-keyword">collect</span>(counting());<span class="hljs-comment">// 价格最高的图书</span>Optional&lt;Book&gt; expensive = books.stream().<span class="hljs-keyword">collect</span>(maxBy(comparing(Book::getPrice)));<span class="hljs-comment">// 价格最低的图书</span>Optional&lt;Book&gt; cheapest = books.stream().<span class="hljs-keyword">collect</span>(minBy(comparing(Book::getPrice)));</code></pre><h3 id="收集顺序"><a href="#收集顺序" class="headerlink" title="收集顺序"></a>收集顺序</h3><pre><code class="hljs plain">进有序，出有序；进无序，出无序。</code></pre><h3 id="特定收集器"><a href="#特定收集器" class="headerlink" title="特定收集器"></a>特定收集器</h3><pre><code class="hljs reasonml">stream.collect(<span class="hljs-keyword">to</span><span class="hljs-constructor">Collection(TreeSet::<span class="hljs-params">new</span>)</span>);</code></pre><h3 id="字符串操作joining"><a href="#字符串操作joining" class="headerlink" title="字符串操作joining"></a>字符串操作joining</h3><pre><code class="hljs reasonml"><span class="hljs-comment">//将流中的字符串通过逗号连接成一个新的字符串</span>String str = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Stream</span>.</span></span><span class="hljs-keyword">of</span>(<span class="hljs-string">"A"</span>, <span class="hljs-string">"B"</span>, <span class="hljs-string">"C"</span>, <span class="hljs-string">"D"</span>).collect(joining(<span class="hljs-string">","</span>));List&lt;Integer&gt; data = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Stream</span>.</span></span><span class="hljs-keyword">of</span>(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>).collect(<span class="hljs-keyword">to</span><span class="hljs-constructor">List()</span>);List&lt;Integer&gt; integers = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Arrays</span>.</span></span><span class="hljs-keyword">as</span><span class="hljs-constructor">List(1, 2, 3, 4, 5)</span>;<span class="hljs-comment">//前后缀拼接</span><span class="hljs-comment">//传统for循环</span>StringBuilder sb = <span class="hljs-keyword">new</span> <span class="hljs-constructor">StringBuilder(<span class="hljs-string">"["</span>)</span>;for (Integer num : integers) &#123;    sb.append(num).append(<span class="hljs-string">", "</span>);&#125;sb.append(<span class="hljs-string">"]"</span>);<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(sb);<span class="hljs-comment">//lambda循环（map是为了将int转为string）</span>String str = data.stream<span class="hljs-literal">()</span>.map(String::valueOf).collect(joining(<span class="hljs-string">","</span>, <span class="hljs-string">"["</span>, <span class="hljs-string">"]"</span>));<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(str);</code></pre><h3 id="数据分块（parttitioningBy，将流分解成两个集合），传入一个pridicate对象来判断属于哪部分。"><a href="#数据分块（parttitioningBy，将流分解成两个集合），传入一个pridicate对象来判断属于哪部分。" class="headerlink" title="数据分块（parttitioningBy，将流分解成两个集合），传入一个pridicate对象来判断属于哪部分。"></a>数据分块（parttitioningBy，将流分解成两个集合），传入一个pridicate对象来判断属于哪部分。</h3><pre><code class="hljs pgsql">//数据分块：将数据分成<span class="hljs-keyword">true</span>和<span class="hljs-keyword">false</span>两部分Map&lt;<span class="hljs-type">Boolean</span>, List&lt;<span class="hljs-keyword">User</span>&gt;&gt; res = users.stream().collect(partitioningBy(<span class="hljs-keyword">user</span> -&gt; <span class="hljs-keyword">user</span>.getName().length() &gt; <span class="hljs-number">3</span>));</code></pre><h3 id="数据分组（groupingBy）"><a href="#数据分组（groupingBy）" class="headerlink" title="数据分组（groupingBy）"></a>数据分组（groupingBy）</h3><pre><code class="hljs lasso"><span class="hljs-comment">//数据分组：将数据以某个key值分成多部分</span><span class="hljs-built_in">Map</span>&lt;<span class="hljs-built_in">String</span>, <span class="hljs-built_in">List</span>&lt;User&gt;&gt; result = users.stream().collect(groupingBy(user -&gt; user.getAddress()));<span class="hljs-built_in">Map</span>&lt;<span class="hljs-built_in">String</span>, <span class="hljs-built_in">List</span>&lt;User&gt;&gt; result = users.stream().collect(groupingBy(User<span class="hljs-type">::getAddress</span>));</code></pre><h3 id="组合收集器（下游收集器），在主收集器中应用下级收集器，对结果进行再次封装。"><a href="#组合收集器（下游收集器），在主收集器中应用下级收集器，对结果进行再次封装。" class="headerlink" title="组合收集器（下游收集器），在主收集器中应用下级收集器，对结果进行再次封装。"></a>组合收集器（下游收集器），在主收集器中应用下级收集器，对结果进行再次封装。</h3><pre><code class="hljs reasonml"><span class="hljs-comment">//将数据分组后，不是返回每组的数据，而是统计每组的个数返回。</span>Map&lt;String, Long&gt; collect1 = users.stream<span class="hljs-literal">()</span>.collect(grouping<span class="hljs-constructor">By(User::<span class="hljs-params">getName</span>, <span class="hljs-params">counting</span>()</span>));<span class="hljs-comment">//通过mapping可以进行其他二次收集。</span>Map&lt;String, List&lt;String&gt;&gt; collect2 = users.stream<span class="hljs-literal">()</span>.collect(grouping<span class="hljs-constructor">By(User::<span class="hljs-params">getAddress</span>, <span class="hljs-params">mapping</span>(User::<span class="hljs-params">getName</span>, <span class="hljs-params">toList</span>()</span>) ));函数拆分示例：collect( grouping<span class="hljs-constructor">By(<span class="hljs-params">key1</span>,  <span class="hljs-params">mapping</span>(<span class="hljs-params">key2</span>,  <span class="hljs-params">value</span>)</span>  )  )</code></pre><h2 id="进阶集合操作"><a href="#进阶集合操作" class="headerlink" title="进阶集合操作"></a>进阶集合操作</h2><h3 id="map的foreach循环"><a href="#map的foreach循环" class="headerlink" title="map的foreach循环"></a>map的foreach循环</h3><pre><code class="hljs lasso"><span class="hljs-built_in">Map</span>&lt;<span class="hljs-built_in">String</span>, <span class="hljs-built_in">Integer</span>&gt; <span class="hljs-keyword">cache</span> = <span class="hljs-literal">new</span> HashMap&lt;&gt;();<span class="hljs-built_in">Map</span>&lt;<span class="hljs-built_in">String</span>, <span class="hljs-built_in">List</span>&lt;User&gt;&gt; users = <span class="hljs-literal">new</span> HashMap&lt;<span class="hljs-built_in">String</span>, <span class="hljs-built_in">List</span>&lt;User&gt;&gt;();<span class="hljs-comment">//传统for循环</span>for (<span class="hljs-built_in">Map</span>.Entry&lt;<span class="hljs-built_in">String</span>, <span class="hljs-built_in">List</span>&lt;User&gt;&gt; entry : users.entrySet()) &#123;    <span class="hljs-built_in">String</span> key = entry.getKey();    <span class="hljs-built_in">List</span>&lt;User&gt; value = entry.getValue();    <span class="hljs-keyword">cache</span>.put(key, value.size());&#125;<span class="hljs-comment">//lambda方式</span>users.forEach((key, value) -&gt; &#123;    <span class="hljs-keyword">cache</span>.put(key, value.size());&#125;);</code></pre><h3 id="computeIfAbsent"><a href="#computeIfAbsent" class="headerlink" title="computeIfAbsent"></a>computeIfAbsent</h3><p>根据key获取某个值，若值不存在，丛数据库中取</p><pre><code class="hljs pgsql">//传统方式<span class="hljs-built_in">public</span> List&lt;<span class="hljs-keyword">User</span>&gt; getUserByName(String <span class="hljs-type">name</span>) &#123;    List&lt;<span class="hljs-keyword">User</span>&gt; <span class="hljs-keyword">user</span> = users.<span class="hljs-keyword">get</span>(<span class="hljs-type">name</span>);    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">user</span> == <span class="hljs-keyword">null</span>) &#123;        <span class="hljs-keyword">user</span> = readFromDB(<span class="hljs-type">name</span>);        users.put(<span class="hljs-type">name</span>, <span class="hljs-keyword">user</span>);    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-keyword">user</span>;&#125;//lambda方式<span class="hljs-built_in">public</span> List&lt;<span class="hljs-keyword">User</span>&gt; getUser1ByName(String <span class="hljs-type">name</span>) &#123;    <span class="hljs-keyword">return</span> users.computeIfAbsent(<span class="hljs-type">name</span>, this::readFromDB);&#125;private List&lt;<span class="hljs-keyword">User</span>&gt; readFromDB(String <span class="hljs-type">name</span>) &#123;    <span class="hljs-keyword">return</span> <span class="hljs-built_in">new</span> ArrayList&lt;&gt;();&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>stream</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/blog/2020/05/31/hello-world/"/>
    <url>/blog/2020/05/31/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre><code class="hljs bash">$ hexo new <span class="hljs-string">"My New Post"</span></code></pre><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre><code class="hljs bash">$ hexo server</code></pre><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre><code class="hljs bash">$ hexo generate</code></pre><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre><code class="hljs bash">$ hexo deploy</code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>

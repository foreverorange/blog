<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>java8方法引用理解</title>
      <link href="/blog/2020/05/31/java8%E6%96%B9%E6%B3%95%E5%BC%95%E7%94%A8%E7%90%86%E8%A7%A3/"/>
      <url>/blog/2020/05/31/java8%E6%96%B9%E6%B3%95%E5%BC%95%E7%94%A8%E7%90%86%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h2 id="什么是方法引用"><a href="#什么是方法引用" class="headerlink" title="什么是方法引用?"></a>什么是方法引用?</h2><p>方法引用可用于在不调用方法的情况下引用方法。它将方法视为Lambda表达式。它们只能作为语法糖来减少一些lambdas的冗长。在方法引用中，将包含方法的对象（或类）放在::运算符之前，将方法的名称放在不带参数的方法之后。例如：</p><pre><code class="hljs asciidoc"><span class="hljs-bullet">Object :: </span>methodName</code></pre><h2 id="为什么会出现方法引用？"><a href="#为什么会出现方法引用？" class="headerlink" title="为什么会出现方法引用？"></a>为什么会出现方法引用？</h2><p>在Java中，我们可以通过创建新对象来使用对象的引用,或者引用已有的对象，例如：</p><pre><code class="hljs lasso"><span class="hljs-comment">//创建新对象来引用该对象</span><span class="hljs-built_in">List</span> <span class="hljs-built_in">list</span> = <span class="hljs-literal">new</span> ArrayList();dosth(<span class="hljs-built_in">list</span>);<span class="hljs-comment">//引用已有的对象</span><span class="hljs-built_in">List</span> list2 = <span class="hljs-built_in">list</span>;dosth(list2);</code></pre><p>如果我们只在另一个方法中使用对象的方法，我们仍然必须将完整的对象作为参数传递。那么将方法作为参数传递不是更有效吗？</p><h2 id="方法引用这种语法糖不能用于所有的方法，它们只能用于只有一个方法的lambda表达式"><a href="#方法引用这种语法糖不能用于所有的方法，它们只能用于只有一个方法的lambda表达式" class="headerlink" title="方法引用这种语法糖不能用于所有的方法，它们只能用于只有一个方法的lambda表达式"></a>方法引用这种语法糖不能用于所有的方法，它们只能用于只有一个方法的lambda表达式</h2><pre><code class="hljs arduino"><span class="hljs-comment">//lambda转方法引用</span>Consumer&lt;<span class="hljs-keyword">String</span>&gt; c = s -&gt; System.out.<span class="hljs-built_in">println</span>(s);Consumer&lt;<span class="hljs-keyword">String</span>&gt; c = System.out::<span class="hljs-built_in">println</span>;</code></pre><p>换句话说，可以使用lambda表达式去代替一个匿名类，如果这个匿名类只有一个方法，就可以用更简短的方法引用来代替lambda表达式。</p><h2 id="静态方法引用"><a href="#静态方法引用" class="headerlink" title="静态方法引用"></a>静态方法引用</h2><pre><code class="hljs livescript"><span class="hljs-keyword">from</span><span class="hljs-function"><span class="hljs-params">(args)</span> -&gt;</span> Class.staticMethod(args)<span class="hljs-keyword">to</span>Class::staticMethod</code></pre><p>如上所述，我们不需要显式的传递参数，方法引用中会自动传递参数</p><pre><code class="hljs arduino">Consumer&lt;<span class="hljs-keyword">String</span>&gt; c1 = (s) -&gt; System.out.<span class="hljs-built_in">println</span>(s);Consumer&lt;<span class="hljs-keyword">String</span>&gt; c2 = System.out::<span class="hljs-built_in">println</span>;c2.accept(<span class="hljs-string">"Hello"</span>);</code></pre><p>当我们所使用的lambda表达式仅仅调用了一个静态方法，我们就可以使用静态方法引用。如下所示，将lambda表达式（匿名类）中的值判断提取成isMoreThanFifty这个静态方法，就可以使用静态方法引用这种语法糖。</p><pre><code class="hljs reasonml">public <span class="hljs-keyword">class</span> Numbers &#123;    <span class="hljs-comment">//将值判断提取成静态方法</span>    public static boolean is<span class="hljs-constructor">MoreThanFifty(<span class="hljs-params">int</span> <span class="hljs-params">n1</span>, <span class="hljs-params">int</span> <span class="hljs-params">n2</span>)</span> &#123;        return (n1 + n2) &gt; <span class="hljs-number">50</span>;    &#125;    <span class="hljs-comment">//公共接口方法</span>    public static List&lt;Integer&gt; find<span class="hljs-constructor">Numbers(List&lt;Integer&gt; <span class="hljs-params">l</span>, BiPredicate&lt;Integer, Integer&gt; <span class="hljs-params">p</span>)</span> &#123;        List&lt;Integer&gt; newList = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;<span class="hljs-literal">()</span>;        for (Integer i : l) &#123;            <span class="hljs-keyword">if</span> (p.test(i, i + <span class="hljs-number">10</span>)) &#123;                newList.add(i);            &#125;        &#125;        return newList;    &#125;    public static void main(String<span class="hljs-literal">[]</span> args) &#123;        List&lt;Integer&gt; <span class="hljs-built_in">list</span> = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Arrays</span>.</span></span><span class="hljs-keyword">as</span><span class="hljs-constructor">List(12, 5, 45, 18, 33, 24, 40)</span>;        <span class="hljs-comment">// Using an anonymous class</span>        List&lt;Integer&gt; res = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Numbers</span>.</span></span>find<span class="hljs-constructor">Numbers(<span class="hljs-params">list</span>, <span class="hljs-params">new</span> BiPredicate&lt;Integer, Integer&gt;()</span> &#123;            @Override            public boolean test(Integer integer, Integer integer2) &#123;                return <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Numbers</span>.</span></span>is<span class="hljs-constructor">MoreThanFifty(<span class="hljs-params">integer</span>, <span class="hljs-params">integer2</span>)</span>;            &#125;        &#125;);        res.stream<span class="hljs-literal">()</span>.for<span class="hljs-constructor">Each(System.<span class="hljs-params">out</span> :: <span class="hljs-params">println</span>)</span>;<span class="hljs-comment">//        res.stream().peek(System.out :: println).collect(Collectors.toList());</span>        <span class="hljs-comment">// Using a lambda expression</span>        <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Numbers</span>.</span></span>find<span class="hljs-constructor">Numbers(<span class="hljs-params">list</span>, (<span class="hljs-params">i1</span>, <span class="hljs-params">i2</span>)</span> -&gt; <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Numbers</span>.</span></span>is<span class="hljs-constructor">MoreThanFifty(<span class="hljs-params">i1</span>, <span class="hljs-params">i2</span>)</span>);        <span class="hljs-comment">// Using a method reference</span>        <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Numbers</span>.</span></span>find<span class="hljs-constructor">Numbers(<span class="hljs-params">list</span>, Numbers::<span class="hljs-params">isMoreThanFifty</span>)</span>;    &#125;&#125;</code></pre><h2 id="特定类型的对象的实例方法的方法引用"><a href="#特定类型的对象的实例方法的方法引用" class="headerlink" title="特定类型的对象的实例方法的方法引用"></a>特定类型的对象的实例方法的方法引用</h2><pre><code class="hljs livescript"><span class="hljs-keyword">from</span><span class="hljs-function"><span class="hljs-params">(obj, args)</span> -&gt;</span> obj.instanceMethod(args)<span class="hljs-keyword">to</span>ObjectType::instanceMethod</code></pre><ul><li>我们使用实例的类型而非实例本身</li><li>参数隐式传递<pre><code class="hljs zephir"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">People</span> </span>&#123;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">double</span> calculateWeight() &#123;        <span class="hljs-keyword">double</span> weight = <span class="hljs-number">0</span>;        <span class="hljs-comment">// Calculate weight</span>        <span class="hljs-keyword">return</span> weight;    &#125;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">List</span>&lt;<span class="hljs-keyword">Double</span>&gt; calculateAllWeight(<span class="hljs-keyword">List</span>&lt;People&gt; l, <span class="hljs-function"><span class="hljs-keyword">Function</span>&lt;<span class="hljs-title">People</span>, <span class="hljs-title">Double</span>&gt; <span class="hljs-title">f</span>) </span>&#123;        <span class="hljs-keyword">List</span>&lt;<span class="hljs-keyword">Double</span>&gt; results = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();        <span class="hljs-keyword">for</span> (People s : l) &#123;            results.add(f.apply(s));        &#125;        <span class="hljs-keyword">return</span> results;    &#125;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PeopleClient</span> </span>&#123;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> void main(String[] args) &#123;        <span class="hljs-keyword">List</span>&lt;People&gt; <span class="hljs-keyword">list</span> = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();        People p = <span class="hljs-keyword">new</span> People();        <span class="hljs-comment">// Using an anonymous class</span>        p.calculateAllWeight(<span class="hljs-keyword">list</span>, <span class="hljs-keyword">new</span> <span class="hljs-function"><span class="hljs-keyword">Function</span>&lt;<span class="hljs-title">People</span>, <span class="hljs-title">Double</span>&gt;<span class="hljs-params">()</span> </span>&#123;            @Override            <span class="hljs-keyword">public</span> <span class="hljs-keyword">Double</span> apply(People people) &#123;<span class="hljs-comment">// The object</span>                <span class="hljs-keyword">return</span> people.calculateWeight();<span class="hljs-comment">// The method</span>            &#125;        &#125;);        <span class="hljs-comment">// Using a lambda expression</span>        p.calculateAllWeight(<span class="hljs-keyword">list</span>, people -&gt; people.calculateWeight());        <span class="hljs-comment">// Using a method reference</span>        p.calculateAllWeight(<span class="hljs-keyword">list</span>, People::calculateWeight);    &#125;&#125;</code></pre>在这个例子中，我们没有给方法传递任何参数，关键在于对象的实例是lambda表达式的一个参数，我们通过实例的类型来完成对实例方法的引用。下面是另一个例子，在这个例子中，我们向方法引用中传递了两个参数。<pre><code class="hljs lasso"><span class="hljs-comment">//java中有一个Function接口可以接收一个参数，BiFunction接口接受两个参数，没有接受三个参数的，所以我们自定义一个TriFunction</span>interface TriFunction&lt;T, U, V, R&gt; &#123;  R apply(T t, U u, V v);&#125;<span class="hljs-comment">//然后定义一个类，接收两个参数，并且有一个返回值</span>class <span class="hljs-keyword">Sum</span> &#123;  <span class="hljs-built_in">Integer</span> doSum(<span class="hljs-built_in">String</span> s1, <span class="hljs-built_in">String</span> s2) &#123;    <span class="hljs-keyword">return</span> <span class="hljs-built_in">Integer</span>.parseInt(s1) + <span class="hljs-built_in">Integer</span>.parseInt(s1);  &#125;&#125;<span class="hljs-comment">//用匿名类实现TriFunction，来包装doSum()</span>TriFunction&lt;<span class="hljs-keyword">Sum</span>, <span class="hljs-built_in">String</span>, <span class="hljs-built_in">String</span>, <span class="hljs-built_in">Integer</span>&gt; anonymous =  <span class="hljs-literal">new</span> TriFunction&lt;<span class="hljs-keyword">Sum</span>, <span class="hljs-built_in">String</span>, <span class="hljs-built_in">String</span>, <span class="hljs-built_in">Integer</span>&gt;() &#123;    @Override    <span class="hljs-keyword">public</span> <span class="hljs-built_in">Integer</span> apply(<span class="hljs-keyword">Sum</span> s, <span class="hljs-built_in">String</span> arg1, <span class="hljs-built_in">String</span> arg2) &#123;      <span class="hljs-keyword">return</span> s.doSum(arg1, arg2);    &#125;&#125;;System.out.println(anonymous.apply(<span class="hljs-literal">new</span> <span class="hljs-keyword">Sum</span>(), <span class="hljs-string">"1"</span>, <span class="hljs-string">"4"</span>));<span class="hljs-comment">//使用lambda表达式来包装</span>TriFunction&lt;<span class="hljs-keyword">Sum</span>, <span class="hljs-built_in">String</span>, <span class="hljs-built_in">String</span>, <span class="hljs-built_in">Integer</span>&gt; lambda =  (<span class="hljs-keyword">Sum</span> s, <span class="hljs-built_in">String</span> arg1, <span class="hljs-built_in">String</span> arg2) -&gt; s.doSum(arg1, arg2);System.out.println(lambda.apply(<span class="hljs-literal">new</span> <span class="hljs-keyword">Sum</span>(), <span class="hljs-string">"1"</span>, <span class="hljs-string">"4"</span>));<span class="hljs-comment">//使用方法引用</span>TriFunction&lt;<span class="hljs-keyword">Sum</span>, <span class="hljs-built_in">String</span>, <span class="hljs-built_in">String</span>, <span class="hljs-built_in">Integer</span>&gt; mRef = <span class="hljs-keyword">Sum</span><span class="hljs-type">::doSum</span>;System.out.println(mRef.apply(<span class="hljs-literal">new</span> <span class="hljs-keyword">Sum</span>(), <span class="hljs-string">"1"</span>, <span class="hljs-string">"4"</span>));</code></pre></li><li>第一个参数是要执行的方法的实例对象</li><li>第二、三个参数是传递的其他参数</li><li>最后一个参数是要执行的方法的返回值类型</li></ul><h2 id="已有对象的实例方法引用"><a href="#已有对象的实例方法引用" class="headerlink" title="已有对象的实例方法引用"></a>已有对象的实例方法引用</h2><pre><code class="hljs livescript"><span class="hljs-keyword">from</span><span class="hljs-function"><span class="hljs-params">(args)</span> -&gt;</span> obj.instanceMethod(args)<span class="hljs-keyword">to</span>obj::instanceMethod</code></pre><p>直接引用已经在其他地方实例化的对象的一个方法，本身不需要再实现一次</p><pre><code class="hljs arduino"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Car</span> &#123;</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> id;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">String</span> color;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getId</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> id;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setId</span><span class="hljs-params">(<span class="hljs-keyword">int</span> id)</span> </span>&#123;        <span class="hljs-keyword">this</span>.id = id;    &#125;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Mechanic</span> &#123;</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">fix</span><span class="hljs-params">(Car c)</span> </span>&#123;        System.out.<span class="hljs-built_in">println</span>(<span class="hljs-string">"Fixing car "</span> + c.getId());    &#125;&#125;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">InstanceRef</span> &#123;</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">String</span>[] args)</span> </span>&#123;        InstanceRef instanceRef = <span class="hljs-keyword">new</span> InstanceRef();        <span class="hljs-keyword">final</span> Mechanic mechanic = <span class="hljs-keyword">new</span> Mechanic();        Car car = <span class="hljs-keyword">new</span> Car();        <span class="hljs-comment">// Using an anonymous class</span>        instanceRef.execute(car, <span class="hljs-keyword">new</span> Consumer&lt;Car&gt;() &#123;            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> accept(Car c) &#123;                mechanic.fix(c);            &#125;        &#125;);        <span class="hljs-comment">// Using a lambda expression</span>        instanceRef.execute(car, car1 -&gt; mechanic.fix(car1));        <span class="hljs-comment">//Using a method reference</span>        instanceRef.execute(car, mechanic::fix);    &#125;    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">execute</span><span class="hljs-params">(Car car, Consumer&lt;Car&gt; c)</span> </span>&#123;        c.accept(car);    &#125;&#125;</code></pre><h2 id="构造方法引用"><a href="#构造方法引用" class="headerlink" title="构造方法引用"></a>构造方法引用</h2><pre><code class="hljs livescript"><span class="hljs-keyword">from</span><span class="hljs-function"><span class="hljs-params">(args)</span> -&gt;</span> <span class="hljs-keyword">new</span> ClassName(args)<span class="hljs-keyword">to</span>ClassName::<span class="hljs-keyword">new</span></code></pre><p>这个lambda表达式唯一能做的就是创建一个新对象，我们通过关键字new来引用类的构造函数。与其他情况一样，参数（如果有）不会在方法引用中传递。</p><p><strong>无参构造</strong></p><pre><code class="hljs dart"><span class="hljs-comment">// Using an anonymous class</span>Supplier&lt;<span class="hljs-built_in">List</span>&lt;<span class="hljs-built_in">String</span>&gt;&gt; s = <span class="hljs-keyword">new</span> Supplier() &#123;  public <span class="hljs-built_in">List</span>&lt;<span class="hljs-built_in">String</span>&gt; <span class="hljs-keyword">get</span>() &#123;    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ArrayList&lt;<span class="hljs-built_in">String</span>&gt;();  &#125;&#125;;<span class="hljs-built_in">List</span>&lt;<span class="hljs-built_in">String</span>&gt; l = s.<span class="hljs-keyword">get</span>();<span class="hljs-comment">// Using a lambda expression</span>Supplier&lt;<span class="hljs-built_in">List</span>&lt;<span class="hljs-built_in">String</span>&gt;&gt; s = () -&gt; <span class="hljs-keyword">new</span> ArrayList&lt;<span class="hljs-built_in">String</span>&gt;();<span class="hljs-built_in">List</span>&lt;<span class="hljs-built_in">String</span>&gt; l = s.<span class="hljs-keyword">get</span>();<span class="hljs-comment">// Using a method reference</span>Supplier&lt;<span class="hljs-built_in">List</span>&lt;<span class="hljs-built_in">String</span>&gt;&gt; s = ArrayList::<span class="hljs-keyword">new</span>;<span class="hljs-built_in">List</span>&lt;<span class="hljs-built_in">String</span>&gt; l = s.<span class="hljs-keyword">get</span>();</code></pre><p><strong>带参构造</strong></p><pre><code class="hljs lasso"><span class="hljs-comment">// Using a anonymous class</span>BiFunction&lt;<span class="hljs-built_in">String</span>, <span class="hljs-built_in">String</span>, <span class="hljs-built_in">Locale</span>&gt; f = <span class="hljs-literal">new</span> BiFunction&lt;<span class="hljs-built_in">String</span>, <span class="hljs-built_in">String</span>, <span class="hljs-built_in">Locale</span>&gt;() &#123;  <span class="hljs-keyword">public</span> <span class="hljs-built_in">Locale</span> apply(<span class="hljs-built_in">String</span> lang, <span class="hljs-built_in">String</span> country) &#123;    <span class="hljs-keyword">return</span> <span class="hljs-literal">new</span> <span class="hljs-built_in">Locale</span>(lang, country);  &#125;&#125;;<span class="hljs-built_in">Locale</span> loc = f.apply(<span class="hljs-string">"en"</span>,<span class="hljs-string">"UK"</span>);<span class="hljs-comment">// Using a lambda expression</span>BiFunction&lt;<span class="hljs-built_in">String</span>, <span class="hljs-built_in">String</span>, <span class="hljs-built_in">Locale</span>&gt; f = (lang, country) -&gt; <span class="hljs-literal">new</span> <span class="hljs-built_in">Locale</span>(lang, country);<span class="hljs-built_in">Locale</span> loc = f.apply(<span class="hljs-string">"en"</span>,<span class="hljs-string">"UK"</span>);<span class="hljs-comment">// Using a method reference</span>BiFunction&lt;<span class="hljs-built_in">String</span>, <span class="hljs-built_in">String</span>, <span class="hljs-built_in">Locale</span>&gt; f = <span class="hljs-built_in">Locale</span><span class="hljs-type">::new</span>;<span class="hljs-built_in">Locale</span> loc = f.apply(<span class="hljs-string">"en"</span>,<span class="hljs-string">"UK"</span>);</code></pre><p>如果有三个及以上的参数的构造函数，则必须创建自己的函数接口。引用构造函数与引用静态方法非常相似，区别在于构造函数“方法名称”是new。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>如果使用了方法引用之后能让代码变的更加整洁，就使用它。实际使用中，一种使用方式是将代码包裹在一个方法中，而非使用一个单独的类或者lambda表达式，然后使用方法引用的方式进行调用。方法引用常用于java8的另一种新特性Streams中，而基于方法引用的设计模式也会更加具有拓展性。</p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> stream </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java8新特性之Stream</title>
      <link href="/blog/2020/05/31/java8%E6%96%B0%E7%89%B9%E6%80%A7%E4%B9%8BStream/"/>
      <url>/blog/2020/05/31/java8%E6%96%B0%E7%89%B9%E6%80%A7%E4%B9%8BStream/</url>
      
        <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>Stream API与InputStream和OutputStream是完全不同的概念，<strong>Stream API是对Java中集合操作的增强，可以利用它进行各种过滤、排序、分组、聚合等操作</strong>。Stream API配合Lambda表达式可以加大的提高代码可读性和编码效率，Stream API也支持并行操作。</p><h3 id="流不是集合，它不关心数据的存放，只关注如何处理数据"><a href="#流不是集合，它不关心数据的存放，只关注如何处理数据" class="headerlink" title="流不是集合，它不关心数据的存放，只关注如何处理数据"></a>流不是集合，它不关心数据的存放，只关注如何处理数据</h3><p>Stream API主要用于处理集合操作，不过它的处理方式与传统的方式不同，称为“数据流处理”。流（Stream）类似于关系数据库的查询操作，是一种声明式操作。比如要从数据库中获取所有年龄大于20岁的用户的名称，并按照用户的创建时间进行排序，用一条SQL语句就可以搞定，不过使用Java程序实现就会显得有些繁琐，这时候可以使用流：</p><pre><code class="hljs lasso"><span class="hljs-built_in">List</span>&lt;<span class="hljs-built_in">String</span>&gt; userNames = users.stream()    .filter(user -&gt; user.getAge() &gt; <span class="hljs-number">20</span>)    .sorted(comparing(User<span class="hljs-type">::getCreationDate</span>))    .<span class="hljs-built_in">map</span>(User<span class="hljs-type">::getUserName</span>)    .collect(toList());</code></pre><p>在Java中，集合是一种数据结构，或者说是一种容器，用于存放数据，流不是容器，它不关心数据的存放，只关注如何处理。可以把流当做是Java中的Iterator，不过它比Iterator强大多了。</p><h3 id="流使用内部迭代方式处理数据"><a href="#流使用内部迭代方式处理数据" class="headerlink" title="流使用内部迭代方式处理数据"></a>流使用内部迭代方式处理数据</h3><p>流与集合另一个区别在于他们的遍历方式，遍历集合通常使用for-each方式，这种方式称为外部迭代，而流使用内部迭代方式，也就是说它帮你把迭代的工作做了，你只需要给出一个函数来告诉它接下来要干什么：</p><pre><code class="hljs reasonml"><span class="hljs-comment">// 外部迭代</span>List&lt;String&gt; <span class="hljs-built_in">list</span> = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Arrays</span>.</span></span><span class="hljs-keyword">as</span><span class="hljs-constructor">List(<span class="hljs-string">"A"</span>, <span class="hljs-string">"B"</span>, <span class="hljs-string">"C"</span>, <span class="hljs-string">"D"</span>)</span>;for (String str : <span class="hljs-built_in">list</span>) &#123;    <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(str);&#125;<span class="hljs-comment">// 内部迭代</span><span class="hljs-built_in">list</span>.stream<span class="hljs-literal">()</span>.for<span class="hljs-constructor">Each(System.<span class="hljs-params">out</span>::<span class="hljs-params">println</span>)</span>;</code></pre><p>外部迭代更像是作文题，我们不仅要控制元素的迭代方式，还需要定义怎么操作元素；内部迭代更像是填空题，我们只用关注如何操作元素就可以了。</p><h3 id="流只能遍历一次"><a href="#流只能遍历一次" class="headerlink" title="流只能遍历一次"></a>流只能遍历一次</h3><p>流只能遍历一次，遍历结束后，这个流就被关闭掉了。如果要重新遍历，可以从数据源（集合）中重新获取一个流。如果你对一个流遍历两次，就会抛出java.lang.IllegalStateException异常：</p><pre><code class="hljs reasonml">List&lt;String&gt; <span class="hljs-built_in">list</span> = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Arrays</span>.</span></span><span class="hljs-keyword">as</span><span class="hljs-constructor">List(<span class="hljs-string">"A"</span>, <span class="hljs-string">"B"</span>, <span class="hljs-string">"C"</span>, <span class="hljs-string">"D"</span>)</span>;Stream&lt;String&gt; stream = <span class="hljs-built_in">list</span>.stream<span class="hljs-literal">()</span>;stream.for<span class="hljs-constructor">Each(System.<span class="hljs-params">out</span>::<span class="hljs-params">println</span>)</span>;stream.for<span class="hljs-constructor">Each(System.<span class="hljs-params">out</span>::<span class="hljs-params">println</span>)</span>; <span class="hljs-comment">// 这里会抛出java.lang.IllegalStateException异常，因为流已经被关闭</span></code></pre><h3 id="流通常由三部分构成："><a href="#流通常由三部分构成：" class="headerlink" title="流通常由三部分构成："></a>流通常由三部分构成：</h3><ol><li>数据源：数据源一般用于流的获取，比如本文开头那个过滤用户的例子中users.stream()方法。</li><li>中间处理：中间处理包括对流中元素的一系列处理，如：过滤（filter()），映射（map()），排序（sorted()）。</li><li>终端处理：终端处理会生成结果，结果可以是任何不是流值，如List<String>；也可以不返回结果，如stream.forEach(System.out::println)就是将结果打印到控制台中，并没有返回。</li></ol><h2 id="创建流"><a href="#创建流" class="headerlink" title="创建流"></a>创建流</h2><h3 id="由值创建流"><a href="#由值创建流" class="headerlink" title="由值创建流"></a>由值创建流</h3><p>使用静态方法Stream.of()创建流，该方法接收一个变长参数：</p><pre><code class="hljs arduino"><span class="hljs-built_in">Stream</span>&lt;<span class="hljs-built_in">Stream</span>&gt; stream = <span class="hljs-built_in">Stream</span>.of(<span class="hljs-string">"A"</span>, <span class="hljs-string">"B"</span>, <span class="hljs-string">"C"</span>, <span class="hljs-string">"D"</span>);<span class="hljs-comment">//也可以使用静态方法Stream.empty()创建一个空的流：</span><span class="hljs-built_in">Stream</span>&lt;<span class="hljs-built_in">Stream</span>&gt; stream = <span class="hljs-built_in">Stream</span>.empty();</code></pre><h3 id="由数组、集合-创建流"><a href="#由数组、集合-创建流" class="headerlink" title="由数组、集合 创建流"></a>由数组、集合 创建流</h3><p>使用静态方法Arrays.stream()从数组创建一个流，该方法接收一个数组参数：</p><pre><code class="hljs armasm"><span class="hljs-keyword">String[] </span><span class="hljs-keyword">strs </span>= &#123;<span class="hljs-string">"A"</span>, <span class="hljs-string">"B"</span>, <span class="hljs-string">"C"</span>, <span class="hljs-string">"D"</span>&#125;<span class="hljs-comment">;</span><span class="hljs-keyword">Stream&lt;Stream&gt; </span><span class="hljs-keyword">stream </span>= Arrays.<span class="hljs-keyword">stream(strs);</span></code></pre><h3 id="通过文件生成流"><a href="#通过文件生成流" class="headerlink" title="通过文件生成流"></a>通过文件生成流</h3><p>使用java.nio.file.Files类中的很多静态方法都可以获取流，比如Files.lines()方法，该方法接收一个java.nio.file.Path对象，返回一个由文件行构成的字符串流：</p><pre><code class="hljs reasonml">Stream&lt;String&gt; stream = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Files</span>.</span></span>lines(<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Paths</span>.</span></span>get(<span class="hljs-string">"text.txt"</span>), <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Charset</span>.</span></span>default<span class="hljs-constructor">Charset()</span>);</code></pre><h3 id="通过函数创建流"><a href="#通过函数创建流" class="headerlink" title="通过函数创建流"></a>通过函数创建流</h3><p>java.util.stream.Stream中有两个静态方法用于从函数生成流，他们分别是Stream.generate()和Stream.iterate()：</p><pre><code class="hljs reasonml"><span class="hljs-comment">// iteartor 打印100以内的所有偶数</span><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Stream</span>.</span></span>iterate(<span class="hljs-number">0</span>, n -&gt; n + <span class="hljs-number">2</span>).limit(<span class="hljs-number">51</span>).for<span class="hljs-constructor">Each(System.<span class="hljs-params">out</span>::<span class="hljs-params">println</span>)</span>;<span class="hljs-comment">// generate 打印10个Hello Man!</span><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Stream</span>.</span></span>generate(<span class="hljs-literal">()</span> -&gt; <span class="hljs-string">"Hello Man!"</span>).limit(<span class="hljs-number">10</span>).for<span class="hljs-constructor">Each(System.<span class="hljs-params">out</span>::<span class="hljs-params">println</span>)</span>;</code></pre><p>值得注意的是，这两个方法生成的流都是无限流，没有固定大小，可以无穷的计算下去，可以使用limit()来限制边界。</p><pre><code class="hljs reasonml"><span class="hljs-comment">//一般来说，iterate()用于生成一系列值，比如生成以当前时间开始之后的10天的日期：</span><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Stream</span>.</span></span>iterate(<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">LocalDate</span>.</span></span>now<span class="hljs-literal">()</span>, date -&gt; date.plus<span class="hljs-constructor">Days(1)</span>).limit(<span class="hljs-number">10</span>).for<span class="hljs-constructor">Each(System.<span class="hljs-params">out</span>::<span class="hljs-params">println</span>)</span>;<span class="hljs-comment">//generate()方法用于生成一些随机数，比如生成10个UUID：</span><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Stream</span>.</span></span>generate(<span class="hljs-literal">()</span> -&gt; <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">UUID</span>.</span></span>random<span class="hljs-constructor">UUID()</span>.<span class="hljs-keyword">to</span><span class="hljs-constructor">String()</span>).limit(<span class="hljs-number">10</span>).for<span class="hljs-constructor">Each(System.<span class="hljs-params">out</span>::<span class="hljs-params">println</span>)</span>;</code></pre><h3 id="collect-toList-将流中的值转换为集合"><a href="#collect-toList-将流中的值转换为集合" class="headerlink" title="collect(toList())将流中的值转换为集合"></a>collect(toList())将流中的值转换为集合</h3><pre><code class="hljs reasonml"><span class="hljs-comment">//of从初识值生成新的stream，再通过collect(toList())生成新的集合</span>List&lt;String&gt; collect = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Stream</span>.</span></span><span class="hljs-keyword">of</span>(<span class="hljs-string">"aa"</span>, <span class="hljs-string">"bb"</span>, <span class="hljs-string">"cc"</span>, <span class="hljs-string">"aa"</span>, <span class="hljs-string">"bb"</span>).collect(<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Collectors</span>.</span></span><span class="hljs-keyword">to</span><span class="hljs-constructor">List()</span>);</code></pre><p>of是惰性求值，不生成新的集合，通过collect(toList())这种及早求值才生成新的集合。返回值是stream就是惰性求值，返回值为另一个值或者空就是及早求值。</p><h3 id="惰性求值与及早求值的区别"><a href="#惰性求值与及早求值的区别" class="headerlink" title="惰性求值与及早求值的区别"></a>惰性求值与及早求值的区别</h3><pre><code class="hljs processing"><span class="hljs-comment">//如下加count就是及早求值，会sout输出strs。不加count，程序不输出任何信息</span>strs.stream().<span class="hljs-built_in">filter</span>(<span class="hljs-built_in">str</span> -&gt; &#123;    System.out.<span class="hljs-built_in">println</span>(<span class="hljs-built_in">str</span>);    <span class="hljs-keyword">return</span> <span class="hljs-built_in">str</span>.startsWith(<span class="hljs-string">"a"</span>);&#125;).count();</code></pre><p>过滤+计数，只循环了一次。只执行fileter会返回一个stream，他不是一个新集合，仅仅是创建新集合的配方。</p><h2 id="流常用方法"><a href="#流常用方法" class="headerlink" title="流常用方法"></a>流常用方法</h2><h3 id="过滤和排序"><a href="#过滤和排序" class="headerlink" title="过滤和排序"></a>过滤和排序</h3><pre><code class="hljs angelscript">Stream.of(<span class="hljs-number">1</span>, <span class="hljs-number">8</span>, <span class="hljs-number">5</span>, <span class="hljs-number">2</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">9</span>, <span class="hljs-number">2</span>, <span class="hljs-number">0</span>, <span class="hljs-number">4</span>, <span class="hljs-number">8</span>)    .filter(n -&gt; n &gt; <span class="hljs-number">2</span>)     <span class="hljs-comment">// 对元素过滤，保留大于2的元素</span>    .distinct()             <span class="hljs-comment">// 去重，类似于SQL语句中的DISTINCT</span>    .skip(<span class="hljs-number">1</span>)                <span class="hljs-comment">// 跳过前面1个元素</span>    .limit(<span class="hljs-number">2</span>)               <span class="hljs-comment">// 返回开头2个元素，类似于SQL语句中的SELECT TOP</span>    .sorted()               <span class="hljs-comment">// 对结果排序</span>    .forEach(System.<span class="hljs-keyword">out</span>::println);</code></pre><p>filter 对集合的值进行过滤，必须返回true或者false</p><h3 id="查找和匹配"><a href="#查找和匹配" class="headerlink" title="查找和匹配"></a>查找和匹配</h3><pre><code class="hljs reasonml"><span class="hljs-comment">//检查流中的任意元素是否包含字符串"PHP"</span>boolean match1 = get<span class="hljs-constructor">Stream()</span>.any<span class="hljs-constructor">Match(<span class="hljs-params">s</span> -&gt; <span class="hljs-params">s</span>.<span class="hljs-params">equals</span>(<span class="hljs-string">"PHP"</span>)</span>);<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(match1);boolean match2 = get<span class="hljs-constructor">Stream()</span>.collect(<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Collectors</span>.</span></span><span class="hljs-keyword">to</span><span class="hljs-constructor">List()</span>).contains(<span class="hljs-string">"PHP"</span>);<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(match2);<span class="hljs-comment">// 检查流中的所有元素是否都包含字符串"#"</span>boolean hasAllMatch = get<span class="hljs-constructor">Stream()</span>.all<span class="hljs-constructor">Match(<span class="hljs-params">s</span> -&gt; <span class="hljs-params">s</span>.<span class="hljs-params">contains</span>(<span class="hljs-string">"#"</span>)</span>);<span class="hljs-comment">// 检查流中的任意元素是否没有以"C"开头的字符串</span>boolean hasNoneMatch = get<span class="hljs-constructor">Stream()</span>.none<span class="hljs-constructor">Match(<span class="hljs-params">s</span> -&gt; <span class="hljs-params">s</span>.<span class="hljs-params">startsWith</span>(<span class="hljs-string">"C"</span>)</span>);<span class="hljs-comment">// 查找元素</span>Optional&lt;String&gt; element = get<span class="hljs-constructor">Stream()</span>.ilter(s -&gt; s.contains(<span class="hljs-string">"C"</span>))    <span class="hljs-comment">// .findFirst()     // 查找第一个元素</span>    .find<span class="hljs-constructor">Any()</span>;         <span class="hljs-comment">// 查找任意元素</span> <span class="hljs-comment">//获取初始流   </span><span class="hljs-keyword">private</span> static Stream&lt;String&gt; get<span class="hljs-constructor">Stream()</span> &#123;    return <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Stream</span>.</span></span><span class="hljs-keyword">of</span>(<span class="hljs-string">"Java"</span>, <span class="hljs-string">"C#"</span>, <span class="hljs-string">"PHP"</span>, <span class="hljs-string">"C++"</span>, <span class="hljs-string">"Python"</span>);&#125;</code></pre><ol><li>每次都需要重新getStream()来获取新的流，因为之前的流已经使用并且关闭了。可以理解为若返回值不是stream，则表示已经结束了流操作</li><li>findAny的返回类型是一个Optional<T>类（java.util.Optional），它一个容器类，代表一个值存在或不存在，用来避免控制正异常。</li><li>findFirst()和findAny()返回的都是第一个元素，通过查看javadoc描述，大致意思是findAny()是为了提高并行操作时的性能。数据大时可findany。</li></ol><h3 id="归约"><a href="#归约" class="headerlink" title="归约"></a>归约</h3><p>归约操作就是将流中的元素进行合并，形成一个新的值，常见的归约操作包括求和，求最大值或最小值。归约操作一般使用reduce()方法，与map()方法搭配使用，可以处理一些很复杂的归约操作。</p><pre><code class="hljs lasso"><span class="hljs-comment">// 获取流</span><span class="hljs-built_in">List</span>&lt;Book&gt; books = Arrays.asList(   <span class="hljs-literal">new</span> Book(<span class="hljs-string">"Java编程思想"</span>, <span class="hljs-string">"Bruce Eckel"</span>, <span class="hljs-string">"机械工业出版社"</span>, <span class="hljs-number">108.00</span>D),   <span class="hljs-literal">new</span> Book(<span class="hljs-string">"Java 8实战"</span>, <span class="hljs-string">"Mario Fusco"</span>, <span class="hljs-string">"人民邮电出版社"</span>, <span class="hljs-number">79.00</span>D),   <span class="hljs-literal">new</span> Book(<span class="hljs-string">"MongoDB权威指南（第2版）"</span>, <span class="hljs-string">"Kristina Chodorow"</span>, <span class="hljs-string">"人民邮电出版社"</span>, <span class="hljs-number">69.00</span>D));<span class="hljs-comment">// 计算所有图书的总价</span>Optional&lt;Double&gt; totalPrice = books.stream()       .<span class="hljs-built_in">map</span>(Book<span class="hljs-type">::getPrice</span>)       .reduce((n, m) -&gt; n + m);<span class="hljs-comment">// 价格最高的图书</span>Optional&lt;Book&gt; expensive = books.stream().<span class="hljs-keyword">max</span>(Comparator.comparing(Book<span class="hljs-type">::getPrice</span>));<span class="hljs-comment">// 价格最低的图书</span>Optional&lt;Book&gt; cheapest = books.stream().<span class="hljs-keyword">min</span>(Comparator.comparing(Book<span class="hljs-type">::getPrice</span>));<span class="hljs-comment">// 计算总数</span>long count = books.stream().count()</code></pre><h3 id="reduce从一组值中生成一个值，如累加。"><a href="#reduce从一组值中生成一个值，如累加。" class="headerlink" title="reduce从一组值中生成一个值，如累加。"></a>reduce从一组值中生成一个值，如累加。</h3><pre><code class="hljs angelscript"><span class="hljs-comment">//0初始值，total总值，index循环的每一个值。</span>Integer num = Stream.of(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>).reduce(<span class="hljs-number">0</span>, (total, index) -&gt; total + index);</code></pre><h3 id="max-min-传入comparator进行大小比较，返回Optional对象"><a href="#max-min-传入comparator进行大小比较，返回Optional对象" class="headerlink" title="max(min) 传入comparator进行大小比较，返回Optional对象"></a>max(min) 传入comparator进行大小比较，返回Optional对象</h3><pre><code class="hljs maxima">//Optional对象(代表一个可能存在也可能不存在的值，NPE方案),通过<span class="hljs-built_in">get</span>拿到Optional对象中的值Integer <span class="hljs-built_in">integer</span> = Stream.of(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>).<span class="hljs-built_in">min</span>(Comparator.comparing(<span class="hljs-built_in">num</span> -&gt; <span class="hljs-built_in">num</span>)).<span class="hljs-built_in">get</span>();</code></pre><h3 id="map-将流中的值转换为新值"><a href="#map-将流中的值转换为新值" class="headerlink" title="map 将流中的值转换为新值"></a>map 将流中的值转换为新值</h3><pre><code class="hljs reasonml"><span class="hljs-comment">//将list小写处理成大写</span><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Stream</span>.</span></span><span class="hljs-keyword">of</span>(<span class="hljs-string">"aa"</span>, <span class="hljs-string">"bb"</span>, <span class="hljs-string">"cc"</span>, <span class="hljs-string">"aa"</span>, <span class="hljs-string">"bb"</span>).map(str -&gt; str.<span class="hljs-keyword">to</span><span class="hljs-constructor">UpperCase()</span>).collect(<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Collectors</span>.</span></span><span class="hljs-keyword">to</span><span class="hljs-constructor">List()</span>);</code></pre><h3 id="flatmap-把多个stream合并成一个stream并返回"><a href="#flatmap-把多个stream合并成一个stream并返回" class="headerlink" title="flatmap 把多个stream合并成一个stream并返回"></a>flatmap 把多个stream合并成一个stream并返回</h3><p>与map()方法类似的还有一个flatMap()，flatMap()方法让你把一个流中的每个值都换成另一个流，然后把所有的流连接起来成为一个新的流。</p><pre><code class="hljs reasonml"><span class="hljs-comment">//传统for循环</span>List&lt;String&gt; names0 = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;<span class="hljs-literal">()</span>;for (Company company : data) &#123;    List&lt;User&gt; users = company.get<span class="hljs-constructor">Uesrs()</span>;    for (User user : users) &#123;        <span class="hljs-keyword">if</span> (user.get<span class="hljs-constructor">Age()</span> &gt; <span class="hljs-number">30</span>) &#123;            names0.add(user.get<span class="hljs-constructor">Name()</span>);        &#125;    &#125;&#125;<span class="hljs-comment">//lambda方式1</span>List&lt;String&gt; names1 = data.stream<span class="hljs-literal">()</span>    .flat<span class="hljs-constructor">Map(<span class="hljs-params">company</span> -&gt; <span class="hljs-params">company</span>.<span class="hljs-params">getUesrs</span>()</span>.stream<span class="hljs-literal">()</span>)    .filter(user -&gt; user.get<span class="hljs-constructor">Age()</span> &gt; <span class="hljs-number">30</span>)    .map(user -&gt; user.get<span class="hljs-constructor">Name()</span>)    .collect(<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Collectors</span>.</span></span><span class="hljs-keyword">to</span><span class="hljs-constructor">List()</span>);<span class="hljs-comment">//lambda方式2</span>List&lt;String&gt; names2 = data.stream<span class="hljs-literal">()</span>    .map(Company::getUesrs)    .flat<span class="hljs-constructor">Map(Collection::<span class="hljs-params">stream</span>)</span>    .filter(user -&gt; user.get<span class="hljs-constructor">Age()</span> &gt; <span class="hljs-number">30</span>)    .map(User::getName)    .collect(<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Collectors</span>.</span></span><span class="hljs-keyword">to</span><span class="hljs-constructor">List()</span>);</code></pre><p>使用flatMap()方法的效果是，各个数组并不是分别映射成一个流，而是映射成流的内容。所有使用map(Arrays::stream)时生成的单个流都被合并起来，也就是对流扁平化操作。</p><h3 id="peek-用于记录中间值（输出流中的值），不会改变流。一般用作日志输出，断点调试。"><a href="#peek-用于记录中间值（输出流中的值），不会改变流。一般用作日志输出，断点调试。" class="headerlink" title="peek 用于记录中间值（输出流中的值），不会改变流。一般用作日志输出，断点调试。"></a>peek 用于记录中间值（输出流中的值），不会改变流。一般用作日志输出，断点调试。</h3><pre><code class="hljs reasonml">List&lt;Integer&gt; nums = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Stream</span>.</span></span><span class="hljs-keyword">of</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>).collect(<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Collectors</span>.</span></span><span class="hljs-keyword">to</span><span class="hljs-constructor">List()</span>);nums.stream<span class="hljs-literal">()</span>.filter(num -&gt; num &gt; <span class="hljs-number">3</span>).peek(num -&gt; &#123;    <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(num);&#125;).collect(<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Collectors</span>.</span></span><span class="hljs-keyword">to</span><span class="hljs-constructor">List()</span>);</code></pre><h2 id="数据收集"><a href="#数据收集" class="headerlink" title="数据收集"></a>数据收集</h2><p>前面总结了如何创建流以及流处理，接下来总结下数据收集。数据收集是流式数据处理的终端处理，<strong>与中间处理不同的是，终端处理会消耗流，也就是说，终端处理之后，这个流就会被关闭，如果再进行中间处理，就会抛出异常</strong>。数据收集主要使用collect方法，该方法也属于归约操作，像reduce()方法那样可以接收各种做法作为参数，将流中的元素累积成一个汇总结果，具体的做法是通过定义新的Collector接口来定义的。</p><h3 id="可以静态导入Collectors和Comparator两个类，这样就不用再去写Collectors-counting-和Comparator-comparing-。"><a href="#可以静态导入Collectors和Comparator两个类，这样就不用再去写Collectors-counting-和Comparator-comparing-。" class="headerlink" title="可以静态导入Collectors和Comparator两个类，这样就不用再去写Collectors.counting()和Comparator.comparing()。"></a>可以静态导入Collectors和Comparator两个类，这样就不用再去写Collectors.counting()和Comparator.comparing()。</h3><pre><code class="hljs gradle"><span class="hljs-keyword">import</span> <span class="hljs-keyword">static</span> java.util.stream.Collectors.*;<span class="hljs-keyword">import</span> <span class="hljs-keyword">static</span> java.util.Comparator.*;<span class="hljs-comment">// 求和</span><span class="hljs-keyword">long</span> <span class="hljs-keyword">count</span> = books.stream().<span class="hljs-keyword">collect</span>(counting());<span class="hljs-comment">// 价格最高的图书</span>Optional&lt;Book&gt; expensive = books.stream().<span class="hljs-keyword">collect</span>(maxBy(comparing(Book::getPrice)));<span class="hljs-comment">// 价格最低的图书</span>Optional&lt;Book&gt; cheapest = books.stream().<span class="hljs-keyword">collect</span>(minBy(comparing(Book::getPrice)));</code></pre><h3 id="收集顺序"><a href="#收集顺序" class="headerlink" title="收集顺序"></a>收集顺序</h3><pre><code class="hljs plain">进有序，出有序；进无序，出无序。</code></pre><h3 id="特定收集器"><a href="#特定收集器" class="headerlink" title="特定收集器"></a>特定收集器</h3><pre><code class="hljs reasonml">stream.collect(<span class="hljs-keyword">to</span><span class="hljs-constructor">Collection(TreeSet::<span class="hljs-params">new</span>)</span>);</code></pre><h3 id="字符串操作joining"><a href="#字符串操作joining" class="headerlink" title="字符串操作joining"></a>字符串操作joining</h3><pre><code class="hljs reasonml"><span class="hljs-comment">//将流中的字符串通过逗号连接成一个新的字符串</span>String str = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Stream</span>.</span></span><span class="hljs-keyword">of</span>(<span class="hljs-string">"A"</span>, <span class="hljs-string">"B"</span>, <span class="hljs-string">"C"</span>, <span class="hljs-string">"D"</span>).collect(joining(<span class="hljs-string">","</span>));List&lt;Integer&gt; data = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Stream</span>.</span></span><span class="hljs-keyword">of</span>(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>).collect(<span class="hljs-keyword">to</span><span class="hljs-constructor">List()</span>);List&lt;Integer&gt; integers = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Arrays</span>.</span></span><span class="hljs-keyword">as</span><span class="hljs-constructor">List(1, 2, 3, 4, 5)</span>;<span class="hljs-comment">//前后缀拼接</span><span class="hljs-comment">//传统for循环</span>StringBuilder sb = <span class="hljs-keyword">new</span> <span class="hljs-constructor">StringBuilder(<span class="hljs-string">"["</span>)</span>;for (Integer num : integers) &#123;    sb.append(num).append(<span class="hljs-string">", "</span>);&#125;sb.append(<span class="hljs-string">"]"</span>);<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(sb);<span class="hljs-comment">//lambda循环（map是为了将int转为string）</span>String str = data.stream<span class="hljs-literal">()</span>.map(String::valueOf).collect(joining(<span class="hljs-string">","</span>, <span class="hljs-string">"["</span>, <span class="hljs-string">"]"</span>));<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(str);</code></pre><h3 id="数据分块（parttitioningBy，将流分解成两个集合），传入一个pridicate对象来判断属于哪部分。"><a href="#数据分块（parttitioningBy，将流分解成两个集合），传入一个pridicate对象来判断属于哪部分。" class="headerlink" title="数据分块（parttitioningBy，将流分解成两个集合），传入一个pridicate对象来判断属于哪部分。"></a>数据分块（parttitioningBy，将流分解成两个集合），传入一个pridicate对象来判断属于哪部分。</h3><pre><code class="hljs pgsql">//数据分块：将数据分成<span class="hljs-keyword">true</span>和<span class="hljs-keyword">false</span>两部分Map&lt;<span class="hljs-type">Boolean</span>, List&lt;<span class="hljs-keyword">User</span>&gt;&gt; res = users.stream().collect(partitioningBy(<span class="hljs-keyword">user</span> -&gt; <span class="hljs-keyword">user</span>.getName().length() &gt; <span class="hljs-number">3</span>));</code></pre><h3 id="数据分组（groupingBy）"><a href="#数据分组（groupingBy）" class="headerlink" title="数据分组（groupingBy）"></a>数据分组（groupingBy）</h3><pre><code class="hljs lasso"><span class="hljs-comment">//数据分组：将数据以某个key值分成多部分</span><span class="hljs-built_in">Map</span>&lt;<span class="hljs-built_in">String</span>, <span class="hljs-built_in">List</span>&lt;User&gt;&gt; result = users.stream().collect(groupingBy(user -&gt; user.getAddress()));<span class="hljs-built_in">Map</span>&lt;<span class="hljs-built_in">String</span>, <span class="hljs-built_in">List</span>&lt;User&gt;&gt; result = users.stream().collect(groupingBy(User<span class="hljs-type">::getAddress</span>));</code></pre><h3 id="组合收集器（下游收集器），在主收集器中应用下级收集器，对结果进行再次封装。"><a href="#组合收集器（下游收集器），在主收集器中应用下级收集器，对结果进行再次封装。" class="headerlink" title="组合收集器（下游收集器），在主收集器中应用下级收集器，对结果进行再次封装。"></a>组合收集器（下游收集器），在主收集器中应用下级收集器，对结果进行再次封装。</h3><pre><code class="hljs reasonml"><span class="hljs-comment">//将数据分组后，不是返回每组的数据，而是统计每组的个数返回。</span>Map&lt;String, Long&gt; collect1 = users.stream<span class="hljs-literal">()</span>.collect(grouping<span class="hljs-constructor">By(User::<span class="hljs-params">getName</span>, <span class="hljs-params">counting</span>()</span>));<span class="hljs-comment">//通过mapping可以进行其他二次收集。</span>Map&lt;String, List&lt;String&gt;&gt; collect2 = users.stream<span class="hljs-literal">()</span>.collect(grouping<span class="hljs-constructor">By(User::<span class="hljs-params">getAddress</span>, <span class="hljs-params">mapping</span>(User::<span class="hljs-params">getName</span>, <span class="hljs-params">toList</span>()</span>) ));函数拆分示例：collect( grouping<span class="hljs-constructor">By(<span class="hljs-params">key1</span>,  <span class="hljs-params">mapping</span>(<span class="hljs-params">key2</span>,  <span class="hljs-params">value</span>)</span>  )  )</code></pre><h2 id="进阶集合操作"><a href="#进阶集合操作" class="headerlink" title="进阶集合操作"></a>进阶集合操作</h2><h3 id="map的foreach循环"><a href="#map的foreach循环" class="headerlink" title="map的foreach循环"></a>map的foreach循环</h3><pre><code class="hljs lasso"><span class="hljs-built_in">Map</span>&lt;<span class="hljs-built_in">String</span>, <span class="hljs-built_in">Integer</span>&gt; <span class="hljs-keyword">cache</span> = <span class="hljs-literal">new</span> HashMap&lt;&gt;();<span class="hljs-built_in">Map</span>&lt;<span class="hljs-built_in">String</span>, <span class="hljs-built_in">List</span>&lt;User&gt;&gt; users = <span class="hljs-literal">new</span> HashMap&lt;<span class="hljs-built_in">String</span>, <span class="hljs-built_in">List</span>&lt;User&gt;&gt;();<span class="hljs-comment">//传统for循环</span>for (<span class="hljs-built_in">Map</span>.Entry&lt;<span class="hljs-built_in">String</span>, <span class="hljs-built_in">List</span>&lt;User&gt;&gt; entry : users.entrySet()) &#123;    <span class="hljs-built_in">String</span> key = entry.getKey();    <span class="hljs-built_in">List</span>&lt;User&gt; value = entry.getValue();    <span class="hljs-keyword">cache</span>.put(key, value.size());&#125;<span class="hljs-comment">//lambda方式</span>users.forEach((key, value) -&gt; &#123;    <span class="hljs-keyword">cache</span>.put(key, value.size());&#125;);</code></pre><h3 id="computeIfAbsent"><a href="#computeIfAbsent" class="headerlink" title="computeIfAbsent"></a>computeIfAbsent</h3><p>根据key获取某个值，若值不存在，丛数据库中取</p><pre><code class="hljs pgsql">//传统方式<span class="hljs-built_in">public</span> List&lt;<span class="hljs-keyword">User</span>&gt; getUserByName(String <span class="hljs-type">name</span>) &#123;    List&lt;<span class="hljs-keyword">User</span>&gt; <span class="hljs-keyword">user</span> = users.<span class="hljs-keyword">get</span>(<span class="hljs-type">name</span>);    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">user</span> == <span class="hljs-keyword">null</span>) &#123;        <span class="hljs-keyword">user</span> = readFromDB(<span class="hljs-type">name</span>);        users.put(<span class="hljs-type">name</span>, <span class="hljs-keyword">user</span>);    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-keyword">user</span>;&#125;//lambda方式<span class="hljs-built_in">public</span> List&lt;<span class="hljs-keyword">User</span>&gt; getUser1ByName(String <span class="hljs-type">name</span>) &#123;    <span class="hljs-keyword">return</span> users.computeIfAbsent(<span class="hljs-type">name</span>, this::readFromDB);&#125;private List&lt;<span class="hljs-keyword">User</span>&gt; readFromDB(String <span class="hljs-type">name</span>) &#123;    <span class="hljs-keyword">return</span> <span class="hljs-built_in">new</span> ArrayList&lt;&gt;();&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> stream </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/blog/2020/05/31/hello-world/"/>
      <url>/blog/2020/05/31/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre><code class="hljs bash">$ hexo new <span class="hljs-string">"My New Post"</span></code></pre><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre><code class="hljs bash">$ hexo server</code></pre><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre><code class="hljs bash">$ hexo generate</code></pre><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre><code class="hljs bash">$ hexo deploy</code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>

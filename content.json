{"meta":{"title":"foreverorange","subtitle":"","description":"","author":"foreverorange","url":"http://yoursite.com","root":"/blog/"},"pages":[{"title":"about","date":"2020-02-23T11:20:33.000Z","updated":"2020-05-31T02:56:02.816Z","comments":true,"path":"about/index.html","permalink":"http://yoursite.com/about/index.html","excerpt":"","text":"这里写关于页的正文，支持 Markdown, HTML"}],"posts":[{"title":"生产者消费者","slug":"生产者消费者","date":"2020-06-05T13:44:03.000Z","updated":"2020-06-06T09:10:01.265Z","comments":true,"path":"2020/06/05/生产者消费者/","link":"","permalink":"http://yoursite.com/2020/06/05/%E7%94%9F%E4%BA%A7%E8%80%85%E6%B6%88%E8%B4%B9%E8%80%85/","excerpt":"","text":"一、生产者消费者生产者和消费者在同一时间段内共用同一段存储空间，生产者put数据，消费者take数据 阻塞队列就相当于一个缓冲区，平衡了生产者和消费者的处理能力，将他们解耦。 二、四种实现生产者消费者模型1、Object的wait() / notify()方法wait/notify 是Object的方法，因此我们可以给任何对象实现同步机制。 wait：当缓冲区满时，生产者/消费者放弃锁，让度cpu，使自己处于等待状态。 notify：当生产者/消费者 生产/消费 时，放弃锁，向其他线程发出可执行的通知，使自己处于等待状态。 public class ProducerConsumer &#123; private static final int CAPACITY = 5; private static final Queue&lt;Integer&gt; queue = new LinkedList&lt;Integer&gt;(); public static void main(String[] args) &#123; // 模拟生产者 for (int i = 0; i &lt; 3; i++) &#123; new Thread(()-&gt; produce(),\"procuder-\"+ i).start(); &#125; // 模拟消费者 for (int i = 0; i &lt; 5; i++) &#123; new Thread(()-&gt; consume(),\"consumer-\"+ i).start(); &#125; // 主线程睡眠，便于看效果 try &#123; TimeUnit.SECONDS.sleep(2); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.exit(0); &#125; private static void consume() &#123; while (true) &#123; synchronized (queue) &#123; while (queue.isEmpty()) &#123; try &#123; // 空队列，则不能消费 System.out.println(Thread.currentThread().getName() + \" 等待生产\"); queue.wait(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; // 队列不为空，则正常消费 Integer poll = queue.poll(); System.out.println(Thread.currentThread().getName() + \" 消费了\" + poll); queue.notifyAll(); // 线程睡眠，便于看效果 try &#123; TimeUnit.MILLISECONDS.sleep(100); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125; private static void produce() &#123; int k = 0; while (true) &#123; synchronized (queue) &#123; while (queue.size() == CAPACITY) &#123; try &#123; // 满了则wait System.out.println(Thread.currentThread().getName() + \" 等待消费\"); queue.wait(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; // 没满则往queue中添加元素 System.out.println(Thread.currentThread().getName() + \" 生产了\" + k); queue.offer(k++); queue.notifyAll(); // 线程睡眠，便于看效果 try &#123; TimeUnit.MILLISECONDS.sleep(100); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125; &#125; 使用while进行size=queueSize、isEmpty的判断，使用if会造成虚假唤醒。 2、Lock中condition的await()/signal()方法通过在lock对象上调用newCondition()，将变量和锁对象进行绑定，进而控制并发资源的安全。 public class LockCondition &#123; private static final int CAPACITY = 5; private static final ReentrantLock lock = new ReentrantLock(); private static final Condition fullCondition = lock.newCondition(); private static final Condition emptyCondition = lock.newCondition(); private static final Queue&lt;Integer&gt; queue = new LinkedList&lt;&gt;(); public static void main(String[] args) &#123; for (int i = 0; i &lt; 3; i++) &#123; new Thread(() -&gt; produce(), \"product-\" + i).start(); &#125; for (int i = 0; i &lt; 3; i++) &#123; new Thread(() -&gt; consume(), \"consumer-\" + i).start(); &#125; // 主线程睡眠，便于看效果 try &#123; TimeUnit.SECONDS.sleep(2); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.exit(0); &#125; private static void consume() &#123; while (true) &#123; if (lock.tryLock()) &#123; try &#123; while (queue.isEmpty()) &#123; // 队列为空，释放锁，通知生产者去生产 System.out.println(Thread.currentThread().getName() + \" 队列为空，等待生产\"); emptyCondition.await(); &#125; Integer poll = queue.poll(); System.out.println(Thread.currentThread().getName() + \" 消费了 \" + poll); //唤醒其他所有生产者、消费者 fullCondition.signalAll(); emptyCondition.signalAll(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; finally &#123; if (lock.isHeldByCurrentThread()) &#123; lock.unlock(); &#125; &#125; &#125; // 线程睡眠，便于看效果 try &#123; TimeUnit.MILLISECONDS.sleep(new Random().nextInt(100)); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125; private static void produce() &#123; while (true) &#123; int k = 0; if (lock.tryLock()) &#123; try &#123; while (queue.size() == CAPACITY) &#123; // 队列满了，释放锁，通知消费者去消费 System.out.println(Thread.currentThread().getName() + \" 队列满了，等待消费\"); fullCondition.await(); &#125; System.out.println(Thread.currentThread().getName() + \" 生产了\" + k); queue.offer(k++); //唤醒其他所有生产者、消费者 emptyCondition.signalAll(); fullCondition.signalAll(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; finally &#123; if (lock.isHeldByCurrentThread()) &#123; lock.unlock(); &#125; &#125; &#125; // 线程睡眠，便于看效果 try &#123; TimeUnit.MILLISECONDS.sleep(new Random().nextInt(100)); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125; await和signal需组合使用。在案例中阻塞时用了await，但是唤醒时用的notify，导致运行过程中一直报错IllegalMonitorStateException 3、使用blockQueue阻塞队列方法jdk对2方式的一种封装，可直接使用。 在juc下，有ArrayBlockingQueue、LinkedBlockingQueue、SynchronousQueue、PriorityBlockingQueue四种实现。 实现生产者-消费者模型使用 ArrayBlockingQueue或者 LinkedBlockingQueue即可。 public class MyBlockingQueue &#123; private static final int CAPICITY = 3; private static final int MAX = 30; private static final LinkedBlockingQueue&lt;Integer&gt; queue = new LinkedBlockingQueue&lt;&gt;(CAPICITY); public static void main(String[] args) &#123; for (int i = 0; i &lt; 3; i++) &#123; new Thread(() -&gt; produce(), \"product-\" + i).start(); &#125; for (int i = 0; i &lt; 3; i++) &#123; new Thread(() -&gt; consume(), \"consumer-\" + i).start(); &#125; // 主线程睡眠，便于看效果 try &#123; TimeUnit.SECONDS.sleep(2); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.exit(0); &#125; static void produce() &#123; int k = 0; while (k &lt; MAX) &#123; try &#123; System.out.println(Thread.currentThread().getName() + \" 生产了\" + k); queue.put(k++); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; // 线程睡眠，便于看效果 try &#123; TimeUnit.MILLISECONDS.sleep(new Random().nextInt(100)); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125; static void consume() &#123; while (true) &#123; try &#123; Integer take = queue.take(); System.out.println(Thread.currentThread().getName() + \"消费了\" + take); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; // 线程睡眠，便于看效果 try &#123; TimeUnit.MILLISECONDS.sleep(new Random().nextInt(100)); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125; put()方法：类似于我们上面的生产者线程，容量达到最大时，自动阻塞。 take()方法：类似于我们上面的消费者线程，容量为0时，自动阻塞。 4、PipedInputStream / PipedOutputStream","categories":[{"name":"java","slug":"java","permalink":"http://yoursite.com/categories/java/"}],"tags":[{"name":"thread queue","slug":"thread-queue","permalink":"http://yoursite.com/tags/thread-queue/"}]},{"title":"springboot自定义starter","slug":"springboot自定义starter","date":"2020-06-03T14:46:40.000Z","updated":"2020-06-03T15:02:44.539Z","comments":true,"path":"2020/06/03/springboot自定义starter/","link":"","permalink":"http://yoursite.com/2020/06/03/springboot%E8%87%AA%E5%AE%9A%E4%B9%89starter/","excerpt":"","text":"写在前面按照约定，官方的为spring-boot-xxx-starter ，非官方的为 xxx-spring-boot-starter 一、Spring Boot starter机制 Spring Boot中的starter是一种非常重要的机制，应用者只需要在maven中引入starter依赖，Spring Boot就能自动扫描到要加载的信息并启动相应的默认配置。 starter让我们摆脱了各种依赖库的处理，需要配置各种信息的困扰。 Spring Boot会自动通过classpath路径下的类发现需要的Bean，并注册进IOC容器。 Spring Boot提供了针对日常企业应用研发各种场景的spring-boot-starter依赖模块。所有这些依赖模块都遵循着约定成俗的默认配置，并允许我们调整这些配置，即遵循“约定大于配置”的理念。 二、自定义starter的条件如果想自定义Starter，首选需要实现自动化配置，而要实现自动化配置需要满足以下两个条件： 能够自动配置项目所需要的配置信息，也就是自动加载依赖环境； 能够根据项目提供的信息自动生成Bean，并且注册到Bean管理容器中； 三、自定义starter代码部分1、pom文件&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt; &lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.ztf&lt;/groupId&gt; &lt;artifactId&gt;orange-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;dependencies&gt; &lt;!-- https://mvnrepository.com/artifact/org.springframework.boot/spring-boot-autoconfigure --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-autoconfigure&lt;/artifactId&gt; &lt;version&gt;2.3.0.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-configuration-processor&lt;/artifactId&gt; &lt;version&gt;2.3.0.RELEASE&lt;/version&gt; &lt;!--该依赖只能在本项目中传递，不会传递到引用该项目的父项目中，父项目有需要需主动引用该依赖。--&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;version&gt;1.18.6&lt;/version&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;/project&gt; 2、定义XxxProperties 属性配置类， 设置属性前缀，用于在application.properties中配置。 package com.ztf; import lombok.Data; import org.springframework.boot.context.properties.ConfigurationProperties; @ConfigurationProperties(prefix = \"local.orange\") @Data public class MyProperties &#123; private String id; private String name; private int age; &#125; 3、定义XxxService逻辑操作类package com.ztf; public class MyService &#123; MyProperties myProperties; public void setMyProperties(MyProperties myProperties) &#123; this.myProperties = myProperties; &#125; public MyService(MyProperties myProperties) &#123; this.myProperties = myProperties; &#125; public void helloWorld() &#123; System.out.println(\"hi, 我叫: \" + myProperties.getName() + \", id:\" + myProperties.getId() + \"岁\" + \", 年龄: \" + myProperties.getAge()); &#125; &#125; 4、定义XxxAutoConfiguration自动配置类 用于完成Bean创建等工作。 package com.ztf; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.boot.autoconfigure.condition.ConditionalOnClass; import org.springframework.boot.autoconfigure.condition.ConditionalOnMissingBean; import org.springframework.boot.autoconfigure.condition.ConditionalOnProperty; import org.springframework.boot.context.properties.EnableConfigurationProperties; import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.Configuration; @Configuration @EnableConfigurationProperties(MyProperties.class) @ConditionalOnClass(MyService.class) @ConditionalOnProperty(prefix = \"local.orange\", value = \"enabled\", matchIfMissing = true) public class MyServiceAutoConfiguration &#123; @Autowired MyProperties myProperties; @Bean @ConditionalOnMissingBean(MyService.class) public MyService myService() &#123; return new MyService(myProperties); &#125; &#125; 5、在spring.factories中声明 在resources下创建目录META-INF，在 META-INF 目录下创建 spring.factories，在SpringBoot启动时会根据此文件来加载项目的自动化配置类。 spring.factories内容如下： org.springframework.boot.autoconfigure.EnableAutoConfiguration=com.ztf.MyServiceAutoConfiguration 四、自定义starter使用1、pom中引用自定义starter的jar&lt;dependency&gt; &lt;groupId&gt;com.ztf&lt;/groupId&gt; &lt;artifactId&gt;orange-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;/dependency&gt; 2、yml配置文件中声明参数## 自定义的一个starter local: orange: id: 007 name: myorange age: 18 3、项目中使用@Autowired MyService myService; @GetMapping(\"/test\") public String testMyStarter() &#123; myService.helloWorld(); return \"ok\"; &#125; 六、总结 Spring Boot在启动时扫描项目所依赖的JAR包，寻找包含spring.factories文件的JAR包， 然后读取spring.factories文件获取配置的自动配置类AutoConfiguration， 然后将自动配置类下满足条件(@ConditionalOnXxx)的@Bean放入到Spring容器中(Spring Context) 这样使用者就可以直接用来注入，因为该类已经在容器中了","categories":[{"name":"java","slug":"java","permalink":"http://yoursite.com/categories/java/"}],"tags":[{"name":"springboot","slug":"springboot","permalink":"http://yoursite.com/tags/springboot/"}]},{"title":"mac环境变量配置","slug":"mac环境变量配置","date":"2020-06-03T13:10:43.000Z","updated":"2020-06-03T13:13:25.334Z","comments":true,"path":"2020/06/03/mac环境变量配置/","link":"","permalink":"http://yoursite.com/2020/06/03/mac%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E9%85%8D%E7%BD%AE/","excerpt":"","text":"gradle环境变量配置vi ~/.bash_profile # 增加gradle环境变量，如下： export GRADLE_HOME=/Users/orange/Documents/gradle-6.4 export PATH=$PATH:$GRADLE_HOME/bin # 刷新 source ~/.bash_profile # 查看版本 gradle -version","categories":[{"name":"idea","slug":"idea","permalink":"http://yoursite.com/categories/idea/"}],"tags":[{"name":"环境变量","slug":"环境变量","permalink":"http://yoursite.com/tags/%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/"}]},{"title":"mybatis-generator","slug":"mybatis-generator","date":"2020-06-02T13:36:54.000Z","updated":"2020-06-03T12:18:35.200Z","comments":true,"path":"2020/06/02/mybatis-generator/","link":"","permalink":"http://yoursite.com/2020/06/02/mybatis-generator/","excerpt":"","text":"1.作用用来自动生成MyBatis的 mapper、dao、entity 2.使用MyBatis Generator的使用方式有4种： 命令行生成 Maven方式生成 使用Ant任务生成 使用Java代码生成 其中推荐使用Maven方式进行代码生成，因为集成和使用比较简单。 3.代码自动生成配置Step1：配置pom中plugin依赖&lt;plugin&gt; &lt;groupId&gt;org.mybatis.generator&lt;/groupId&gt; &lt;artifactId&gt;mybatis-generator-maven-plugin&lt;/artifactId&gt; &lt;version&gt;1.4.0&lt;/version&gt; &lt;executions&gt; &lt;execution&gt; &lt;id&gt;Generate MyBatis Artifacts&lt;/id&gt; &lt;phase&gt;package&lt;/phase&gt; &lt;goals&gt; &lt;goal&gt;generate&lt;/goal&gt; &lt;/goals&gt; &lt;/execution&gt; &lt;/executions&gt; &lt;configuration&gt; &lt;!--允许移动生成的文件 --&gt; &lt;verbose&gt;true&lt;/verbose&gt; &lt;!-- 是否覆盖 --&gt; &lt;overwrite&gt;true&lt;/overwrite&gt; &lt;!-- 自动生成的配置 --&gt; &lt;configurationFile&gt;src/main/resources/generatorConfig.xml&lt;/configurationFile&gt; &lt;!--将当前pom的依赖项添加到生成器的类路径中--&gt; &lt;includeCompileDependencies&gt;true&lt;/includeCompileDependencies&gt; &lt;/configuration&gt; &lt;/plugin&gt; Step2：配置generatorConfig.xml文件&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt; &lt;!--mybatis的代码生成器相关配置--&gt; &lt;!DOCTYPE generatorConfiguration PUBLIC \"-//mybatis.org//DTD MyBatis Generator Configuration 1.0//EN\" \"http://mybatis.org/dtd/mybatis-generator-config_1_0.dtd\"&gt; &lt;generatorConfiguration&gt; &lt;!-- 引入配置文件 --&gt; &lt;properties resource=\"application.yml\"/&gt; &lt;context id=\"Mysql\" targetRuntime=\"MyBatis3Simple\" defaultModelType=\"flat\"&gt; &lt;property name=\"autoDelimitKeywords\" value=\"true\" /&gt; &lt;property name=\"beginningDelimiter\" value=\"`\" /&gt; &lt;property name=\"endingDelimiter\" value=\"`\" /&gt; &lt;property name=\"javaFileEncoding\" value=\"utf-8\" /&gt; &lt;plugin type=\"org.mybatis.generator.plugins.SerializablePlugin\" /&gt; &lt;commentGenerator &gt; &lt;!-- 不生成注释 --&gt; &lt;property name=\"suppressAllComments\" value=\"true\"/&gt; &lt;!-- 不生成注释代时间戳--&gt; &lt;property name=\"suppressDate\" value=\"true\" /&gt; &lt;/commentGenerator&gt; &lt;!--数据库链接地址账号密码--&gt; &lt;!--&lt;jdbcConnection driverClass=\"$&#123;spring.datasource.driver-class-name&#125;\"--&gt; &lt;!--connectionURL=\"$&#123;spring.datasource.url&#125;\"--&gt; &lt;!--userId=\"$&#123;spring.datasource.username&#125;\"--&gt; &lt;!--password=\"$&#123;spring.datasource.password&#125;\"&gt;--&gt; &lt;!--&lt;/jdbcConnection&gt;--&gt; &lt;jdbcConnection driverClass=\"com.mysql.cj.jdbc.Driver\" connectionURL=\"jdbc:mysql://localhost:3306/display\" userId=\"root\" password=\"P@ssw0rd\"&gt; &lt;/jdbcConnection&gt; &lt;!-- 类型转换 --&gt; &lt;javaTypeResolver&gt; &lt;!-- 是否使用bigDecimal， false可自动转化以下类型（Long, Integer, Short, etc.） --&gt; &lt;property name=\"forceBigDecimals\" value=\"false\"/&gt; &lt;/javaTypeResolver&gt; &lt;!--生成Model类存放位置--&gt; &lt;javaModelGenerator targetPackage=\"com.ztf.mybatisplus.bean\" targetProject=\"src/main/java\"&gt; &lt;property name=\"enableSubPackages\" value=\"true\"/&gt; &lt;property name=\"trimStrings\" value=\"true\"/&gt; &lt;/javaModelGenerator&gt; &lt;!-- 生成mapxml文件 --&gt; &lt;sqlMapGenerator targetPackage=\"mapper\" targetProject=\"src/main/resources/mybatis\" &gt; &lt;property name=\"enableSubPackages\" value=\"false\" /&gt; &lt;/sqlMapGenerator&gt; &lt;!-- 生成mapper java文件 --&gt; &lt;javaClientGenerator targetPackage=\"com.ztf.mybatisplus.dao\" targetProject=\"src/main/java\" type=\"XMLMAPPER\" &gt; &lt;property name=\"enableSubPackages\" value=\"false\" /&gt; &lt;/javaClientGenerator&gt; &lt;!--具体解析的表，建议配置domainObjectName属性，避免带上表前缀T_--&gt; &lt;table tableName=\"t_corp\" enableCountByExample=\"true\" domainObjectName=\"Corp\" enableUpdateByExample=\"true\" enableDeleteByExample=\"true\" enableSelectByExample=\"true\" selectByExampleQueryId=\"true\"&gt; &lt;!--&lt;generatedKey column=\"id\" sqlStatement=\"Mysql\" identity=\"true\" /&gt;--&gt; &lt;/table&gt; &lt;!--&lt;table tableName=\"user_log\" enableCountByExample=\"true\" --&gt; &lt;!--enableUpdateByExample=\"true\" enableDeleteByExample=\"true\" --&gt; &lt;!--enableSelectByExample=\"true\" selectByExampleQueryId=\"true\"&gt;--&gt; &lt;!--&lt;generatedKey column=\"id\" sqlStatement=\"Mysql\" identity=\"true\" /&gt;--&gt; &lt;!--&lt;/table&gt;--&gt; &lt;/context&gt; &lt;/generatorConfiguration&gt; 4.注意事项 MyBatis Generator 只会覆盖旧的 po、dao、而 mapper.xml 不会覆盖，而是追加，这样做的目的是防止用户自己写的 sql 语句一不小心都被 MyBatis Generator 给覆盖了 &lt;!-- 是否覆盖 --&gt; &lt;overwrite&gt;true&lt;/overwrite&gt; 一般配置了 includeCompileDependencies 后就不需要配置其他依赖了，因为 includeCompileDependencies 会将当前 pom 的 dependencies 中所有 Compile 期的依赖全部添加到生成器的类路径中。 &lt;!--将当前pom的依赖项添加到生成器的类路径中--&gt; &lt;includeCompileDependencies&gt;true&lt;/includeCompileDependencies&gt; 数据库文件yml方式加载不进来配置，写成application.properties&quot;方式就可以 &lt;!-- 引入配置文件 --&gt; &lt;properties resource=\"application-dev.properties\"/&gt; context属性 id : 随便填，保证多个 context id 不重复就行 defaultModelType ： 可以不填，默认值 conditional，flat表示一张表对应一个po targetRuntime ：可以不填，默认值 MyBatis3，常用的还有 MyBatis3Simple。MyBatis3Simple生成的 dao 和 mapper.xml 内容较少，但也包含了最常用的。 context的子元素要求有序 1. **property** (0..N) 2. **plugin** (0..N) 3. **commentGenerator** (0 or 1) 4. **jdbcConnection** (需要connectionFactory 或 jdbcConnection) 5. **javaTypeResolver** (0 or 1) 6. **javaModelGenerator** (至少1个) 7. **sqlMapGenerator** (0 or 1) 8. **javaClientGenerator** (0 or 1) 9. **table** (1..N) commentGenerator 默认生成注释和时间戳，可显式的声明某一项不生成。建议全部显式不生成。 &lt;commentGenerator&gt; &lt;!-- 不希望生成的注释中包含时间戳 --&gt; &lt;property name=\"suppressDate\" value=\"true\"/&gt; &lt;!-- 不希望生成的注释中包含注释 --&gt; &lt;property name=\"suppressAllComments\" value=\"true\"/&gt; &lt;/commentGenerator&gt; type=&quot;XMLMAPPER&quot; 会将接口的实现放在 mapper.xml中，也推荐这样配置。也可以设置 type=&quot;ANNOTATEDMAPPER&quot;，接口的实现通过注解写在接口上面 一个 table 对应一张表，如果想同时生成多张表，需要配置多个 table domainObjectName 不配置时，它会按照帕斯卡命名法将表名转换成类名，建议配置该属性，避免带上表前缀T_ &lt;domainObjectRenamingRule searchString=\"^T\" replaceString=\"\" /&gt; 表字段也会默认带上c_、d_，可设置去掉 &lt;!-- 这个意思就是匹配，开头的任意个非下划线(_)的字符，也就是这种如：c_，d_ 等等 --&gt; &lt;columnRenamingRule searchString=\"^[^_]+\" replaceString=\"\"/&gt; &lt;!-- 也可如下只去掉c_--&gt; &lt;columnRenamingRule searchString=\"^c_\" replaceString=\"\" /&gt; enableXXXByExample 默认为true，但只有在targetRuntime=&quot;MyBatis3&quot;时才生效。当 targetRuntime=&quot;MyBatis3Simple&quot;时，enableXXXByExample 不管为true、还是false 都不生效。一般建议全设置为false，true的话会生成很多Example帮助类，造成很多sonar问题。 4.参考Spring Boot （七）MyBatis代码自动生成和辅助插件 MyBatis Generator 超详细配置","categories":[{"name":"mybatis","slug":"mybatis","permalink":"http://yoursite.com/categories/mybatis/"}],"tags":[{"name":"mybatis-generator","slug":"mybatis-generator","permalink":"http://yoursite.com/tags/mybatis-generator/"}]},{"title":"性能优化策略","slug":"性能优化策略","date":"2020-06-01T12:42:04.000Z","updated":"2020-06-01T13:25:08.525Z","comments":true,"path":"2020/06/01/性能优化策略/","link":"","permalink":"http://yoursite.com/2020/06/01/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E7%AD%96%E7%95%A5/","excerpt":"","text":"一、时空转换1.1 时间换空间 场景1: 降低内存空间的占用。 场景2: 降低数据的大小来方便网络传输和外部存储。 具体方式： 1、改变数据结构或者数据格式，减少要存储的数据大小。 2、使用压缩算法，压缩内存中的数据，使用时解压。 3、把内存中的数据存储到外部的、更便宜的存储设备中，需要时再取回来。 这些节省内存空间的方法，一般都需要付出时间的代价。 衡量任何压缩算法，基本上看三个指标：压缩比例、压缩速度以及使用内存。 如果系统的瓶颈在网络传输速度或者存储空间大小上，那就尽量采取高压缩比的算法。 1.2 空间换时间 场景：要求快速响应。 具体方式： 1、对数据和服务进行多份拷贝，尽大可能的覆盖更多的用户。 典型案例：集群 二、预处理和延后处理2.1 预处理/提前处理使用场景： 1、web静态资源提前加载，preload 和 prefetch。 2、文件系统预读功能。提前从磁盘读取下一次的数据。 这个功能对顺序读取十分有效，可以减少磁盘请求的数量 2.2 延后/惰性处理 尽量将操作推迟到必须执行的时刻。 使用场景： 1、COW（copy on write）写时复制。多线程读取共享资源时，不进行复制操作，当某个线程需要对资源进行修改时，才拷贝一份到工作内存，使其不会影响其他线程。 三、并行和并发四、缓存/批量合并4.1 缓存 缓存的本质是加速访问。 使用场景： 1、对于一个基于 Web 的应用服务，前端会有浏览器缓存，有 CDN 存放在边缘服务器上，有反向代理提供的静态内容缓存；后端则还会有服务器本地缓存。 2、程序设计中，对于可能重复创建和销毁，且创建销毁代价很大的对象（比如套接字和线程），也可以缓存，对应的缓存形式，就是连接池和线程池等。 3、对于消耗较大的计算，也可以将计算结果缓存起来，下次可以直接读取结果。比如对递归代码的一个有效优化手段，就是缓存中间结果。 4.2批量合并 在有 IO（比如网络 IO 和磁盘 IO）的时候，合并操作和批量操作往往能提升吞吐量，提高性能。 使用场景： 1、批量 IO 读写。就是在有多次 IO 的时候，可以把它们合并成一次读写数据。这样可以减少读写时间和协议负担。 2、对数据库的读写操作，也可以尽量合并。比如，对键值数据库的查询，最好一次查询多个键，而不要分成多次。 3、涉及到网络请求的时候，网络传输的时间可能远大于请求的处理时间，因此合并网络请求也很有必要。 五、更高效的算法和数据结构附录：参考文档","categories":[{"name":"总结","slug":"总结","permalink":"http://yoursite.com/categories/%E6%80%BB%E7%BB%93/"}],"tags":[{"name":"性能优化","slug":"性能优化","permalink":"http://yoursite.com/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"}]},{"title":"服务熔断","slug":"服务熔断","date":"2020-05-31T14:43:58.000Z","updated":"2020-05-31T15:45:41.762Z","comments":true,"path":"2020/05/31/服务熔断/","link":"","permalink":"http://yoursite.com/2020/05/31/%E6%9C%8D%E5%8A%A1%E7%86%94%E6%96%AD/","excerpt":"","text":"服务熔断 hystrix，是一个用于处理分布式系统延迟和容错的库，它能够保证在一个子服务出问题的情况下，不会导致整体服务失败，避免级联雪崩，以提高分布式系统的弹性。 “断路器”本身是一个开关装置，当某个服务单元发生故障后，向调用方返回一个服务预期的、可处理的备选响应，而不是长时间等待或者抛出一个服务端无法处理的异常。这样就保证了调用方线程不会被长时间占用，从而避免故障在分布式系统中蔓延，甚至雪崩。 1、服务降级（客户端提供异常响应） 限制其他低相关服务的访问，使他们占用计算机较少的资源，从而保障主服务拥有更多的资源，使其能正常访问。 // 配置文件默认关闭，需手动开启 feign: hystrix: enabled: true # 启用服务降级 @FeignClient(name = \"MYCLOUD-PROVIDER\", fallback = HystrixConsumerService.class) public interface CorpConsumerService &#123; @GetMapping(\"/corps/&#123;id&#125;\") Corp getCorp(@PathVariable(\"id\") String id); @GetMapping(\"/corps\") List&lt;Corp&gt; getCorps(); &#125; // 客户端熔断回调缺省值处理 // 假设服务端未启动，即这么处理 @Service public class HystrixConsumerService implements CorpConsumerService &#123; public Corp getCorp(String id) &#123; return Corp.builder().id(id).name(\"HystrixConsumerService\").age(40).build(); &#125; public List&lt;Corp&gt; getCorps() &#123; return null; &#125; &#125; 2、服务熔断（服务端返回合适的异常响应） 熔断机制是对微服务雪崩效应的一种链路保护机制。 当扇出链路的某个微服务不可用或者响应时间太长时，会进行服务的降级，进而熔断该节点的微服务调用，快速返回错误的响应信息，当检测到该微服务调用响应正常后恢复调用链路。 hystrix会监控微服务之间的调用状况，当失败的调用到一定阈值，缺省是5s内20ci调用失败就会触发。熔断机制的注解是@HystrixCommand。 // 启动类配置enable @SpringBootApplication @EnableEurekaClient @EnableHystrix public class CorpProvider8005 &#123; public static void main(String[] args) &#123; SpringApplication.run(CorpProvider8005.class, args); &#125; &#125; // 添加@HystrixCommand注解 // 发生异常时，会调用hystrixCorp方法，控制台无异常堆栈 @GetMapping(\"/corps/&#123;id&#125;\") @HystrixCommand(fallbackMethod = \"hystrixCorp\") Corp getCorp(@PathVariable(\"id\") String id) &#123; Corp corp = corpService.getCorp(id); if (corp == null) &#123; throw new RuntimeException(\"id \" + id + \" 不存在\"); &#125; return corp; &#125; Corp hystrixCorp(@PathVariable(\"id\") String id) &#123; return Corp.builder().id(id).name(\"hystrix\").age(30).build(); &#125; 3、服务限流4、实时监控","categories":[{"name":"java","slug":"java","permalink":"http://yoursite.com/categories/java/"}],"tags":[{"name":"springCloud hystrix","slug":"springCloud-hystrix","permalink":"http://yoursite.com/tags/springCloud-hystrix/"}]},{"title":"负载均衡","slug":"负载均衡","date":"2020-05-31T13:32:48.000Z","updated":"2020-05-31T14:47:12.805Z","comments":true,"path":"2020/05/31/负载均衡/","link":"","permalink":"http://yoursite.com/2020/05/31/%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/","excerpt":"","text":"负载均衡 LB（load balance）：简单的说就是将用户请求平摊分配到多个服务器上，从而达到系统的高可用。 常见的负载均衡软件有nginx、lvx 常见分类 集中式LB：在服务的消费方和服务方使用独立的Lb方式，如nginx，由它负责请求转发。 进程式LB：将LB逻辑集成到消费方，消费方从注册中心获取可用的服务，再从这里面选一个进行访问，如ribbon。 ribbon 负载均衡// 配置类 @Configuration public class RestTemplateConfig &#123; @Bean @LoadBalanced RestTemplate restTemplate() &#123; return new RestTemplate(); &#125; &#125; // controller调用 // 第二版根据服务名去访问，需要将restTemplate注解为@LoadBalanced才会生效 private String service = \"http://MYCLOUD-PROVIDER\"; @RequestMapping(\"/consumer/corps/&#123;id&#125;\") Corp getCorp(@PathVariable(\"id\") String id) &#123; String url = service + \"/corps/\"; return restTemplate.getForObject(url + id, Corp.class); &#125; 使用服务名去调用，restful风格 feign 负载均衡 feign是声明式的web service客户端，只需提供一个接口，添加注解就可以了。 feign是ribbon的封装，以面向对象方式的去访问。 feign不需要去显式的声明restTemplate 使用接口注解去调用 // 逻辑处理类，映射路径为实际接口路径 @FeignClient(name = \"MYCLOUD-PROVIDER\") public interface CorpConsumerService &#123; @GetMapping(\"/corps/&#123;id&#125;\") Corp getCorp(@PathVariable(\"id\") String id); @GetMapping(\"/corps\") List&lt;Corp&gt; getCorps(); &#125; // 启动类配置enable @SpringBootApplication @EnableEurekaClient @EnableFeignClients public class CorpConsumer8002 &#123; public static void main(String[] args) &#123; SpringApplication.run(CorpConsumer8002.class, args); &#125; &#125;","categories":[{"name":"java","slug":"java","permalink":"http://yoursite.com/categories/java/"}],"tags":[{"name":"springCloud ribbon","slug":"springCloud-ribbon","permalink":"http://yoursite.com/tags/springCloud-ribbon/"}]},{"title":"eureka对比zookeeper","slug":"eureka对比zookeeper","date":"2020-05-31T13:09:42.000Z","updated":"2020-06-02T14:28:23.975Z","comments":true,"path":"2020/05/31/eureka对比zookeeper/","link":"","permalink":"http://yoursite.com/2020/05/31/eureka%E5%AF%B9%E6%AF%94zookeeper/","excerpt":"","text":"cap原则一、回顾 ACID 原则 关系数据库管理系统（Relational Database Management System：RDBMS），如mysql、oracle、sqlserver A（atomicity）原子性 C（consistency）一致性 I（Isolation）隔离性 D（durability）持久性 CAP原则 一般用于redis、mongdb C（consistency）一致性 A（avaibility）可用性 P（partition tolerance）分区容错性 由于P 分区容错性在分布式系统中是必须要满足的，所以只能在c、a之间权衡 二、zookeeper保证的是CP三、eureka保证的是AP","categories":[{"name":"java","slug":"java","permalink":"http://yoursite.com/categories/java/"}],"tags":[{"name":"springCloud","slug":"springCloud","permalink":"http://yoursite.com/tags/springCloud/"},{"name":"eureka","slug":"eureka","permalink":"http://yoursite.com/tags/eureka/"}]},{"title":"java8方法引用理解","slug":"java8方法引用理解","date":"2020-05-31T04:12:15.000Z","updated":"2020-05-31T04:13:16.886Z","comments":true,"path":"2020/05/31/java8方法引用理解/","link":"","permalink":"http://yoursite.com/2020/05/31/java8%E6%96%B9%E6%B3%95%E5%BC%95%E7%94%A8%E7%90%86%E8%A7%A3/","excerpt":"","text":"什么是方法引用?方法引用可用于在不调用方法的情况下引用方法。它将方法视为Lambda表达式。它们只能作为语法糖来减少一些lambdas的冗长。在方法引用中，将包含方法的对象（或类）放在::运算符之前，将方法的名称放在不带参数的方法之后。例如： Object :: methodName 为什么会出现方法引用？在Java中，我们可以通过创建新对象来使用对象的引用,或者引用已有的对象，例如： //创建新对象来引用该对象 List list = new ArrayList(); dosth(list); //引用已有的对象 List list2 = list; dosth(list2); 如果我们只在另一个方法中使用对象的方法，我们仍然必须将完整的对象作为参数传递。那么将方法作为参数传递不是更有效吗？ 方法引用这种语法糖不能用于所有的方法，它们只能用于只有一个方法的lambda表达式//lambda转方法引用 Consumer&lt;String&gt; c = s -&gt; System.out.println(s); Consumer&lt;String&gt; c = System.out::println; 换句话说，可以使用lambda表达式去代替一个匿名类，如果这个匿名类只有一个方法，就可以用更简短的方法引用来代替lambda表达式。 静态方法引用from (args) -&gt; Class.staticMethod(args) to Class::staticMethod 如上所述，我们不需要显式的传递参数，方法引用中会自动传递参数 Consumer&lt;String&gt; c1 = (s) -&gt; System.out.println(s); Consumer&lt;String&gt; c2 = System.out::println; c2.accept(\"Hello\"); 当我们所使用的lambda表达式仅仅调用了一个静态方法，我们就可以使用静态方法引用。如下所示，将lambda表达式（匿名类）中的值判断提取成isMoreThanFifty这个静态方法，就可以使用静态方法引用这种语法糖。 public class Numbers &#123; //将值判断提取成静态方法 public static boolean isMoreThanFifty(int n1, int n2) &#123; return (n1 + n2) &gt; 50; &#125; //公共接口方法 public static List&lt;Integer&gt; findNumbers(List&lt;Integer&gt; l, BiPredicate&lt;Integer, Integer&gt; p) &#123; List&lt;Integer&gt; newList = new ArrayList&lt;&gt;(); for (Integer i : l) &#123; if (p.test(i, i + 10)) &#123; newList.add(i); &#125; &#125; return newList; &#125; public static void main(String[] args) &#123; List&lt;Integer&gt; list = Arrays.asList(12, 5, 45, 18, 33, 24, 40); // Using an anonymous class List&lt;Integer&gt; res = Numbers.findNumbers(list, new BiPredicate&lt;Integer, Integer&gt;() &#123; @Override public boolean test(Integer integer, Integer integer2) &#123; return Numbers.isMoreThanFifty(integer, integer2); &#125; &#125;); res.stream().forEach(System.out :: println); // res.stream().peek(System.out :: println).collect(Collectors.toList()); // Using a lambda expression Numbers.findNumbers(list, (i1, i2) -&gt; Numbers.isMoreThanFifty(i1, i2)); // Using a method reference Numbers.findNumbers(list, Numbers::isMoreThanFifty); &#125; &#125; 特定类型的对象的实例方法的方法引用from (obj, args) -&gt; obj.instanceMethod(args) to ObjectType::instanceMethod 我们使用实例的类型而非实例本身 参数隐式传递public class People &#123; public double calculateWeight() &#123; double weight = 0; // Calculate weight return weight; &#125; public List&lt;Double&gt; calculateAllWeight(List&lt;People&gt; l, Function&lt;People, Double&gt; f) &#123; List&lt;Double&gt; results = new ArrayList&lt;&gt;(); for (People s : l) &#123; results.add(f.apply(s)); &#125; return results; &#125; &#125; class PeopleClient &#123; public static void main(String[] args) &#123; List&lt;People&gt; list = new ArrayList&lt;&gt;(); People p = new People(); // Using an anonymous class p.calculateAllWeight(list, new Function&lt;People, Double&gt;() &#123; @Override public Double apply(People people) &#123;// The object return people.calculateWeight();// The method &#125; &#125;); // Using a lambda expression p.calculateAllWeight(list, people -&gt; people.calculateWeight()); // Using a method reference p.calculateAllWeight(list, People::calculateWeight); &#125; &#125; 在这个例子中，我们没有给方法传递任何参数，关键在于对象的实例是lambda表达式的一个参数，我们通过实例的类型来完成对实例方法的引用。下面是另一个例子，在这个例子中，我们向方法引用中传递了两个参数。//java中有一个Function接口可以接收一个参数，BiFunction接口接受两个参数，没有接受三个参数的，所以我们自定义一个TriFunction interface TriFunction&lt;T, U, V, R&gt; &#123; R apply(T t, U u, V v); &#125; //然后定义一个类，接收两个参数，并且有一个返回值 class Sum &#123; Integer doSum(String s1, String s2) &#123; return Integer.parseInt(s1) + Integer.parseInt(s1); &#125; &#125; //用匿名类实现TriFunction，来包装doSum() TriFunction&lt;Sum, String, String, Integer&gt; anonymous = new TriFunction&lt;Sum, String, String, Integer&gt;() &#123; @Override public Integer apply(Sum s, String arg1, String arg2) &#123; return s.doSum(arg1, arg2); &#125; &#125;; System.out.println(anonymous.apply(new Sum(), \"1\", \"4\")); //使用lambda表达式来包装 TriFunction&lt;Sum, String, String, Integer&gt; lambda = (Sum s, String arg1, String arg2) -&gt; s.doSum(arg1, arg2); System.out.println(lambda.apply(new Sum(), \"1\", \"4\")); //使用方法引用 TriFunction&lt;Sum, String, String, Integer&gt; mRef = Sum::doSum; System.out.println(mRef.apply(new Sum(), \"1\", \"4\")); 第一个参数是要执行的方法的实例对象 第二、三个参数是传递的其他参数 最后一个参数是要执行的方法的返回值类型 已有对象的实例方法引用from (args) -&gt; obj.instanceMethod(args) to obj::instanceMethod 直接引用已经在其他地方实例化的对象的一个方法，本身不需要再实现一次 class Car &#123; private int id; private String color; public int getId() &#123; return id; &#125; public void setId(int id) &#123; this.id = id; &#125; &#125; class Mechanic &#123; public void fix(Car c) &#123; System.out.println(\"Fixing car \" + c.getId()); &#125; &#125; public class InstanceRef &#123; public static void main(String[] args) &#123; InstanceRef instanceRef = new InstanceRef(); final Mechanic mechanic = new Mechanic(); Car car = new Car(); // Using an anonymous class instanceRef.execute(car, new Consumer&lt;Car&gt;() &#123; public void accept(Car c) &#123; mechanic.fix(c); &#125; &#125;); // Using a lambda expression instanceRef.execute(car, car1 -&gt; mechanic.fix(car1)); //Using a method reference instanceRef.execute(car, mechanic::fix); &#125; private void execute(Car car, Consumer&lt;Car&gt; c) &#123; c.accept(car); &#125; &#125; 构造方法引用from (args) -&gt; new ClassName(args) to ClassName::new 这个lambda表达式唯一能做的就是创建一个新对象，我们通过关键字new来引用类的构造函数。与其他情况一样，参数（如果有）不会在方法引用中传递。 无参构造 // Using an anonymous class Supplier&lt;List&lt;String&gt;&gt; s = new Supplier() &#123; public List&lt;String&gt; get() &#123; return new ArrayList&lt;String&gt;(); &#125; &#125;; List&lt;String&gt; l = s.get(); // Using a lambda expression Supplier&lt;List&lt;String&gt;&gt; s = () -&gt; new ArrayList&lt;String&gt;(); List&lt;String&gt; l = s.get(); // Using a method reference Supplier&lt;List&lt;String&gt;&gt; s = ArrayList::new; List&lt;String&gt; l = s.get(); 带参构造 // Using a anonymous class BiFunction&lt;String, String, Locale&gt; f = new BiFunction&lt;String, String, Locale&gt;() &#123; public Locale apply(String lang, String country) &#123; return new Locale(lang, country); &#125; &#125;; Locale loc = f.apply(\"en\",\"UK\"); // Using a lambda expression BiFunction&lt;String, String, Locale&gt; f = (lang, country) -&gt; new Locale(lang, country); Locale loc = f.apply(\"en\",\"UK\"); // Using a method reference BiFunction&lt;String, String, Locale&gt; f = Locale::new; Locale loc = f.apply(\"en\",\"UK\"); 如果有三个及以上的参数的构造函数，则必须创建自己的函数接口。引用构造函数与引用静态方法非常相似，区别在于构造函数“方法名称”是new。 总结如果使用了方法引用之后能让代码变的更加整洁，就使用它。实际使用中，一种使用方式是将代码包裹在一个方法中，而非使用一个单独的类或者lambda表达式，然后使用方法引用的方式进行调用。方法引用常用于java8的另一种新特性Streams中，而基于方法引用的设计模式也会更加具有拓展性。","categories":[{"name":"java","slug":"java","permalink":"http://yoursite.com/categories/java/"}],"tags":[{"name":"stream","slug":"stream","permalink":"http://yoursite.com/tags/stream/"}]},{"title":"java8新特性之Stream","slug":"java8新特性之Stream","date":"2020-05-31T04:07:12.000Z","updated":"2020-05-31T04:09:19.626Z","comments":true,"path":"2020/05/31/java8新特性之Stream/","link":"","permalink":"http://yoursite.com/2020/05/31/java8%E6%96%B0%E7%89%B9%E6%80%A7%E4%B9%8BStream/","excerpt":"","text":"概述Stream API与InputStream和OutputStream是完全不同的概念，Stream API是对Java中集合操作的增强，可以利用它进行各种过滤、排序、分组、聚合等操作。Stream API配合Lambda表达式可以加大的提高代码可读性和编码效率，Stream API也支持并行操作。 流不是集合，它不关心数据的存放，只关注如何处理数据Stream API主要用于处理集合操作，不过它的处理方式与传统的方式不同，称为“数据流处理”。流（Stream）类似于关系数据库的查询操作，是一种声明式操作。比如要从数据库中获取所有年龄大于20岁的用户的名称，并按照用户的创建时间进行排序，用一条SQL语句就可以搞定，不过使用Java程序实现就会显得有些繁琐，这时候可以使用流： List&lt;String&gt; userNames = users.stream() .filter(user -&gt; user.getAge() &gt; 20) .sorted(comparing(User::getCreationDate)) .map(User::getUserName) .collect(toList()); 在Java中，集合是一种数据结构，或者说是一种容器，用于存放数据，流不是容器，它不关心数据的存放，只关注如何处理。可以把流当做是Java中的Iterator，不过它比Iterator强大多了。 流使用内部迭代方式处理数据流与集合另一个区别在于他们的遍历方式，遍历集合通常使用for-each方式，这种方式称为外部迭代，而流使用内部迭代方式，也就是说它帮你把迭代的工作做了，你只需要给出一个函数来告诉它接下来要干什么： // 外部迭代 List&lt;String&gt; list = Arrays.asList(\"A\", \"B\", \"C\", \"D\"); for (String str : list) &#123; System.out.println(str); &#125; // 内部迭代 list.stream().forEach(System.out::println); 外部迭代更像是作文题，我们不仅要控制元素的迭代方式，还需要定义怎么操作元素；内部迭代更像是填空题，我们只用关注如何操作元素就可以了。 流只能遍历一次流只能遍历一次，遍历结束后，这个流就被关闭掉了。如果要重新遍历，可以从数据源（集合）中重新获取一个流。如果你对一个流遍历两次，就会抛出java.lang.IllegalStateException异常： List&lt;String&gt; list = Arrays.asList(\"A\", \"B\", \"C\", \"D\"); Stream&lt;String&gt; stream = list.stream(); stream.forEach(System.out::println); stream.forEach(System.out::println); // 这里会抛出java.lang.IllegalStateException异常，因为流已经被关闭 流通常由三部分构成： 数据源：数据源一般用于流的获取，比如本文开头那个过滤用户的例子中users.stream()方法。 中间处理：中间处理包括对流中元素的一系列处理，如：过滤（filter()），映射（map()），排序（sorted()）。 终端处理：终端处理会生成结果，结果可以是任何不是流值，如List；也可以不返回结果，如stream.forEach(System.out::println)就是将结果打印到控制台中，并没有返回。 创建流由值创建流使用静态方法Stream.of()创建流，该方法接收一个变长参数： Stream&lt;Stream&gt; stream = Stream.of(\"A\", \"B\", \"C\", \"D\"); //也可以使用静态方法Stream.empty()创建一个空的流： Stream&lt;Stream&gt; stream = Stream.empty(); 由数组、集合 创建流使用静态方法Arrays.stream()从数组创建一个流，该方法接收一个数组参数： String[] strs = &#123;\"A\", \"B\", \"C\", \"D\"&#125;; Stream&lt;Stream&gt; stream = Arrays.stream(strs); 通过文件生成流使用java.nio.file.Files类中的很多静态方法都可以获取流，比如Files.lines()方法，该方法接收一个java.nio.file.Path对象，返回一个由文件行构成的字符串流： Stream&lt;String&gt; stream = Files.lines(Paths.get(\"text.txt\"), Charset.defaultCharset()); 通过函数创建流java.util.stream.Stream中有两个静态方法用于从函数生成流，他们分别是Stream.generate()和Stream.iterate()： // iteartor 打印100以内的所有偶数 Stream.iterate(0, n -&gt; n + 2).limit(51).forEach(System.out::println); // generate 打印10个Hello Man! Stream.generate(() -&gt; \"Hello Man!\").limit(10).forEach(System.out::println); 值得注意的是，这两个方法生成的流都是无限流，没有固定大小，可以无穷的计算下去，可以使用limit()来限制边界。 //一般来说，iterate()用于生成一系列值，比如生成以当前时间开始之后的10天的日期： Stream.iterate(LocalDate.now(), date -&gt; date.plusDays(1)).limit(10).forEach(System.out::println); //generate()方法用于生成一些随机数，比如生成10个UUID： Stream.generate(() -&gt; UUID.randomUUID().toString()).limit(10).forEach(System.out::println); collect(toList())将流中的值转换为集合//of从初识值生成新的stream，再通过collect(toList())生成新的集合 List&lt;String&gt; collect = Stream.of(\"aa\", \"bb\", \"cc\", \"aa\", \"bb\").collect(Collectors.toList()); of是惰性求值，不生成新的集合，通过collect(toList())这种及早求值才生成新的集合。返回值是stream就是惰性求值，返回值为另一个值或者空就是及早求值。 惰性求值与及早求值的区别//如下加count就是及早求值，会sout输出strs。不加count，程序不输出任何信息 strs.stream().filter(str -&gt; &#123; System.out.println(str); return str.startsWith(\"a\"); &#125; ).count(); 过滤+计数，只循环了一次。只执行fileter会返回一个stream，他不是一个新集合，仅仅是创建新集合的配方。 流常用方法过滤和排序Stream.of(1, 8, 5, 2, 1, 0, 9, 2, 0, 4, 8) .filter(n -&gt; n &gt; 2) // 对元素过滤，保留大于2的元素 .distinct() // 去重，类似于SQL语句中的DISTINCT .skip(1) // 跳过前面1个元素 .limit(2) // 返回开头2个元素，类似于SQL语句中的SELECT TOP .sorted() // 对结果排序 .forEach(System.out::println); filter 对集合的值进行过滤，必须返回true或者false 查找和匹配//检查流中的任意元素是否包含字符串\"PHP\" boolean match1 = getStream().anyMatch(s -&gt; s.equals(\"PHP\")); System.out.println(match1); boolean match2 = getStream().collect(Collectors.toList()).contains(\"PHP\"); System.out.println(match2); // 检查流中的所有元素是否都包含字符串\"#\" boolean hasAllMatch = getStream().allMatch(s -&gt; s.contains(\"#\")); // 检查流中的任意元素是否没有以\"C\"开头的字符串 boolean hasNoneMatch = getStream().noneMatch(s -&gt; s.startsWith(\"C\")); // 查找元素 Optional&lt;String&gt; element = getStream().ilter(s -&gt; s.contains(\"C\")) // .findFirst() // 查找第一个元素 .findAny(); // 查找任意元素 //获取初始流 private static Stream&lt;String&gt; getStream() &#123; return Stream.of(\"Java\", \"C#\", \"PHP\", \"C++\", \"Python\"); &#125; 每次都需要重新getStream()来获取新的流，因为之前的流已经使用并且关闭了。可以理解为若返回值不是stream，则表示已经结束了流操作 findAny的返回类型是一个Optional类（java.util.Optional），它一个容器类，代表一个值存在或不存在，用来避免控制正异常。 findFirst()和findAny()返回的都是第一个元素，通过查看javadoc描述，大致意思是findAny()是为了提高并行操作时的性能。数据大时可findany。 归约归约操作就是将流中的元素进行合并，形成一个新的值，常见的归约操作包括求和，求最大值或最小值。归约操作一般使用reduce()方法，与map()方法搭配使用，可以处理一些很复杂的归约操作。 // 获取流 List&lt;Book&gt; books = Arrays.asList( new Book(\"Java编程思想\", \"Bruce Eckel\", \"机械工业出版社\", 108.00D), new Book(\"Java 8实战\", \"Mario Fusco\", \"人民邮电出版社\", 79.00D), new Book(\"MongoDB权威指南（第2版）\", \"Kristina Chodorow\", \"人民邮电出版社\", 69.00D) ); // 计算所有图书的总价 Optional&lt;Double&gt; totalPrice = books.stream() .map(Book::getPrice) .reduce((n, m) -&gt; n + m); // 价格最高的图书 Optional&lt;Book&gt; expensive = books.stream().max(Comparator.comparing(Book::getPrice)); // 价格最低的图书 Optional&lt;Book&gt; cheapest = books.stream().min(Comparator.comparing(Book::getPrice)); // 计算总数 long count = books.stream().count() reduce从一组值中生成一个值，如累加。//0初始值，total总值，index循环的每一个值。 Integer num = Stream.of(1, 2, 3).reduce(0, (total, index) -&gt; total + index); max(min) 传入comparator进行大小比较，返回Optional对象//Optional对象(代表一个可能存在也可能不存在的值，NPE方案),通过get拿到Optional对象中的值 Integer integer = Stream.of(1, 2, 3).min(Comparator.comparing(num -&gt; num)).get(); map 将流中的值转换为新值//将list小写处理成大写 Stream.of(\"aa\", \"bb\", \"cc\", \"aa\", \"bb\").map(str -&gt; str.toUpperCase()).collect(Collectors.toList()); flatmap 把多个stream合并成一个stream并返回与map()方法类似的还有一个flatMap()，flatMap()方法让你把一个流中的每个值都换成另一个流，然后把所有的流连接起来成为一个新的流。 //传统for循环 List&lt;String&gt; names0 = new ArrayList&lt;&gt;(); for (Company company : data) &#123; List&lt;User&gt; users = company.getUesrs(); for (User user : users) &#123; if (user.getAge() &gt; 30) &#123; names0.add(user.getName()); &#125; &#125; &#125; //lambda方式1 List&lt;String&gt; names1 = data.stream() .flatMap(company -&gt; company.getUesrs().stream()) .filter(user -&gt; user.getAge() &gt; 30) .map(user -&gt; user.getName()) .collect(Collectors.toList()); //lambda方式2 List&lt;String&gt; names2 = data.stream() .map(Company::getUesrs) .flatMap(Collection::stream) .filter(user -&gt; user.getAge() &gt; 30) .map(User::getName) .collect(Collectors.toList()); 使用flatMap()方法的效果是，各个数组并不是分别映射成一个流，而是映射成流的内容。所有使用map(Arrays::stream)时生成的单个流都被合并起来，也就是对流扁平化操作。 peek 用于记录中间值（输出流中的值），不会改变流。一般用作日志输出，断点调试。List&lt;Integer&gt; nums = Stream.of(1, 2, 3, 4, 5).collect(Collectors.toList()); nums.stream().filter(num -&gt; num &gt; 3).peek(num -&gt; &#123; System.out.println(num); &#125;).collect(Collectors.toList()); 数据收集前面总结了如何创建流以及流处理，接下来总结下数据收集。数据收集是流式数据处理的终端处理，与中间处理不同的是，终端处理会消耗流，也就是说，终端处理之后，这个流就会被关闭，如果再进行中间处理，就会抛出异常。数据收集主要使用collect方法，该方法也属于归约操作，像reduce()方法那样可以接收各种做法作为参数，将流中的元素累积成一个汇总结果，具体的做法是通过定义新的Collector接口来定义的。 可以静态导入Collectors和Comparator两个类，这样就不用再去写Collectors.counting()和Comparator.comparing()。import static java.util.stream.Collectors.*; import static java.util.Comparator.*; // 求和 long count = books.stream().collect(counting()); // 价格最高的图书 Optional&lt;Book&gt; expensive = books.stream().collect(maxBy(comparing(Book::getPrice))); // 价格最低的图书 Optional&lt;Book&gt; cheapest = books.stream().collect(minBy(comparing(Book::getPrice))); 收集顺序进有序，出有序；进无序，出无序。 特定收集器stream.collect(toCollection(TreeSet::new)); 字符串操作joining//将流中的字符串通过逗号连接成一个新的字符串 String str = Stream.of(\"A\", \"B\", \"C\", \"D\").collect(joining(\",\")); List&lt;Integer&gt; data = Stream.of(1,2,3,4,5).collect(toList()); List&lt;Integer&gt; integers = Arrays.asList(1, 2, 3, 4, 5); //前后缀拼接 //传统for循环 StringBuilder sb = new StringBuilder(\"[\"); for (Integer num : integers) &#123; sb.append(num).append(\", \"); &#125; sb.append(\"]\"); System.out.println(sb); //lambda循环（map是为了将int转为string） String str = data.stream().map(String::valueOf).collect(joining(\",\", \"[\", \"]\")); System.out.println(str); 数据分块（parttitioningBy，将流分解成两个集合），传入一个pridicate对象来判断属于哪部分。//数据分块：将数据分成true和false两部分 Map&lt;Boolean, List&lt;User&gt;&gt; res = users.stream().collect(partitioningBy(user -&gt; user.getName().length() &gt; 3)); 数据分组（groupingBy）//数据分组：将数据以某个key值分成多部分 Map&lt;String, List&lt;User&gt;&gt; result = users.stream().collect(groupingBy(user -&gt; user.getAddress())); Map&lt;String, List&lt;User&gt;&gt; result = users.stream().collect(groupingBy(User::getAddress)); 组合收集器（下游收集器），在主收集器中应用下级收集器，对结果进行再次封装。//将数据分组后，不是返回每组的数据，而是统计每组的个数返回。 Map&lt;String, Long&gt; collect1 = users.stream().collect(groupingBy(User::getName, counting())); //通过mapping可以进行其他二次收集。 Map&lt;String, List&lt;String&gt;&gt; collect2 = users.stream().collect(groupingBy(User::getAddress, mapping(User::getName, toList()) )); 函数拆分示例：collect( groupingBy(key1, mapping(key2, value) ) ) 进阶集合操作map的foreach循环Map&lt;String, Integer&gt; cache = new HashMap&lt;&gt;(); Map&lt;String, List&lt;User&gt;&gt; users = new HashMap&lt;String, List&lt;User&gt;&gt;(); //传统for循环 for (Map.Entry&lt;String, List&lt;User&gt;&gt; entry : users.entrySet()) &#123; String key = entry.getKey(); List&lt;User&gt; value = entry.getValue(); cache.put(key, value.size()); &#125; //lambda方式 users.forEach((key, value) -&gt; &#123; cache.put(key, value.size()); &#125;); computeIfAbsent根据key获取某个值，若值不存在，丛数据库中取 //传统方式 public List&lt;User&gt; getUserByName(String name) &#123; List&lt;User&gt; user = users.get(name); if (user == null) &#123; user = readFromDB(name); users.put(name, user); &#125; return user; &#125; //lambda方式 public List&lt;User&gt; getUser1ByName(String name) &#123; return users.computeIfAbsent(name, this::readFromDB); &#125; private List&lt;User&gt; readFromDB(String name) &#123; return new ArrayList&lt;&gt;(); &#125;","categories":[{"name":"java","slug":"java","permalink":"http://yoursite.com/categories/java/"}],"tags":[{"name":"stream","slug":"stream","permalink":"http://yoursite.com/tags/stream/"}]},{"title":"Hello World","slug":"hello-world","date":"2020-05-31T01:14:54.029Z","updated":"2020-05-31T01:14:54.029Z","comments":true,"path":"2020/05/31/hello-world/","link":"","permalink":"http://yoursite.com/2020/05/31/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post$ hexo new \"My New Post\" More info: Writing Run server$ hexo server More info: Server Generate static files$ hexo generate More info: Generating Deploy to remote sites$ hexo deploy More info: Deployment","categories":[],"tags":[]}],"categories":[{"name":"java","slug":"java","permalink":"http://yoursite.com/categories/java/"},{"name":"idea","slug":"idea","permalink":"http://yoursite.com/categories/idea/"},{"name":"mybatis","slug":"mybatis","permalink":"http://yoursite.com/categories/mybatis/"},{"name":"总结","slug":"总结","permalink":"http://yoursite.com/categories/%E6%80%BB%E7%BB%93/"}],"tags":[{"name":"thread queue","slug":"thread-queue","permalink":"http://yoursite.com/tags/thread-queue/"},{"name":"springboot","slug":"springboot","permalink":"http://yoursite.com/tags/springboot/"},{"name":"环境变量","slug":"环境变量","permalink":"http://yoursite.com/tags/%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/"},{"name":"mybatis-generator","slug":"mybatis-generator","permalink":"http://yoursite.com/tags/mybatis-generator/"},{"name":"性能优化","slug":"性能优化","permalink":"http://yoursite.com/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"},{"name":"springCloud hystrix","slug":"springCloud-hystrix","permalink":"http://yoursite.com/tags/springCloud-hystrix/"},{"name":"springCloud ribbon","slug":"springCloud-ribbon","permalink":"http://yoursite.com/tags/springCloud-ribbon/"},{"name":"springCloud","slug":"springCloud","permalink":"http://yoursite.com/tags/springCloud/"},{"name":"eureka","slug":"eureka","permalink":"http://yoursite.com/tags/eureka/"},{"name":"stream","slug":"stream","permalink":"http://yoursite.com/tags/stream/"}]}
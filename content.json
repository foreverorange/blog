{"meta":{"title":"Hexo","subtitle":"","description":"","author":"John Doe","url":"http://yoursite.com","root":"/blog/"},"pages":[{"title":"about","date":"2020-02-23T11:20:33.000Z","updated":"2020-05-31T02:56:02.816Z","comments":true,"path":"about/index.html","permalink":"http://yoursite.com/about/index.html","excerpt":"","text":"这里写关于页的正文，支持 Markdown, HTML"}],"posts":[{"title":"服务熔断","slug":"服务熔断","date":"2020-05-31T14:43:58.000Z","updated":"2020-05-31T15:42:26.682Z","comments":true,"path":"2020/05/31/服务熔断/","link":"","permalink":"http://yoursite.com/2020/05/31/%E6%9C%8D%E5%8A%A1%E7%86%94%E6%96%AD/","excerpt":"","text":"服务熔断 hystrix，是一个用于处理分布式系统延迟和容错的库，它能够保证在一个子服务出问题的情况下，不会导致整体服务失败，避免级联雪崩，以提高分布式系统的弹性。 “断路器”本身是一个开关装置，当某个服务单元发生故障后，向调用方返回一个服务预期的、可处理的备选响应，而不是长时间等待或者抛出一个服务端无法处理的异常。这样就保证了调用方线程不会被长时间占用，从而避免故障在分布式系统中蔓延，甚至雪崩。 1、服务降级（客户端提供异常响应） 限制其他低相关服务的访问，使他们占用计算机较少的资源，从而保障主服务拥有更多的资源，使其能正常访问。 // 配置文件默认关闭，需手动开启 feign: hystrix: enabled: true # 启用服务降级 @FeignClient(name = \"MYCLOUD-PROVIDER\", fallback = HystrixConsumerService.class) public interface CorpConsumerService &#123; @GetMapping(\"/corps/&#123;id&#125;\") Corp getCorp(@PathVariable(\"id\") String id); @GetMapping(\"/corps\") List&lt;Corp&gt; getCorps(); &#125; // 客户端熔断回调缺省值处理 // 假设服务端未启动，即这么处理 @Service public class HystrixConsumerService implements CorpConsumerService &#123; public Corp getCorp(String id) &#123; return Corp.builder().id(id).name(\"HystrixConsumerService\").age(40).build(); &#125; public List&lt;Corp&gt; getCorps() &#123; return null; &#125; &#125; 2、服务熔断（服务端返回合适的异常响应） 熔断机制是对微服务雪崩效应的一种链路保护机制。 当扇出链路的某个微服务不可用或者响应时间太长时，会进行服务的降级，进而熔断该节点的微服务调用，快速返回错误的响应信息，当检测到该微服务调用响应正常后恢复调用链路。 hystrix会监控微服务之间的调用状况，当失败的调用到一定阈值，缺省是5s内20ci调用失败就会触发。熔断机制的注解是@HystrixCommand。 // 启动类配置enable @SpringBootApplication @EnableEurekaClient @EnableHystrix public class CorpProvider8005 &#123; public static void main(String[] args) &#123; SpringApplication.run(CorpProvider8005.class, args); &#125; &#125; // 添加@HystrixCommand注解 // 发生异常时，会调用hystrixCorp方法，控制台无异常堆栈 @GetMapping(\"/corps/&#123;id&#125;\") @HystrixCommand(fallbackMethod = \"hystrixCorp\") Corp getCorp(@PathVariable(\"id\") String id) &#123; Corp corp = corpService.getCorp(id); if (corp == null) &#123; throw new RuntimeException(\"id \" + id + \" 不存在\"); &#125; return corp; &#125; Corp hystrixCorp(@PathVariable(\"id\") String id) &#123; return Corp.builder().id(id).name(\"hystrix\").age(30).build(); &#125; 3、服务限流4、实时监控","categories":[{"name":"java","slug":"java","permalink":"http://yoursite.com/categories/java/"}],"tags":[{"name":"springCloud hystrix","slug":"springCloud-hystrix","permalink":"http://yoursite.com/tags/springCloud-hystrix/"}]},{"title":"负载均衡","slug":"负载均衡","date":"2020-05-31T13:32:48.000Z","updated":"2020-05-31T14:47:12.805Z","comments":true,"path":"2020/05/31/负载均衡/","link":"","permalink":"http://yoursite.com/2020/05/31/%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/","excerpt":"","text":"负载均衡 LB（load balance）：简单的说就是将用户请求平摊分配到多个服务器上，从而达到系统的高可用。 常见的负载均衡软件有nginx、lvx 常见分类 集中式LB：在服务的消费方和服务方使用独立的Lb方式，如nginx，由它负责请求转发。 进程式LB：将LB逻辑集成到消费方，消费方从注册中心获取可用的服务，再从这里面选一个进行访问，如ribbon。 ribbon 负载均衡// 配置类 @Configuration public class RestTemplateConfig &#123; @Bean @LoadBalanced RestTemplate restTemplate() &#123; return new RestTemplate(); &#125; &#125; // controller调用 // 第二版根据服务名去访问，需要将restTemplate注解为@LoadBalanced才会生效 private String service = \"http://MYCLOUD-PROVIDER\"; @RequestMapping(\"/consumer/corps/&#123;id&#125;\") Corp getCorp(@PathVariable(\"id\") String id) &#123; String url = service + \"/corps/\"; return restTemplate.getForObject(url + id, Corp.class); &#125; 使用服务名去调用，restful风格 feign 负载均衡 feign是声明式的web service客户端，只需提供一个接口，添加注解就可以了。 feign是ribbon的封装，以面向对象方式的去访问。 feign不需要去显式的声明restTemplate 使用接口注解去调用 // 逻辑处理类，映射路径为实际接口路径 @FeignClient(name = \"MYCLOUD-PROVIDER\") public interface CorpConsumerService &#123; @GetMapping(\"/corps/&#123;id&#125;\") Corp getCorp(@PathVariable(\"id\") String id); @GetMapping(\"/corps\") List&lt;Corp&gt; getCorps(); &#125; // 启动类配置enable @SpringBootApplication @EnableEurekaClient @EnableFeignClients public class CorpConsumer8002 &#123; public static void main(String[] args) &#123; SpringApplication.run(CorpConsumer8002.class, args); &#125; &#125;","categories":[{"name":"java","slug":"java","permalink":"http://yoursite.com/categories/java/"}],"tags":[{"name":"springCloud ribbon","slug":"springCloud-ribbon","permalink":"http://yoursite.com/tags/springCloud-ribbon/"}]},{"title":"euewka对比zookeeper","slug":"eureka对比zookeeper","date":"2020-05-31T13:09:42.000Z","updated":"2020-05-31T13:27:33.180Z","comments":true,"path":"2020/05/31/eureka对比zookeeper/","link":"","permalink":"http://yoursite.com/2020/05/31/eureka%E5%AF%B9%E6%AF%94zookeeper/","excerpt":"","text":"cap原则一、回顾 ACID 原则 关系数据库管理系统（Relational Database Management System：RDBMS），如mysql、oracle、sqlserver A（atomicity）原子性 C（consistency）一致性 I（Isolation）隔离性 D（durability）持久性 CAP原则 一般用于redis、mongdb C（consistency）一致性 A（avaibility）可用性 P（partition tolerance）分区容错性 由于P 分区容错性在分布式系统中是必须要满足的，所以只能在c、a之间权衡 二、zookeeper保证的是CP三、eureka保证的是AP","categories":[{"name":"java","slug":"java","permalink":"http://yoursite.com/categories/java/"}],"tags":[{"name":"springCloud","slug":"springCloud","permalink":"http://yoursite.com/tags/springCloud/"},{"name":"eureka","slug":"eureka","permalink":"http://yoursite.com/tags/eureka/"}]},{"title":"java8方法引用理解","slug":"java8方法引用理解","date":"2020-05-31T04:12:15.000Z","updated":"2020-05-31T04:13:16.886Z","comments":true,"path":"2020/05/31/java8方法引用理解/","link":"","permalink":"http://yoursite.com/2020/05/31/java8%E6%96%B9%E6%B3%95%E5%BC%95%E7%94%A8%E7%90%86%E8%A7%A3/","excerpt":"","text":"什么是方法引用?方法引用可用于在不调用方法的情况下引用方法。它将方法视为Lambda表达式。它们只能作为语法糖来减少一些lambdas的冗长。在方法引用中，将包含方法的对象（或类）放在::运算符之前，将方法的名称放在不带参数的方法之后。例如： Object :: methodName 为什么会出现方法引用？在Java中，我们可以通过创建新对象来使用对象的引用,或者引用已有的对象，例如： //创建新对象来引用该对象 List list = new ArrayList(); dosth(list); //引用已有的对象 List list2 = list; dosth(list2); 如果我们只在另一个方法中使用对象的方法，我们仍然必须将完整的对象作为参数传递。那么将方法作为参数传递不是更有效吗？ 方法引用这种语法糖不能用于所有的方法，它们只能用于只有一个方法的lambda表达式//lambda转方法引用 Consumer&lt;String&gt; c = s -&gt; System.out.println(s); Consumer&lt;String&gt; c = System.out::println; 换句话说，可以使用lambda表达式去代替一个匿名类，如果这个匿名类只有一个方法，就可以用更简短的方法引用来代替lambda表达式。 静态方法引用from (args) -&gt; Class.staticMethod(args) to Class::staticMethod 如上所述，我们不需要显式的传递参数，方法引用中会自动传递参数 Consumer&lt;String&gt; c1 = (s) -&gt; System.out.println(s); Consumer&lt;String&gt; c2 = System.out::println; c2.accept(\"Hello\"); 当我们所使用的lambda表达式仅仅调用了一个静态方法，我们就可以使用静态方法引用。如下所示，将lambda表达式（匿名类）中的值判断提取成isMoreThanFifty这个静态方法，就可以使用静态方法引用这种语法糖。 public class Numbers &#123; //将值判断提取成静态方法 public static boolean isMoreThanFifty(int n1, int n2) &#123; return (n1 + n2) &gt; 50; &#125; //公共接口方法 public static List&lt;Integer&gt; findNumbers(List&lt;Integer&gt; l, BiPredicate&lt;Integer, Integer&gt; p) &#123; List&lt;Integer&gt; newList = new ArrayList&lt;&gt;(); for (Integer i : l) &#123; if (p.test(i, i + 10)) &#123; newList.add(i); &#125; &#125; return newList; &#125; public static void main(String[] args) &#123; List&lt;Integer&gt; list = Arrays.asList(12, 5, 45, 18, 33, 24, 40); // Using an anonymous class List&lt;Integer&gt; res = Numbers.findNumbers(list, new BiPredicate&lt;Integer, Integer&gt;() &#123; @Override public boolean test(Integer integer, Integer integer2) &#123; return Numbers.isMoreThanFifty(integer, integer2); &#125; &#125;); res.stream().forEach(System.out :: println); // res.stream().peek(System.out :: println).collect(Collectors.toList()); // Using a lambda expression Numbers.findNumbers(list, (i1, i2) -&gt; Numbers.isMoreThanFifty(i1, i2)); // Using a method reference Numbers.findNumbers(list, Numbers::isMoreThanFifty); &#125; &#125; 特定类型的对象的实例方法的方法引用from (obj, args) -&gt; obj.instanceMethod(args) to ObjectType::instanceMethod 我们使用实例的类型而非实例本身 参数隐式传递public class People &#123; public double calculateWeight() &#123; double weight = 0; // Calculate weight return weight; &#125; public List&lt;Double&gt; calculateAllWeight(List&lt;People&gt; l, Function&lt;People, Double&gt; f) &#123; List&lt;Double&gt; results = new ArrayList&lt;&gt;(); for (People s : l) &#123; results.add(f.apply(s)); &#125; return results; &#125; &#125; class PeopleClient &#123; public static void main(String[] args) &#123; List&lt;People&gt; list = new ArrayList&lt;&gt;(); People p = new People(); // Using an anonymous class p.calculateAllWeight(list, new Function&lt;People, Double&gt;() &#123; @Override public Double apply(People people) &#123;// The object return people.calculateWeight();// The method &#125; &#125;); // Using a lambda expression p.calculateAllWeight(list, people -&gt; people.calculateWeight()); // Using a method reference p.calculateAllWeight(list, People::calculateWeight); &#125; &#125; 在这个例子中，我们没有给方法传递任何参数，关键在于对象的实例是lambda表达式的一个参数，我们通过实例的类型来完成对实例方法的引用。下面是另一个例子，在这个例子中，我们向方法引用中传递了两个参数。//java中有一个Function接口可以接收一个参数，BiFunction接口接受两个参数，没有接受三个参数的，所以我们自定义一个TriFunction interface TriFunction&lt;T, U, V, R&gt; &#123; R apply(T t, U u, V v); &#125; //然后定义一个类，接收两个参数，并且有一个返回值 class Sum &#123; Integer doSum(String s1, String s2) &#123; return Integer.parseInt(s1) + Integer.parseInt(s1); &#125; &#125; //用匿名类实现TriFunction，来包装doSum() TriFunction&lt;Sum, String, String, Integer&gt; anonymous = new TriFunction&lt;Sum, String, String, Integer&gt;() &#123; @Override public Integer apply(Sum s, String arg1, String arg2) &#123; return s.doSum(arg1, arg2); &#125; &#125;; System.out.println(anonymous.apply(new Sum(), \"1\", \"4\")); //使用lambda表达式来包装 TriFunction&lt;Sum, String, String, Integer&gt; lambda = (Sum s, String arg1, String arg2) -&gt; s.doSum(arg1, arg2); System.out.println(lambda.apply(new Sum(), \"1\", \"4\")); //使用方法引用 TriFunction&lt;Sum, String, String, Integer&gt; mRef = Sum::doSum; System.out.println(mRef.apply(new Sum(), \"1\", \"4\")); 第一个参数是要执行的方法的实例对象 第二、三个参数是传递的其他参数 最后一个参数是要执行的方法的返回值类型 已有对象的实例方法引用from (args) -&gt; obj.instanceMethod(args) to obj::instanceMethod 直接引用已经在其他地方实例化的对象的一个方法，本身不需要再实现一次 class Car &#123; private int id; private String color; public int getId() &#123; return id; &#125; public void setId(int id) &#123; this.id = id; &#125; &#125; class Mechanic &#123; public void fix(Car c) &#123; System.out.println(\"Fixing car \" + c.getId()); &#125; &#125; public class InstanceRef &#123; public static void main(String[] args) &#123; InstanceRef instanceRef = new InstanceRef(); final Mechanic mechanic = new Mechanic(); Car car = new Car(); // Using an anonymous class instanceRef.execute(car, new Consumer&lt;Car&gt;() &#123; public void accept(Car c) &#123; mechanic.fix(c); &#125; &#125;); // Using a lambda expression instanceRef.execute(car, car1 -&gt; mechanic.fix(car1)); //Using a method reference instanceRef.execute(car, mechanic::fix); &#125; private void execute(Car car, Consumer&lt;Car&gt; c) &#123; c.accept(car); &#125; &#125; 构造方法引用from (args) -&gt; new ClassName(args) to ClassName::new 这个lambda表达式唯一能做的就是创建一个新对象，我们通过关键字new来引用类的构造函数。与其他情况一样，参数（如果有）不会在方法引用中传递。 无参构造 // Using an anonymous class Supplier&lt;List&lt;String&gt;&gt; s = new Supplier() &#123; public List&lt;String&gt; get() &#123; return new ArrayList&lt;String&gt;(); &#125; &#125;; List&lt;String&gt; l = s.get(); // Using a lambda expression Supplier&lt;List&lt;String&gt;&gt; s = () -&gt; new ArrayList&lt;String&gt;(); List&lt;String&gt; l = s.get(); // Using a method reference Supplier&lt;List&lt;String&gt;&gt; s = ArrayList::new; List&lt;String&gt; l = s.get(); 带参构造 // Using a anonymous class BiFunction&lt;String, String, Locale&gt; f = new BiFunction&lt;String, String, Locale&gt;() &#123; public Locale apply(String lang, String country) &#123; return new Locale(lang, country); &#125; &#125;; Locale loc = f.apply(\"en\",\"UK\"); // Using a lambda expression BiFunction&lt;String, String, Locale&gt; f = (lang, country) -&gt; new Locale(lang, country); Locale loc = f.apply(\"en\",\"UK\"); // Using a method reference BiFunction&lt;String, String, Locale&gt; f = Locale::new; Locale loc = f.apply(\"en\",\"UK\"); 如果有三个及以上的参数的构造函数，则必须创建自己的函数接口。引用构造函数与引用静态方法非常相似，区别在于构造函数“方法名称”是new。 总结如果使用了方法引用之后能让代码变的更加整洁，就使用它。实际使用中，一种使用方式是将代码包裹在一个方法中，而非使用一个单独的类或者lambda表达式，然后使用方法引用的方式进行调用。方法引用常用于java8的另一种新特性Streams中，而基于方法引用的设计模式也会更加具有拓展性。","categories":[{"name":"java","slug":"java","permalink":"http://yoursite.com/categories/java/"}],"tags":[{"name":"stream","slug":"stream","permalink":"http://yoursite.com/tags/stream/"}]},{"title":"java8新特性之Stream","slug":"java8新特性之Stream","date":"2020-05-31T04:07:12.000Z","updated":"2020-05-31T04:09:19.626Z","comments":true,"path":"2020/05/31/java8新特性之Stream/","link":"","permalink":"http://yoursite.com/2020/05/31/java8%E6%96%B0%E7%89%B9%E6%80%A7%E4%B9%8BStream/","excerpt":"","text":"概述Stream API与InputStream和OutputStream是完全不同的概念，Stream API是对Java中集合操作的增强，可以利用它进行各种过滤、排序、分组、聚合等操作。Stream API配合Lambda表达式可以加大的提高代码可读性和编码效率，Stream API也支持并行操作。 流不是集合，它不关心数据的存放，只关注如何处理数据Stream API主要用于处理集合操作，不过它的处理方式与传统的方式不同，称为“数据流处理”。流（Stream）类似于关系数据库的查询操作，是一种声明式操作。比如要从数据库中获取所有年龄大于20岁的用户的名称，并按照用户的创建时间进行排序，用一条SQL语句就可以搞定，不过使用Java程序实现就会显得有些繁琐，这时候可以使用流： List&lt;String&gt; userNames = users.stream() .filter(user -&gt; user.getAge() &gt; 20) .sorted(comparing(User::getCreationDate)) .map(User::getUserName) .collect(toList()); 在Java中，集合是一种数据结构，或者说是一种容器，用于存放数据，流不是容器，它不关心数据的存放，只关注如何处理。可以把流当做是Java中的Iterator，不过它比Iterator强大多了。 流使用内部迭代方式处理数据流与集合另一个区别在于他们的遍历方式，遍历集合通常使用for-each方式，这种方式称为外部迭代，而流使用内部迭代方式，也就是说它帮你把迭代的工作做了，你只需要给出一个函数来告诉它接下来要干什么： // 外部迭代 List&lt;String&gt; list = Arrays.asList(\"A\", \"B\", \"C\", \"D\"); for (String str : list) &#123; System.out.println(str); &#125; // 内部迭代 list.stream().forEach(System.out::println); 外部迭代更像是作文题，我们不仅要控制元素的迭代方式，还需要定义怎么操作元素；内部迭代更像是填空题，我们只用关注如何操作元素就可以了。 流只能遍历一次流只能遍历一次，遍历结束后，这个流就被关闭掉了。如果要重新遍历，可以从数据源（集合）中重新获取一个流。如果你对一个流遍历两次，就会抛出java.lang.IllegalStateException异常： List&lt;String&gt; list = Arrays.asList(\"A\", \"B\", \"C\", \"D\"); Stream&lt;String&gt; stream = list.stream(); stream.forEach(System.out::println); stream.forEach(System.out::println); // 这里会抛出java.lang.IllegalStateException异常，因为流已经被关闭 流通常由三部分构成： 数据源：数据源一般用于流的获取，比如本文开头那个过滤用户的例子中users.stream()方法。 中间处理：中间处理包括对流中元素的一系列处理，如：过滤（filter()），映射（map()），排序（sorted()）。 终端处理：终端处理会生成结果，结果可以是任何不是流值，如List；也可以不返回结果，如stream.forEach(System.out::println)就是将结果打印到控制台中，并没有返回。 创建流由值创建流使用静态方法Stream.of()创建流，该方法接收一个变长参数： Stream&lt;Stream&gt; stream = Stream.of(\"A\", \"B\", \"C\", \"D\"); //也可以使用静态方法Stream.empty()创建一个空的流： Stream&lt;Stream&gt; stream = Stream.empty(); 由数组、集合 创建流使用静态方法Arrays.stream()从数组创建一个流，该方法接收一个数组参数： String[] strs = &#123;\"A\", \"B\", \"C\", \"D\"&#125;; Stream&lt;Stream&gt; stream = Arrays.stream(strs); 通过文件生成流使用java.nio.file.Files类中的很多静态方法都可以获取流，比如Files.lines()方法，该方法接收一个java.nio.file.Path对象，返回一个由文件行构成的字符串流： Stream&lt;String&gt; stream = Files.lines(Paths.get(\"text.txt\"), Charset.defaultCharset()); 通过函数创建流java.util.stream.Stream中有两个静态方法用于从函数生成流，他们分别是Stream.generate()和Stream.iterate()： // iteartor 打印100以内的所有偶数 Stream.iterate(0, n -&gt; n + 2).limit(51).forEach(System.out::println); // generate 打印10个Hello Man! Stream.generate(() -&gt; \"Hello Man!\").limit(10).forEach(System.out::println); 值得注意的是，这两个方法生成的流都是无限流，没有固定大小，可以无穷的计算下去，可以使用limit()来限制边界。 //一般来说，iterate()用于生成一系列值，比如生成以当前时间开始之后的10天的日期： Stream.iterate(LocalDate.now(), date -&gt; date.plusDays(1)).limit(10).forEach(System.out::println); //generate()方法用于生成一些随机数，比如生成10个UUID： Stream.generate(() -&gt; UUID.randomUUID().toString()).limit(10).forEach(System.out::println); collect(toList())将流中的值转换为集合//of从初识值生成新的stream，再通过collect(toList())生成新的集合 List&lt;String&gt; collect = Stream.of(\"aa\", \"bb\", \"cc\", \"aa\", \"bb\").collect(Collectors.toList()); of是惰性求值，不生成新的集合，通过collect(toList())这种及早求值才生成新的集合。返回值是stream就是惰性求值，返回值为另一个值或者空就是及早求值。 惰性求值与及早求值的区别//如下加count就是及早求值，会sout输出strs。不加count，程序不输出任何信息 strs.stream().filter(str -&gt; &#123; System.out.println(str); return str.startsWith(\"a\"); &#125; ).count(); 过滤+计数，只循环了一次。只执行fileter会返回一个stream，他不是一个新集合，仅仅是创建新集合的配方。 流常用方法过滤和排序Stream.of(1, 8, 5, 2, 1, 0, 9, 2, 0, 4, 8) .filter(n -&gt; n &gt; 2) // 对元素过滤，保留大于2的元素 .distinct() // 去重，类似于SQL语句中的DISTINCT .skip(1) // 跳过前面1个元素 .limit(2) // 返回开头2个元素，类似于SQL语句中的SELECT TOP .sorted() // 对结果排序 .forEach(System.out::println); filter 对集合的值进行过滤，必须返回true或者false 查找和匹配//检查流中的任意元素是否包含字符串\"PHP\" boolean match1 = getStream().anyMatch(s -&gt; s.equals(\"PHP\")); System.out.println(match1); boolean match2 = getStream().collect(Collectors.toList()).contains(\"PHP\"); System.out.println(match2); // 检查流中的所有元素是否都包含字符串\"#\" boolean hasAllMatch = getStream().allMatch(s -&gt; s.contains(\"#\")); // 检查流中的任意元素是否没有以\"C\"开头的字符串 boolean hasNoneMatch = getStream().noneMatch(s -&gt; s.startsWith(\"C\")); // 查找元素 Optional&lt;String&gt; element = getStream().ilter(s -&gt; s.contains(\"C\")) // .findFirst() // 查找第一个元素 .findAny(); // 查找任意元素 //获取初始流 private static Stream&lt;String&gt; getStream() &#123; return Stream.of(\"Java\", \"C#\", \"PHP\", \"C++\", \"Python\"); &#125; 每次都需要重新getStream()来获取新的流，因为之前的流已经使用并且关闭了。可以理解为若返回值不是stream，则表示已经结束了流操作 findAny的返回类型是一个Optional类（java.util.Optional），它一个容器类，代表一个值存在或不存在，用来避免控制正异常。 findFirst()和findAny()返回的都是第一个元素，通过查看javadoc描述，大致意思是findAny()是为了提高并行操作时的性能。数据大时可findany。 归约归约操作就是将流中的元素进行合并，形成一个新的值，常见的归约操作包括求和，求最大值或最小值。归约操作一般使用reduce()方法，与map()方法搭配使用，可以处理一些很复杂的归约操作。 // 获取流 List&lt;Book&gt; books = Arrays.asList( new Book(\"Java编程思想\", \"Bruce Eckel\", \"机械工业出版社\", 108.00D), new Book(\"Java 8实战\", \"Mario Fusco\", \"人民邮电出版社\", 79.00D), new Book(\"MongoDB权威指南（第2版）\", \"Kristina Chodorow\", \"人民邮电出版社\", 69.00D) ); // 计算所有图书的总价 Optional&lt;Double&gt; totalPrice = books.stream() .map(Book::getPrice) .reduce((n, m) -&gt; n + m); // 价格最高的图书 Optional&lt;Book&gt; expensive = books.stream().max(Comparator.comparing(Book::getPrice)); // 价格最低的图书 Optional&lt;Book&gt; cheapest = books.stream().min(Comparator.comparing(Book::getPrice)); // 计算总数 long count = books.stream().count() reduce从一组值中生成一个值，如累加。//0初始值，total总值，index循环的每一个值。 Integer num = Stream.of(1, 2, 3).reduce(0, (total, index) -&gt; total + index); max(min) 传入comparator进行大小比较，返回Optional对象//Optional对象(代表一个可能存在也可能不存在的值，NPE方案),通过get拿到Optional对象中的值 Integer integer = Stream.of(1, 2, 3).min(Comparator.comparing(num -&gt; num)).get(); map 将流中的值转换为新值//将list小写处理成大写 Stream.of(\"aa\", \"bb\", \"cc\", \"aa\", \"bb\").map(str -&gt; str.toUpperCase()).collect(Collectors.toList()); flatmap 把多个stream合并成一个stream并返回与map()方法类似的还有一个flatMap()，flatMap()方法让你把一个流中的每个值都换成另一个流，然后把所有的流连接起来成为一个新的流。 //传统for循环 List&lt;String&gt; names0 = new ArrayList&lt;&gt;(); for (Company company : data) &#123; List&lt;User&gt; users = company.getUesrs(); for (User user : users) &#123; if (user.getAge() &gt; 30) &#123; names0.add(user.getName()); &#125; &#125; &#125; //lambda方式1 List&lt;String&gt; names1 = data.stream() .flatMap(company -&gt; company.getUesrs().stream()) .filter(user -&gt; user.getAge() &gt; 30) .map(user -&gt; user.getName()) .collect(Collectors.toList()); //lambda方式2 List&lt;String&gt; names2 = data.stream() .map(Company::getUesrs) .flatMap(Collection::stream) .filter(user -&gt; user.getAge() &gt; 30) .map(User::getName) .collect(Collectors.toList()); 使用flatMap()方法的效果是，各个数组并不是分别映射成一个流，而是映射成流的内容。所有使用map(Arrays::stream)时生成的单个流都被合并起来，也就是对流扁平化操作。 peek 用于记录中间值（输出流中的值），不会改变流。一般用作日志输出，断点调试。List&lt;Integer&gt; nums = Stream.of(1, 2, 3, 4, 5).collect(Collectors.toList()); nums.stream().filter(num -&gt; num &gt; 3).peek(num -&gt; &#123; System.out.println(num); &#125;).collect(Collectors.toList()); 数据收集前面总结了如何创建流以及流处理，接下来总结下数据收集。数据收集是流式数据处理的终端处理，与中间处理不同的是，终端处理会消耗流，也就是说，终端处理之后，这个流就会被关闭，如果再进行中间处理，就会抛出异常。数据收集主要使用collect方法，该方法也属于归约操作，像reduce()方法那样可以接收各种做法作为参数，将流中的元素累积成一个汇总结果，具体的做法是通过定义新的Collector接口来定义的。 可以静态导入Collectors和Comparator两个类，这样就不用再去写Collectors.counting()和Comparator.comparing()。import static java.util.stream.Collectors.*; import static java.util.Comparator.*; // 求和 long count = books.stream().collect(counting()); // 价格最高的图书 Optional&lt;Book&gt; expensive = books.stream().collect(maxBy(comparing(Book::getPrice))); // 价格最低的图书 Optional&lt;Book&gt; cheapest = books.stream().collect(minBy(comparing(Book::getPrice))); 收集顺序进有序，出有序；进无序，出无序。 特定收集器stream.collect(toCollection(TreeSet::new)); 字符串操作joining//将流中的字符串通过逗号连接成一个新的字符串 String str = Stream.of(\"A\", \"B\", \"C\", \"D\").collect(joining(\",\")); List&lt;Integer&gt; data = Stream.of(1,2,3,4,5).collect(toList()); List&lt;Integer&gt; integers = Arrays.asList(1, 2, 3, 4, 5); //前后缀拼接 //传统for循环 StringBuilder sb = new StringBuilder(\"[\"); for (Integer num : integers) &#123; sb.append(num).append(\", \"); &#125; sb.append(\"]\"); System.out.println(sb); //lambda循环（map是为了将int转为string） String str = data.stream().map(String::valueOf).collect(joining(\",\", \"[\", \"]\")); System.out.println(str); 数据分块（parttitioningBy，将流分解成两个集合），传入一个pridicate对象来判断属于哪部分。//数据分块：将数据分成true和false两部分 Map&lt;Boolean, List&lt;User&gt;&gt; res = users.stream().collect(partitioningBy(user -&gt; user.getName().length() &gt; 3)); 数据分组（groupingBy）//数据分组：将数据以某个key值分成多部分 Map&lt;String, List&lt;User&gt;&gt; result = users.stream().collect(groupingBy(user -&gt; user.getAddress())); Map&lt;String, List&lt;User&gt;&gt; result = users.stream().collect(groupingBy(User::getAddress)); 组合收集器（下游收集器），在主收集器中应用下级收集器，对结果进行再次封装。//将数据分组后，不是返回每组的数据，而是统计每组的个数返回。 Map&lt;String, Long&gt; collect1 = users.stream().collect(groupingBy(User::getName, counting())); //通过mapping可以进行其他二次收集。 Map&lt;String, List&lt;String&gt;&gt; collect2 = users.stream().collect(groupingBy(User::getAddress, mapping(User::getName, toList()) )); 函数拆分示例：collect( groupingBy(key1, mapping(key2, value) ) ) 进阶集合操作map的foreach循环Map&lt;String, Integer&gt; cache = new HashMap&lt;&gt;(); Map&lt;String, List&lt;User&gt;&gt; users = new HashMap&lt;String, List&lt;User&gt;&gt;(); //传统for循环 for (Map.Entry&lt;String, List&lt;User&gt;&gt; entry : users.entrySet()) &#123; String key = entry.getKey(); List&lt;User&gt; value = entry.getValue(); cache.put(key, value.size()); &#125; //lambda方式 users.forEach((key, value) -&gt; &#123; cache.put(key, value.size()); &#125;); computeIfAbsent根据key获取某个值，若值不存在，丛数据库中取 //传统方式 public List&lt;User&gt; getUserByName(String name) &#123; List&lt;User&gt; user = users.get(name); if (user == null) &#123; user = readFromDB(name); users.put(name, user); &#125; return user; &#125; //lambda方式 public List&lt;User&gt; getUser1ByName(String name) &#123; return users.computeIfAbsent(name, this::readFromDB); &#125; private List&lt;User&gt; readFromDB(String name) &#123; return new ArrayList&lt;&gt;(); &#125;","categories":[{"name":"java","slug":"java","permalink":"http://yoursite.com/categories/java/"}],"tags":[{"name":"stream","slug":"stream","permalink":"http://yoursite.com/tags/stream/"}]},{"title":"Hello World","slug":"hello-world","date":"2020-05-31T01:14:54.029Z","updated":"2020-05-31T01:14:54.029Z","comments":true,"path":"2020/05/31/hello-world/","link":"","permalink":"http://yoursite.com/2020/05/31/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post$ hexo new \"My New Post\" More info: Writing Run server$ hexo server More info: Server Generate static files$ hexo generate More info: Generating Deploy to remote sites$ hexo deploy More info: Deployment","categories":[],"tags":[]}],"categories":[{"name":"java","slug":"java","permalink":"http://yoursite.com/categories/java/"}],"tags":[{"name":"springCloud hystrix","slug":"springCloud-hystrix","permalink":"http://yoursite.com/tags/springCloud-hystrix/"},{"name":"springCloud ribbon","slug":"springCloud-ribbon","permalink":"http://yoursite.com/tags/springCloud-ribbon/"},{"name":"springCloud","slug":"springCloud","permalink":"http://yoursite.com/tags/springCloud/"},{"name":"eureka","slug":"eureka","permalink":"http://yoursite.com/tags/eureka/"},{"name":"stream","slug":"stream","permalink":"http://yoursite.com/tags/stream/"}]}
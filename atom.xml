<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>foreverorange</title>
  
  
  <link href="/blog/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2020-06-13T15:17:05.142Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>foreverorange</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>eureka源码</title>
    <link href="http://yoursite.com/2020/06/13/eureka%E6%BA%90%E7%A0%81/"/>
    <id>http://yoursite.com/2020/06/13/eureka%E6%BA%90%E7%A0%81/</id>
    <published>2020-06-13T13:35:50.000Z</published>
    <updated>2020-06-13T15:17:05.142Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、两种方式禁用服务注册"><a href="#一、两种方式禁用服务注册" class="headerlink" title="一、两种方式禁用服务注册"></a>一、两种方式禁用服务注册</h2><h3 id="1、-EnableDiscoveryClient-autoRegister-false"><a href="#1、-EnableDiscoveryClient-autoRegister-false" class="headerlink" title="1、@EnableDiscoveryClient(autoRegister=false)"></a>1、@EnableDiscoveryClient(autoRegister=false)</h3><h3 id="2、spring-cloud-service-registry-auto-registration-enabled-false"><a href="#2、spring-cloud-service-registry-auto-registration-enabled-false" class="headerlink" title="2、spring.cloud.service-registry.auto-registration.enabled=false"></a>2、spring.cloud.service-registry.auto-registration.enabled=false</h3><pre><code class="hljs java"><span class="hljs-meta">@Import</span>(EnableDiscoveryClientImportSelector<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span><span class="hljs-class"><span class="hljs-title">public</span> @<span class="hljs-title">interface</span> <span class="hljs-title">EnableDiscoveryClient</span> </span>&#123;<span class="hljs-comment">/**</span><span class="hljs-comment"> * If true, the ServiceRegistry will automatically register the local server.</span><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> - &#123;<span class="hljs-doctag">@code</span> true&#125; if you want to automatically register.</span><span class="hljs-comment"> */</span><span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">autoRegister</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">true</span></span>;&#125;</code></pre><ul><li>该配置项默认为true，但是可以主动声明去禁用</li></ul><p><strong><code>@Import(EnableDiscoveryClientImportSelector.class)</code></strong>的源码如下：</p><pre><code class="hljs java"><span class="hljs-meta">@Order</span>(Ordered.LOWEST_PRECEDENCE - <span class="hljs-number">100</span>)<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">EnableDiscoveryClientImportSelector</span></span><span class="hljs-class"><span class="hljs-keyword">extends</span> <span class="hljs-title">SpringFactoryImportSelector</span>&lt;<span class="hljs-title">EnableDiscoveryClient</span>&gt; </span>&#123;<span class="hljs-meta">@Override</span><span class="hljs-keyword">public</span> String[] selectImports(AnnotationMetadata metadata) &#123;    <span class="hljs-comment">// 父类loadFactoryNames方法，定义去加载了FACTORIES_RESOURCE_LOCATION = "META-INF/spring.factories";中所有的自动配置类</span>String[] imports = <span class="hljs-keyword">super</span>.selectImports(metadata);AnnotationAttributes attributes = AnnotationAttributes.fromMap(metadata.getAnnotationAttributes(getAnnotationClass().getName(), <span class="hljs-keyword">true</span>));<span class="hljs-comment">// 获取注解声明的autoRegister，从而调用实际处理</span><span class="hljs-keyword">boolean</span> autoRegister = attributes.getBoolean(<span class="hljs-string">"autoRegister"</span>);<span class="hljs-keyword">if</span> (autoRegister) &#123;List&lt;String&gt; importsList = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;(Arrays.asList(imports));importsList.add(<span class="hljs-string">"org.springframework.cloud.client.serviceregistry.AutoServiceRegistrationConfiguration"</span>);imports = importsList.toArray(<span class="hljs-keyword">new</span> String[<span class="hljs-number">0</span>]);&#125;<span class="hljs-keyword">else</span> &#123;Environment env = getEnvironment();<span class="hljs-keyword">if</span> (ConfigurableEnvironment<span class="hljs-class">.<span class="hljs-keyword">class</span>.<span class="hljs-title">isInstance</span>(<span class="hljs-title">env</span>)) </span>&#123;ConfigurableEnvironment configEnv = (ConfigurableEnvironment) env;LinkedHashMap&lt;String, Object&gt; map = <span class="hljs-keyword">new</span> LinkedHashMap&lt;&gt;();        <span class="hljs-comment">// 从这里可以看出，其实还是通过这个方式处理的</span>map.put(<span class="hljs-string">"spring.cloud.service-registry.auto-registration.enabled"</span>, <span class="hljs-keyword">false</span>);MapPropertySource propertySource = <span class="hljs-keyword">new</span> MapPropertySource(<span class="hljs-string">"springCloudDiscoveryClient"</span>, map);configEnv.getPropertySources().addLast(propertySource);&#125;&#125;<span class="hljs-keyword">return</span> imports;&#125;</code></pre><h2 id="二、springCloud对netflixEureka进行了封装"><a href="#二、springCloud对netflixEureka进行了封装" class="headerlink" title="二、springCloud对netflixEureka进行了封装"></a>二、springCloud对netflixEureka进行了封装</h2><p>打开<code>spring-cloud-starter-netflix-eureka-client.jar</code>，找到<code>META-INF/spring.factories</code>，内容如下：</p><pre><code class="hljs yaml"><span class="hljs-string">org.springframework.boot.autoconfigure.EnableAutoConfiguration=\</span><span class="hljs-string">org.springframework.cloud.netflix.eureka.config.EurekaClientConfigServerAutoConfiguration,\</span><span class="hljs-string">org.springframework.cloud.netflix.eureka.config.DiscoveryClientOptionalArgsConfiguration,\</span><span class="hljs-comment"># EurekaClient的自动配置类</span><span class="hljs-string">org.springframework.cloud.netflix.eureka.EurekaClientAutoConfiguration,\</span><span class="hljs-string">org.springframework.cloud.netflix.ribbon.eureka.RibbonEurekaAutoConfiguration,\</span><span class="hljs-comment"># EurekaDiscoveryClient的自动配置类，默认就扫描加载了</span><span class="hljs-string">org.springframework.cloud.netflix.eureka.EurekaDiscoveryClientConfiguration,\</span><span class="hljs-string">org.springframework.cloud.netflix.eureka.reactive.EurekaReactiveDiscoveryClientConfiguration,\</span><span class="hljs-string">org.springframework.cloud.netflix.eureka.loadbalancer.LoadBalancerEurekaAutoConfiguration</span><span class="hljs-string">org.springframework.cloud.bootstrap.BootstrapConfiguration=\</span><span class="hljs-string">org.springframework.cloud.netflix.eureka.config.EurekaConfigServerBootstrapConfiguration</span></code></pre><p>打开<code>EurekaDiscoveryClientConfiguration</code>，发现，其构造是注入了netflix的EurekaClient，其本身也是一层包装</p><pre><code class="hljs java"><span class="hljs-keyword">import</span> com.netflix.discovery.EurekaClient;<span class="hljs-keyword">import</span> com.netflix.discovery.EurekaClientConfig;<span class="hljs-meta">@Bean</span><span class="hljs-meta">@ConditionalOnMissingBean</span><span class="hljs-function"><span class="hljs-keyword">public</span> EurekaDiscoveryClient <span class="hljs-title">discoveryClient</span><span class="hljs-params">(EurekaClient client,</span></span><span class="hljs-function"><span class="hljs-params">                                             EurekaClientConfig clientConfig)</span> </span>&#123;  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> EurekaDiscoveryClient(client, clientConfig);&#125;</code></pre><p>点进去<code>EurekaClient</code>,其接口和实现类<code>DiscoveryClient</code></p><pre><code class="hljs java"><span class="hljs-meta">@ImplementedBy</span>(DiscoveryClient<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span><span class="hljs-class"><span class="hljs-title">public</span> <span class="hljs-title">interface</span> <span class="hljs-title">EurekaClient</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">LookupService</span> </span>&#123;  ···&#125;</code></pre><p>在<code>DiscoveryClient</code>的构造函数中进行了定时任务的初始化</p><pre><code class="hljs java"><span class="hljs-meta">@Inject</span>DiscoveryClient(ApplicationInfoManager applicationInfoManager, EurekaClientConfig config, AbstractDiscoveryClientOptionalArgs args,                Provider&lt;BackupRegistry&gt; backupRegistryProvider, EndpointRandomizer endpointRandomizer) &#123;···<span class="hljs-comment">// finally, init the schedule tasks (e.g. cluster resolvers, heartbeat, instanceInfo replicator, fetch</span>initScheduledTasks();···</code></pre><h2 id="三、服务获取"><a href="#三、服务获取" class="headerlink" title="三、服务获取"></a>三、服务获取</h2><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * Initializes all scheduled tasks.</span><span class="hljs-comment"> */</span><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">initScheduledTasks</span><span class="hljs-params">()</span> </span>&#123;  <span class="hljs-comment">// 内部是EurekaClientConfigBean中的`eureka.client.fetch-registry=true`参数判断</span>    <span class="hljs-keyword">if</span> (clientConfig.shouldFetchRegistry()) &#123;        <span class="hljs-comment">// registry cache refresh timer</span>        <span class="hljs-keyword">int</span> registryFetchIntervalSeconds = clientConfig.getRegistryFetchIntervalSeconds();        <span class="hljs-keyword">int</span> expBackOffBound = clientConfig.getCacheRefreshExecutorExponentialBackOffBound();      <span class="hljs-comment">// 声明了一个定时任务</span>        cacheRefreshTask = <span class="hljs-keyword">new</span> TimedSupervisorTask(                <span class="hljs-string">"cacheRefresh"</span>,                scheduler,                cacheRefreshExecutor,                registryFetchIntervalSeconds,<span class="hljs-comment">//默认更新周期，30s</span>                TimeUnit.SECONDS,                expBackOffBound,                <span class="hljs-keyword">new</span> CacheRefreshThread()        );              scheduler.schedule(                cacheRefreshTask,                registryFetchIntervalSeconds, TimeUnit.SECONDS);    &#125;····</code></pre><ul><li>服务获取的逻辑处理是一个单独的if</li><li>其判断依据就是eureka.client.fetch-registry=true参数</li></ul><pre><code class="hljs java"><span class="hljs-meta">@ConfigurationProperties</span>(EurekaClientConfigBean.PREFIX)<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">EurekaClientConfigBean</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">EurekaClientConfig</span>, <span class="hljs-title">Ordered</span> </span>&#123;<span class="hljs-comment">/**</span><span class="hljs-comment"> * Default prefix for Eureka client config properties.</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String PREFIX = <span class="hljs-string">"eureka.client"</span>;<span class="hljs-comment">/**</span><span class="hljs-comment"> * Indicates whether this client should fetch eureka registry information from eureka</span><span class="hljs-comment"> * server.</span><span class="hljs-comment"> */</span>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> fetchRegistry = <span class="hljs-keyword">true</span>;</code></pre><h2 id="四、服务注册"><a href="#四、服务注册" class="headerlink" title="四、服务注册"></a>四、服务注册</h2><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment">     * Initializes all scheduled tasks.</span><span class="hljs-comment">     */</span><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">initScheduledTasks</span><span class="hljs-params">()</span> </span>&#123;  ···    <span class="hljs-keyword">if</span> (clientConfig.shouldRegisterWithEureka()) &#123;      ···      <span class="hljs-comment">// InstanceInfo replicator</span>      instanceInfoReplicator = <span class="hljs-keyword">new</span> InstanceInfoReplicator(        <span class="hljs-keyword">this</span>,        instanceInfo,        clientConfig.getInstanceInfoReplicationIntervalSeconds(),        <span class="hljs-number">2</span>); <span class="hljs-comment">// burstSize</span>      ···      instanceInfoReplicator.start(clientConfig.getInitialInstanceInfoReplicationIntervalSeconds());    &#125; <span class="hljs-keyword">else</span> &#123;      logger.info(<span class="hljs-string">"Not registering with Eureka server per configuration"</span>);    &#125;&#125;</code></pre><ul><li>创建了一个instanceInfoReplicator实例，start调用进行定时任务</li></ul><p>定时任务具体如下：</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;  <span class="hljs-keyword">try</span> &#123;    discoveryClient.refreshInstanceInfo();    Long dirtyTimestamp = instanceInfo.isDirtyWithTime();    <span class="hljs-keyword">if</span> (dirtyTimestamp != <span class="hljs-keyword">null</span>) &#123;      <span class="hljs-comment">// 真是出发调用注册的地方就在这里</span>      discoveryClient.register();     ···&#125;<span class="hljs-comment">/**</span><span class="hljs-comment">     * Register with the eureka service by making the appropriate REST call.</span><span class="hljs-comment">     */</span><span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">register</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Throwable </span>&#123;  logger.info(PREFIX + <span class="hljs-string">"&#123;&#125;: registering service..."</span>, appPathIdentifier);  EurekaHttpResponse&lt;Void&gt; httpResponse;  <span class="hljs-keyword">try</span> &#123;    <span class="hljs-comment">// 注册也是通过rest请求，传入了一个instanceInfo对象</span>    httpResponse = eurekaTransport.registrationClient.register(instanceInfo);  &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;    logger.warn(PREFIX + <span class="hljs-string">"&#123;&#125; - registration failed &#123;&#125;"</span>, appPathIdentifier, e.getMessage(), e);    <span class="hljs-keyword">throw</span> e;  &#125;  <span class="hljs-keyword">if</span> (logger.isInfoEnabled()) &#123;    logger.info(PREFIX + <span class="hljs-string">"&#123;&#125; - registration status: &#123;&#125;"</span>, appPathIdentifier, httpResponse.getStatusCode());  &#125;  <span class="hljs-keyword">return</span> httpResponse.getStatusCode() == Status.NO_CONTENT.getStatusCode();&#125;</code></pre><h2 id="五、服务续约"><a href="#五、服务续约" class="headerlink" title="五、服务续约"></a>五、服务续约</h2><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * Initializes all scheduled tasks.</span><span class="hljs-comment"> */</span><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">initScheduledTasks</span><span class="hljs-params">()</span> </span>&#123;    ···    <span class="hljs-keyword">if</span> (clientConfig.shouldRegisterWithEureka()) &#123;        <span class="hljs-keyword">int</span> renewalIntervalInSecs = instanceInfo.getLeaseInfo().getRenewalIntervalInSecs();        <span class="hljs-keyword">int</span> expBackOffBound = clientConfig.getHeartbeatExecutorExponentialBackOffBound();        logger.info(<span class="hljs-string">"Starting heartbeat executor: "</span> + <span class="hljs-string">"renew interval is: &#123;&#125;"</span>, renewalIntervalInSecs);        <span class="hljs-comment">// Heartbeat timer</span>        heartbeatTask = <span class="hljs-keyword">new</span> TimedSupervisorTask(                <span class="hljs-string">"heartbeat"</span>,                scheduler,                heartbeatExecutor,                renewalIntervalInSecs,                TimeUnit.SECONDS,                expBackOffBound,                <span class="hljs-keyword">new</span> HeartbeatThread()        );        scheduler.schedule(                heartbeatTask,                renewalIntervalInSecs, TimeUnit.SECONDS);···&#125;  <span class="hljs-comment">/**</span><span class="hljs-comment">     * The heartbeat task that renews the lease in the given intervals.</span><span class="hljs-comment">     */</span><span class="hljs-keyword">private</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HeartbeatThread</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Runnable</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;      <span class="hljs-keyword">if</span> (renew()) &#123;        lastSuccessfulHeartbeatTimestamp = System.currentTimeMillis();      &#125;    &#125;&#125;  <span class="hljs-comment">/**</span><span class="hljs-comment">     * Renew with the eureka service by making the appropriate REST call</span><span class="hljs-comment">     */</span><span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">renew</span><span class="hljs-params">()</span> </span>&#123;  EurekaHttpResponse&lt;InstanceInfo&gt; httpResponse;  <span class="hljs-keyword">try</span> &#123;    <span class="hljs-comment">// 续约也是rest方式</span>    httpResponse = eurekaTransport.registrationClient.sendHeartBeat(instanceInfo.getAppName(), instanceInfo.getId(), instanceInfo, <span class="hljs-keyword">null</span>);    logger.debug(PREFIX + <span class="hljs-string">"&#123;&#125; - Heartbeat status: &#123;&#125;"</span>, appPathIdentifier, httpResponse.getStatusCode());    <span class="hljs-keyword">if</span> (httpResponse.getStatusCode() == Status.NOT_FOUND.getStatusCode()) &#123;      REREGISTER_COUNTER.increment();      logger.info(PREFIX + <span class="hljs-string">"&#123;&#125; - Re-registering apps/&#123;&#125;"</span>, appPathIdentifier, instanceInfo.getAppName());      <span class="hljs-keyword">long</span> timestamp = instanceInfo.setIsDirtyWithTime();      <span class="hljs-keyword">boolean</span> success = register();      <span class="hljs-keyword">if</span> (success) &#123;        instanceInfo.unsetIsDirty(timestamp);      &#125;      <span class="hljs-keyword">return</span> success;    &#125;    <span class="hljs-keyword">return</span> httpResponse.getStatusCode() == Status.OK.getStatusCode();  &#125; <span class="hljs-keyword">catch</span> (Throwable e) &#123;    logger.error(PREFIX + <span class="hljs-string">"&#123;&#125; - was unable to send heartbeat!"</span>, appPathIdentifier, e);    <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;  &#125;&#125;</code></pre><ul><li>声明了一个heartbeatTask定时任务进行续约，传入HeartbeatThread</li><li>服务续约也是rest方式</li></ul><h2 id="六、配置详解"><a href="#六、配置详解" class="headerlink" title="六、配置详解"></a>六、配置详解</h2><p><code>META-INF/spring.factories</code>，内容中还有个<code>EurekaClientAutoConfiguration</code>，用于加载配置参数类</p><pre><code class="hljs yaml"><span class="hljs-comment"># EurekaClient的自动配置类</span><span class="hljs-string">org.springframework.cloud.netflix.eureka.EurekaClientAutoConfiguration,\</span></code></pre><pre><code class="hljs java"><span class="hljs-meta">@Bean</span><span class="hljs-meta">@ConditionalOnMissingBean</span>(value = EurekaClientConfig<span class="hljs-class">.<span class="hljs-keyword">class</span>,</span><span class="hljs-class">                          <span class="hljs-title">search</span> </span>= SearchStrategy.CURRENT)<span class="hljs-function"><span class="hljs-keyword">public</span> EurekaClientConfigBean <span class="hljs-title">eurekaClientConfigBean</span><span class="hljs-params">(ConfigurableEnvironment env)</span> </span>&#123;  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> EurekaClientConfigBean();&#125;<span class="hljs-meta">@Bean</span><span class="hljs-meta">@ConditionalOnMissingBean</span>(value = EurekaInstanceConfig<span class="hljs-class">.<span class="hljs-keyword">class</span>,</span><span class="hljs-class">                          <span class="hljs-title">search</span> </span>= SearchStrategy.CURRENT)<span class="hljs-function"><span class="hljs-keyword">public</span> EurekaInstanceConfigBean <span class="hljs-title">eurekaInstanceConfigBean</span><span class="hljs-params">(InetUtils inetUtils,</span></span><span class="hljs-function"><span class="hljs-params">                                                         ManagementMetadataProvider managementMetadataProvider)</span> </span>&#123;&#125;</code></pre><ul><li>可以查看<code>EurekaClientConfigBean</code>和<code>EurekaInstanceConfigBean</code>获取比官方文档更详细的解释说明</li><li>eureka的所有的配置信息，都是通过<code>EurekaInstanceConfigBean</code>加载的，真正注册时，内部包装成<code>InstanceInfo</code>进行传递</li></ul><h3 id="1、注册中心配置"><a href="#1、注册中心配置" class="headerlink" title="1、注册中心配置"></a>1、注册中心配置</h3><ul><li><code>eureka.client.serverUrl.defaultZone=xxx</code>：</li></ul><pre><code class="hljs java"><span class="hljs-keyword">private</span> Map&lt;String, String&gt; serviceUrl = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();&#123;   <span class="hljs-keyword">this</span>.serviceUrl.put(DEFAULT_ZONE, DEFAULT_URL);&#125;<span class="hljs-comment">/**</span><span class="hljs-comment"> * Default Eureka URL.</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String DEFAULT_URL = <span class="hljs-string">"http://localhost:8761"</span> + DEFAULT_PREFIX+ <span class="hljs-string">"/"</span>;<span class="hljs-comment">/**</span><span class="hljs-comment"> * Default availability zone if none is resolved based on region.</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String DEFAULT_ZONE = <span class="hljs-string">"defaultZone"</span>;</code></pre><h3 id="2、实例名配置"><a href="#2、实例名配置" class="headerlink" title="2、实例名配置"></a>2、实例名配置</h3><ul><li><code>eureka.instance.instanceId</code></li><li>它是区分同一服务不同实例的唯一标识</li><li>实例名采用主机名作为唯一标识，规则如下</li></ul><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title">getDefaultInstanceId</span><span class="hljs-params">(PropertyResolver resolver,</span></span><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">boolean</span> includeHostname)</span> </span>&#123;String vcapInstanceId = resolver.getProperty(<span class="hljs-string">"vcap.application.instance_id"</span>);<span class="hljs-keyword">if</span> (StringUtils.hasText(vcapInstanceId)) &#123;<span class="hljs-keyword">return</span> vcapInstanceId;&#125;String hostname = <span class="hljs-keyword">null</span>;<span class="hljs-keyword">if</span> (includeHostname) &#123;hostname = resolver.getProperty(<span class="hljs-string">"spring.cloud.client.hostname"</span>);&#125;String appName = resolver.getProperty(<span class="hljs-string">"spring.application.name"</span>);String namePart = combineParts(hostname, SEPARATOR, appName);String indexPart = resolver.getProperty(<span class="hljs-string">"spring.application.instance_id"</span>,resolver.getProperty(<span class="hljs-string">"server.port"</span>));<span class="hljs-keyword">return</span> combineParts(namePart, SEPARATOR, indexPart);&#125;</code></pre><blockquote><p>即 <code>${spring.cloud.client.hostname}:${spring.application.name}:${spring.application.instance_id}</code></p></blockquote><h3 id="3、端点配置"><a href="#3、端点配置" class="headerlink" title="3、端点配置"></a>3、端点配置</h3><ul><li><p><code>homePageUrl、statusPageUrl、healthCheckUrl</code>，即<code>spring-boot-actuator</code>模块提供的<code>/info</code>和<code>/health</code>端点</p></li><li><p>当应用设置了context-path时，端点也需要加上该前缀</p></li></ul><pre><code class="hljs ini"><span class="hljs-attr">xxx.context-path</span>=/orange<span class="hljs-attr">eureka.instance.statusPageUrlPath</span>=<span class="hljs-variable">$&#123;xxx.context-path&#125;</span>/info<span class="hljs-attr">eureka.instance.healthCheckUrlPath</span>=<span class="hljs-variable">$&#123;xxx.context-path&#125;</span>/health</code></pre><ul><li>或者为了安全考虑，修改端点的原始路径</li></ul><pre><code class="hljs ini"><span class="hljs-attr">endpoints.info.path</span>=/orangeInfo<span class="hljs-attr">endpoints.health.path</span>=/orangeHealth<span class="hljs-attr">eureka.instance.statusPageUrlPath</span>=<span class="hljs-variable">$&#123;endpoints.info.path&#125;</span><span class="hljs-attr">eureka.instance.healthCheckUrlPath</span>=<span class="hljs-variable">$&#123;endpoints.health.path&#125;</span></code></pre><h3 id="4、健康检查"><a href="#4、健康检查" class="headerlink" title="4、健康检查"></a>4、健康检查</h3><ul><li>客户端默认的心跳方式可以有效的检查客户端进程是否运行，但是无法保证客户端能否正常提供服务</li><li>可以把客户端的健康检查交给actuator</li></ul><pre><code class="hljs yaml"><span class="hljs-comment"># 在pom中引入Spring-boot-starter-actuator</span><span class="hljs-comment"># 增加参数配置：eureka.client.healthcheck.enabled=true</span></code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;一、两种方式禁用服务注册&quot;&gt;&lt;a href=&quot;#一、两种方式禁用服务注册&quot; class=&quot;headerlink&quot; title=&quot;一、两种方式禁用服务注册&quot;&gt;&lt;/a&gt;一、两种方式禁用服务注册&lt;/h2&gt;&lt;h3 id=&quot;1、-EnableDiscoveryClient-
      
    
    </summary>
    
    
      <category term="springCloud" scheme="http://yoursite.com/categories/springCloud/"/>
    
    
      <category term="eureka" scheme="http://yoursite.com/tags/eureka/"/>
    
  </entry>
  
  <entry>
    <title>eureka组件</title>
    <link href="http://yoursite.com/2020/06/09/eureka%E7%BB%84%E4%BB%B6/"/>
    <id>http://yoursite.com/2020/06/09/eureka%E7%BB%84%E4%BB%B6/</id>
    <published>2020-06-09T12:50:00.000Z</published>
    <updated>2020-06-13T15:17:20.004Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、EnableDiscoveryClient与EnableEurekaClient的区别"><a href="#一、EnableDiscoveryClient与EnableEurekaClient的区别" class="headerlink" title="一、EnableDiscoveryClient与EnableEurekaClient的区别"></a>一、EnableDiscoveryClient与EnableEurekaClient的区别</h2><p>Spring Cloud版本：Angle -&gt; Brixton -&gt; Camden -&gt; Dalston -&gt; Edgware -&gt; Finchley-&gt;Greenwich-&gt;Hoxton</p><blockquote><ol><li>Dalston或更早期的版本,为了启用服务注册发现功能。需要在主启动类上增加<code>@EnableDiscoveryClient</code>或者<code>@EnableEurekaClient</code>注解。</li><li><code>@EnableEurekaClient</code>内部使用了<code>@EnableDiscoveryClient</code>注解，因此如果要使用eureka的注册发现服务，两者功能是一样的。</li><li>EnableDiscoveryClient注解在spring.factories配置中通过配置项EurekaDiscoveryClientConfiguration来开启服务注册发现功能。</li></ol></blockquote><ul><li>@EnableDiscoveryClient注解是基于spring-cloud-commons依赖，并且在classpath中实现。</li><li>@EnableEurekaClient注解是基于spring-cloud-netflix依赖，只能为eureka作用。</li><li>@EnableEurekaClient只适用于Eureka作为注册中心，@EnableDiscoveryClient 可以是其他注册中心。</li></ul><h2 id="二、-EnableDiscoveryClient注解现在也没用了（Dalston之后的版本中（不含Dalston））"><a href="#二、-EnableDiscoveryClient注解现在也没用了（Dalston之后的版本中（不含Dalston））" class="headerlink" title="二、 @EnableDiscoveryClient注解现在也没用了（Dalston之后的版本中（不含Dalston））"></a>二、 @EnableDiscoveryClient注解现在也没用了（Dalston之后的版本中（不含Dalston））</h2><p>只要依赖了以spring-cloud-starter-netflix为前缀的库(例如spring-cloud-starter-netflix-eureka-client)，就启用了服务注册发现功能。</p><p>使用配置项<code>spring.cloud.service-registry.auto-registration.enabled=false</code>即可禁止服务注册发现功能。</p><p>spring容器在查询spring.factories的过程中，如果找到了EnableDiscoveryClient的配置，就会实例化该配置对应的服务注册发现：例如eureka、consul、zookeeper等。</p><p>打开工程spring-cloud-netflix-eureka-client.jar，去看src\main\resources\META-INF目录下的spring.factories文件，发现在springboot的自动配置项中，出现了一个关键配置EurekaDiscoveryClientConfiguration，如下：</p><pre><code class="hljs yaml"><span class="hljs-string">org.springframework.boot.autoconfigure.EnableAutoConfiguration=\</span><span class="hljs-string">org.springframework.cloud.netflix.eureka.config.EurekaClientConfigServerAutoConfiguration,\</span><span class="hljs-string">org.springframework.cloud.netflix.eureka.config.DiscoveryClientOptionalArgsConfiguration,\</span><span class="hljs-string">org.springframework.cloud.netflix.eureka.EurekaClientAutoConfiguration,\</span><span class="hljs-string">org.springframework.cloud.netflix.ribbon.eureka.RibbonEurekaAutoConfiguration,\</span><span class="hljs-string">org.springframework.cloud.netflix.eureka.EurekaDiscoveryClientConfiguration,\</span><span class="hljs-string">org.springframework.cloud.netflix.eureka.reactive.EurekaReactiveDiscoveryClientConfiguration,\</span><span class="hljs-string">org.springframework.cloud.netflix.eureka.loadbalancer.LoadBalancerEurekaAutoConfiguration</span><span class="hljs-string">org.springframework.cloud.bootstrap.BootstrapConfiguration=\</span><span class="hljs-string">org.springframework.cloud.netflix.eureka.config.EurekaConfigServerBootstrapConfiguration</span></code></pre><blockquote><ol><li><p>在spring.factories配置中，配置类EurekaDiscoveryClientConfiguration被配置到springboot的自动配置注解中，与EnableDiscoveryClient注解没有关系了,也就是说只要开启了springboot的自动配置，服务注册发现功能就会启用。</p></li><li><p>EnableEurekaClient源码中没有使用注解EnableDiscoveryClient，此时EnableEurekaClient已经没用了。</p></li></ol></blockquote><h2 id="三、Eureka两个组件：Eureka-Server和Eureka-Client。"><a href="#三、Eureka两个组件：Eureka-Server和Eureka-Client。" class="headerlink" title="三、Eureka两个组件：Eureka Server和Eureka Client。"></a>三、Eureka两个组件：Eureka Server和Eureka Client。</h2><p><strong>Eureka Server</strong></p><ul><li>Eureka Server 提供服务发现能力，各个微服务启动时，会向Eureka Server注册自己的信息（例如IP、端口、微服务名称等），Eureka Server会存储这些信息。</li><li>Eureka Server作为一个独立的部署单元，以REST API的形式为服务实例提供了注册、管理和查询等操作。同时，Eureka Server也为我们提供了可视化的监控页面，可以直观地看到各个Eureka Server当前的运行状态和所有已注册服务的情况。</li></ul><p><strong>Eureka Client</strong></p><ul><li><p>Erueka Client是一个java客户端，用于简化与Eureka的交互。</p></li><li><p>微服务启动后，会周期性（默认30s）地向Eureka Server发送心跳以续约自己的“ 租期 ”。</p></li><li><p>如果Eureka server在一定的时间内没有接收到某个微服务实例的心跳，Eureka Server将注销该实例（默认90s）。</p></li><li><p>默认情况下，Eureka Server同时也是Eureka Client。 多个Eureka Server 实例互相之间通过复制的方式来实现服务注册表中数据的同步。</p></li><li><p>Eureka Client 会缓存服务注册表中的信息，这种方式有一定的优势——首先，无须每次请求都查询Eureka Server，从而降低了Eureka Server的压力；其次，即使Eureka Server所有节点都宕掉，服务消费者依然可以使用缓存中的信息找到服务提供者并完成调用。 综上，Eureka通过心跳检查、客户端缓存等机制，提高了系统的灵活性、可伸缩性和可用性。</p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;一、EnableDiscoveryClient与EnableEurekaClient的区别&quot;&gt;&lt;a href=&quot;#一、EnableDiscoveryClient与EnableEurekaClient的区别&quot; class=&quot;headerlink&quot; title=&quot;一、
      
    
    </summary>
    
    
      <category term="springCloud" scheme="http://yoursite.com/categories/springCloud/"/>
    
    
      <category term="eureka" scheme="http://yoursite.com/tags/eureka/"/>
    
  </entry>
  
  <entry>
    <title>RestTemplate使用</title>
    <link href="http://yoursite.com/2020/06/08/RestTemplate%E4%BD%BF%E7%94%A8/"/>
    <id>http://yoursite.com/2020/06/08/RestTemplate%E4%BD%BF%E7%94%A8/</id>
    <published>2020-06-08T13:05:44.000Z</published>
    <updated>2020-06-08T13:57:05.423Z</updated>
    
    <content type="html"><![CDATA[<h1 id="restTemplate详解"><a href="#restTemplate详解" class="headerlink" title="restTemplate详解"></a>restTemplate详解</h1><ul><li>该对象会使用ribbon的自动化配置，同时通过@LoadBalanced注解修饰还能开启客户端负载均衡</li></ul><h2 id="一、GET请求"><a href="#一、GET请求" class="headerlink" title="一、GET请求"></a>一、GET请求</h2><h3 id="1-1-getForEntity"><a href="#1-1-getForEntity" class="headerlink" title="1.1 getForEntity"></a>1.1 getForEntity</h3><ul><li>该方法返回的是ResponseEntity，是spring对HTTP响应的封装。</li></ul><blockquote><p>主要存储了HTTP的几个重要元素，如HttpStatus状态码。在HttpEntity中还存储着HttpHeaders以及范型类型的请求体对象。</p></blockquote><p><strong>三种常见的重载方式</strong></p><pre><code class="hljs java">getForEntity(String url, Class&lt;T&gt; responseType, Object... uriVariables) <span class="hljs-comment">// 如 restTemplate.getForEntity("http://MYCLOUD-PROVIDER/user?name=&#123;1&#125;", String.class, "orange");</span></code></pre><ul><li>url中使用占位符的方式进行参数绑定。</li><li>第二个参数为返回值的包装类型。</li></ul><hr><pre><code class="hljs java">RestTemplate restTemplate = <span class="hljs-keyword">new</span> RestTemplate();Map&lt;String, String&gt; params = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();params.put(<span class="hljs-string">"key"</span>, <span class="hljs-string">"orange"</span>);restTemplate.getForEntity(<span class="hljs-string">"http://MYCLOUD-PROVIDER/user?name=&#123;key&#125;"</span>, String<span class="hljs-class">.<span class="hljs-keyword">class</span>, <span class="hljs-title">params</span>)</span>;</code></pre><ul><li>参数绑定的方式稍有不同。</li></ul><hr><pre><code class="hljs java">RestTemplate restTemplate = <span class="hljs-keyword">new</span> RestTemplate();UriComponents uriComponents = UriComponentsBuilder  .fromUriString(<span class="hljs-string">"http://MYCLOUD-PROVIDER/user?name=&#123;key&#125;"</span>)  .build()  .expand(<span class="hljs-string">"orange"</span>)  .encode();URI uri = uriComponents.toUri();ResponseEntity&lt;String&gt; forEntity = restTemplate.getForEntity(uri, String<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;</code></pre><h3 id="1-2-getForObject"><a href="#1-2-getForObject" class="headerlink" title="1.2 getForObject"></a>1.2 getForObject</h3><ul><li>请求方式基本同getForEntity，可以理解是对其的进一步封装。</li><li>它通过HttpMessageConverterExtractor对body进行转换，实现请求直接返回包装好的对象内容。</li></ul><pre><code class="hljs java">restTemplate.getForObject(url, Orange<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;</code></pre><ul><li>当body是一个Orange对象时，可直接包装。</li></ul><blockquote><p>当不需要关注响应body之外的内容时，建议使用该方式，可以少一个从response中获取body的步骤。</p></blockquote><h2 id="二、POST请求"><a href="#二、POST请求" class="headerlink" title="二、POST请求"></a>二、POST请求</h2><pre><code class="hljs java">postForEntity(String url, <span class="hljs-meta">@Nullable</span> Object request, Class&lt;T&gt; responseType, Object... uriVariables)</code></pre><ul><li>基本用法与get类似，这里需要注意的是新增加的request参数。</li><li>request可以是一个普通对象，也可以是一个HttpEntity对象。</li><li>request普通对象会被隐式转换成HttpEntity对象。</li><li>这个request不仅包含了body内容，还包含了header内容。</li><li>第四个参数uriVariables用于对url中参数绑定。</li></ul><h2 id="三、PUT请求"><a href="#三、PUT请求" class="headerlink" title="三、PUT请求"></a>三、PUT请求</h2><pre><code class="hljs java">put(String url, <span class="hljs-meta">@Nullable</span> Object request, Object... uriVariables)</code></pre><h2 id="四、DELETE请求"><a href="#四、DELETE请求" class="headerlink" title="四、DELETE请求"></a>四、DELETE请求</h2><pre><code class="hljs java">delete(String url, Object... uriVariables)</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;restTemplate详解&quot;&gt;&lt;a href=&quot;#restTemplate详解&quot; class=&quot;headerlink&quot; title=&quot;restTemplate详解&quot;&gt;&lt;/a&gt;restTemplate详解&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;该对象会使用ribbon的自动化
      
    
    </summary>
    
    
      <category term="springCloud" scheme="http://yoursite.com/categories/springCloud/"/>
    
    
      <category term="restTemplate" scheme="http://yoursite.com/tags/restTemplate/"/>
    
  </entry>
  
  <entry>
    <title>ribbon使用</title>
    <link href="http://yoursite.com/2020/06/08/ribbon%E4%BD%BF%E7%94%A8/"/>
    <id>http://yoursite.com/2020/06/08/ribbon%E4%BD%BF%E7%94%A8/</id>
    <published>2020-06-08T12:17:27.000Z</published>
    <updated>2020-06-14T03:09:14.571Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、什么是ribbon"><a href="#一、什么是ribbon" class="headerlink" title="一、什么是ribbon"></a>一、什么是ribbon</h2><ul><li>Spring cloud ribbon是一个基于HTTP和TCP的客户端负载均衡工具，它基于netflix ribbon实现。</li><li>将面向服务的rest模版请求自动转换成客户端负载均衡的服务调用。</li><li>是一个工具类框架，例如API网关的请求转发、Feign的底层都是基于ribbon的。</li></ul><h2 id="二、客户端负载均衡"><a href="#二、客户端负载均衡" class="headerlink" title="二、客户端负载均衡"></a>二、客户端负载均衡</h2><h3 id="1、基础理论"><a href="#1、基础理论" class="headerlink" title="1、基础理论"></a>1、基础理论</h3><ul><li>负载均衡是系统高可用、缓解网络压力、处理能力扩容的重要手段之一。</li></ul><h4 id="1-1-服务端负载均衡"><a href="#1-1-服务端负载均衡" class="headerlink" title="1.1 服务端负载均衡"></a>1.1 服务端负载均衡</h4><ul><li>我们通常所说的负载均衡都是服务端负载均衡，硬件层面如F5，软件层面如nginx。</li><li>硬件负载均衡的设备或者软件负载均衡的软件，都会维护一个可用的服务清单，并通过心跳的方式来剔除故障的服务端节点。</li><li>当客户端发送请求到负载均衡设备时，该设备按照一定算法（轮询、权重、流量等）从服务端清单中取出一个地址，然后转发请求。</li></ul><h4 id="1-2-客户端负载均衡"><a href="#1-2-客户端负载均衡" class="headerlink" title="1.2 客户端负载均衡"></a>1.2 客户端负载均衡</h4><ul><li>在客户端负载均衡中，所有的客户端节点都维护着自己的服务端清单，并通过心跳维护清单的健康性。</li><li>即客户端负载和服务端负载最大的不同点在于清单所储存的位置。</li></ul><h3 id="2、使用方式"><a href="#2、使用方式" class="headerlink" title="2、使用方式"></a>2、使用方式</h3><ul><li><p>服务提供者启动多个实例并注册到一个或多个相关联的注册中心</p></li><li><p>服务消费者直接调用被@LoadBalanced注解修饰的RestTemplate进行服务调用。</p></li></ul><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RestTemplateConfig</span> </span>&#123;    <span class="hljs-meta">@Bean</span>    <span class="hljs-meta">@LoadBalanced</span>    <span class="hljs-function">RestTemplate <span class="hljs-title">restTemplate</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> RestTemplate();    &#125;&#125;<span class="hljs-comment">// 根据服务名去访问，需要将restTemplate注解为@LoadBalanced才会生效</span><span class="hljs-keyword">private</span> String service = <span class="hljs-string">"http://MYCLOUD-PROVIDER"</span>;<span class="hljs-meta">@RequestMapping</span>(<span class="hljs-string">"/consumer/corps/&#123;id&#125;"</span>)<span class="hljs-function">Corp <span class="hljs-title">getCorp</span><span class="hljs-params">(@PathVariable(<span class="hljs-string">"id"</span>)</span> String id) </span>&#123;String url = service + <span class="hljs-string">"/corps/"</span>;<span class="hljs-keyword">return</span> restTemplate.getForObject(url + id, Corp<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;&#125;<span class="hljs-comment">// pom 中引入</span>&lt;dependency&gt;  &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;  &lt;artifactId&gt;spring-cloud-starter-netflix-ribbon&lt;/artifactId&gt;  &lt;version&gt;2.2.3.RELEASE&lt;/version&gt;&lt;/dependency&gt;</code></pre><h2 id="3、自动装配方式解读"><a href="#3、自动装配方式解读" class="headerlink" title="3、自动装配方式解读"></a>3、自动装配方式解读</h2><p>在springCloud实现的服务治理框架中，默认对ribbon自动化整合配置。如eureka中<code>spring.factories</code>:</p><pre><code class="hljs yaml"><span class="hljs-string">org.springframework.boot.autoconfigure.EnableAutoConfiguration=\</span><span class="hljs-string">···</span><span class="hljs-string">org.springframework.cloud.netflix.eureka.EurekaClientAutoConfiguration,\</span><span class="hljs-comment"># 自动整合ribbon相关配置，通过这个类来了解它的配置详情</span><span class="hljs-string">org.springframework.cloud.netflix.ribbon.eureka.RibbonEurekaAutoConfiguration,\</span><span class="hljs-string">org.springframework.cloud.netflix.eureka.EurekaDiscoveryClientConfiguration,\</span><span class="hljs-string">···</span></code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;一、什么是ribbon&quot;&gt;&lt;a href=&quot;#一、什么是ribbon&quot; class=&quot;headerlink&quot; title=&quot;一、什么是ribbon&quot;&gt;&lt;/a&gt;一、什么是ribbon&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;Spring cloud ribbon是一个基于HTTP
      
    
    </summary>
    
    
      <category term="springCloud" scheme="http://yoursite.com/categories/springCloud/"/>
    
    
      <category term="ribbon" scheme="http://yoursite.com/tags/ribbon/"/>
    
  </entry>
  
  <entry>
    <title>eureka使用</title>
    <link href="http://yoursite.com/2020/06/07/eureka%E4%BD%BF%E7%94%A8/"/>
    <id>http://yoursite.com/2020/06/07/eureka%E4%BD%BF%E7%94%A8/</id>
    <published>2020-06-07T15:20:49.000Z</published>
    <updated>2020-06-09T15:29:48.178Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、eureka是什么"><a href="#一、eureka是什么" class="headerlink" title="一、eureka是什么"></a>一、eureka是什么</h2><ul><li>服务治理可以说是微服务架构中核心的模块，它主要用来实现各个微服务实例之间的自动化注册与发现。</li></ul><p><strong>1、服务注册：</strong></p><p>每个服务单元将自己的主机号、版本号、通信协议等告知注册中心，注册中心维护服务清单，并通过心跳的方式监测清单中的服务是否可用，并剔除不可用的服务。</p><p><strong>2、服务发现：</strong></p><p>各服务单元通过服务名进行相互调用。</p><p><strong>3、eureka服务端：</strong></p><p>即服务注册中心，提供服务治理，即服务注册与发现的功能。</p><blockquote><p>若eureka以集群方式部署，当集群中有分片出现故障时，eureka进入自我保护模式。它允许再分片故障期间继续提供服务注册与发现，等故障恢复后，其他分片会把它们的状态再次同步回来。</p></blockquote><blockquote><p>不同服务端通过异步的方式相互复制各自的状态，这意味着在任意时间点，每个实例关于所有服务的状态是有细微差异的。也就是我们通常所说的AP原则。</p></blockquote><p><strong>4、eureka客户端</strong></p><p>向注册中心注册自身提供的服务，并周期性的发送心跳来更新服务租约。</p><p>将服务端已注册的服务信息缓存到本地，并周期性的刷新。</p><h2 id="二、单机配置方式"><a href="#二、单机配置方式" class="headerlink" title="二、单机配置方式"></a>二、单机配置方式</h2><h3 id="1、服务端"><a href="#1、服务端" class="headerlink" title="1、服务端"></a>1、服务端</h3><h4 id="1）pom中引入："><a href="#1）pom中引入：" class="headerlink" title="1）pom中引入："></a>1）pom中引入：</h4><pre><code class="hljs java">&lt;dependencies&gt;  &lt;dependency&gt;  &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;  &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-server&lt;/artifactId&gt;  &lt;version&gt;2.2.3.RELEASE&lt;/version&gt;  &lt;/dependency&gt;&lt;/dependencies&gt;</code></pre><h4 id="2）配置文件："><a href="#2）配置文件：" class="headerlink" title="2）配置文件："></a>2）配置文件：</h4><pre><code class="hljs yaml"><span class="hljs-attr">server:</span>  <span class="hljs-attr">port:</span> <span class="hljs-number">8003</span><span class="hljs-attr">eureka:</span>  <span class="hljs-attr">instance:</span>    <span class="hljs-attr">hostname:</span> <span class="hljs-string">localhost</span> <span class="hljs-comment"># eureka服务端的实例名字</span>  <span class="hljs-attr">client:</span>    <span class="hljs-attr">service-url:</span>      <span class="hljs-attr">defaultZone:</span> <span class="hljs-string">http://$&#123;eureka.instance.hostname&#125;:$&#123;server.port&#125;/eureka/</span>    <span class="hljs-attr">register-with-eureka:</span> <span class="hljs-literal">false</span> <span class="hljs-comment"># 是否向注册中心注册自己，默认true，server应设置为false</span>    <span class="hljs-attr">fetch-registry:</span> <span class="hljs-literal">false</span> <span class="hljs-comment"># 服务端本身就是维护服务实例的，所以并不需要去检索服务，默认true，server应设置为false</span></code></pre><h4 id="3）启动类"><a href="#3）启动类" class="headerlink" title="3）启动类:"></a>3）启动类:</h4><pre><code class="hljs java"><span class="hljs-meta">@SpringBootApplication</span><span class="hljs-meta">@EnableEurekaServer</span> <span class="hljs-comment">//开启Eureka服务端，接受其它微服务注册进来</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">EurekaServer8003</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        SpringApplication.run(EurekaServer8003<span class="hljs-class">.<span class="hljs-keyword">class</span>, <span class="hljs-title">args</span>)</span>;    &#125;&#125;</code></pre><h3 id="2、客户端"><a href="#2、客户端" class="headerlink" title="2、客户端"></a>2、客户端</h3><h4 id="1）pom中引入"><a href="#1）pom中引入" class="headerlink" title="1）pom中引入"></a>1）pom中引入</h4><pre><code class="hljs java">&lt;dependency&gt;&lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;&lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt;&lt;version&gt;2.2.3.RELEASE&lt;/version&gt;&lt;/dependency&gt;</code></pre><h4 id="2）配置文件"><a href="#2）配置文件" class="headerlink" title="2）配置文件"></a>2）配置文件</h4><pre><code class="hljs yaml"><span class="hljs-attr">spring:</span>  <span class="hljs-attr">application:</span>    <span class="hljs-attr">name:</span> <span class="hljs-string">mycloud-provider</span> <span class="hljs-comment"># eureka页面 application显示的名称。EurekaServer中服务名默认转成大写的。</span><span class="hljs-attr">eureka:</span>  <span class="hljs-attr">client:</span>    <span class="hljs-attr">service-url:</span>      <span class="hljs-attr">defaultZone:</span> <span class="hljs-string">http://localhost:8003/eureka/</span>  <span class="hljs-attr">instance:</span>    <span class="hljs-attr">instance-id:</span> <span class="hljs-string">$&#123;spring.application.name&#125;:$&#123;server.port&#125;</span> <span class="hljs-comment"># eureka页面status显示的内容</span></code></pre><h4 id="3）启动类-1"><a href="#3）启动类-1" class="headerlink" title="3）启动类"></a>3）启动类</h4><pre><code class="hljs java"><span class="hljs-meta">@SpringBootApplication</span><span class="hljs-comment">// 可不加该配置，Dalston之后的版本中（不含Dalston），只要开启了springboot的自动配置，服务注册发现功能就会启用</span><span class="hljs-comment">// 使用配置项`spring.cloud.service-registry.auto-registration.enabled=false`即可禁止服务注册发现功能。</span><span class="hljs-comment">// eureka.client.register-with-eureka: false 也可禁止服务注册功能。</span><span class="hljs-comment">// @EnableEurekaClient </span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CorpProvider8001</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        SpringApplication.run(CorpProvider8001<span class="hljs-class">.<span class="hljs-keyword">class</span>, <span class="hljs-title">args</span>)</span>;    &#125;&#125;</code></pre><blockquote><p>如果不想用主机名作为自定义注册中心的地址，也可以使用IP的形式。在配置文件中配置eureka.instance.prefer-ip-address=true，改值默认为false。</p></blockquote><h3 id="三、info信息完善"><a href="#三、info信息完善" class="headerlink" title="三、info信息完善"></a>三、info信息完善</h3><h4 id="1）引入依赖"><a href="#1）引入依赖" class="headerlink" title="1）引入依赖"></a>1）引入依赖</h4><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-actuator<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre><h4 id="2）yml中配置"><a href="#2）yml中配置" class="headerlink" title="2）yml中配置"></a>2）yml中配置</h4><pre><code class="hljs yaml"><span class="hljs-attr">info:</span> <span class="hljs-comment"># eureka页面status点击跳转监控页面 显示的内容</span>  <span class="hljs-attr">app.name:</span> <span class="hljs-string">$&#123;spring.application.name&#125;</span>  <span class="hljs-attr">company.name:</span> <span class="hljs-string">www.orange.com</span>  <span class="hljs-attr">build.artifactId:</span> <span class="hljs-string">mycloud-provider</span>  <span class="hljs-attr">build.version:</span> <span class="hljs-number">1.0</span></code></pre><h3 id="四、高可用集群配置方式"><a href="#四、高可用集群配置方式" class="headerlink" title="四、高可用集群配置方式"></a>四、高可用集群配置方式</h3><p>eureka server的高可用实际上就是将自己作为服务向其他注册中心注册自己。</p><h4 id="1）创建server1"><a href="#1）创建server1" class="headerlink" title="1）创建server1"></a>1）创建server1</h4><pre><code class="hljs yaml"><span class="hljs-attr">spring:</span>  <span class="hljs-attr">application:</span>    <span class="hljs-attr">name:</span> <span class="hljs-string">eureka-server</span><span class="hljs-attr">server:</span>  <span class="hljs-attr">port:</span> <span class="hljs-number">8003</span><span class="hljs-attr">eureka:</span>  <span class="hljs-attr">instance:</span>    <span class="hljs-attr">hostname:</span> <span class="hljs-string">server-1</span>  <span class="hljs-attr">client:</span>    <span class="hljs-attr">service-url:</span>      <span class="hljs-attr">defaultZone:</span> <span class="hljs-string">http://server-2:8004/eureka/</span></code></pre><h4 id="2-创建server2"><a href="#2-创建server2" class="headerlink" title="2) 创建server2"></a>2) 创建server2</h4><pre><code class="hljs yaml"><span class="hljs-attr">spring:</span>  <span class="hljs-attr">application:</span>    <span class="hljs-attr">name:</span> <span class="hljs-string">eureka-server</span><span class="hljs-attr">server:</span>  <span class="hljs-attr">port:</span> <span class="hljs-number">8004</span><span class="hljs-attr">eureka:</span>  <span class="hljs-attr">instance:</span>    <span class="hljs-attr">hostname:</span> <span class="hljs-string">server-2</span>  <span class="hljs-attr">client:</span>    <span class="hljs-attr">service-url:</span>      <span class="hljs-attr">defaultZone:</span> <span class="hljs-string">http://server-1:8003/eureka/</span></code></pre><h4 id="3）客户端配置"><a href="#3）客户端配置" class="headerlink" title="3）客户端配置"></a>3）客户端配置</h4><pre><code class="hljs yaml"><span class="hljs-attr">spring:</span>  <span class="hljs-attr">application:</span>    <span class="hljs-attr">name:</span> <span class="hljs-string">client</span><span class="hljs-attr">eureka:</span>  <span class="hljs-attr">client:</span>    <span class="hljs-attr">service-url:</span>      <span class="hljs-attr">defaultZone:</span> <span class="hljs-string">http://server-1:8003/eureka/,http://server-2:8004/eureka/</span> <span class="hljs-comment"># 分别向两个服务端注入</span></code></pre><h3 id="五、基础架构"><a href="#五、基础架构" class="headerlink" title="五、基础架构"></a>五、基础架构</h3><p>服务治理的3个核心要素：服务提供者、服务消费者、服务注册中心。</p><blockquote><p>很多时候，客户端既是服务提供者又是服务消费者</p></blockquote><h4 id="1）服务提供者"><a href="#1）服务提供者" class="headerlink" title="1）服务提供者"></a>1）服务提供者</h4><p><strong>服务注册：</strong></p><p>服务提供者在启动的时候，通过rest请求将自己注册到eureka server，同时附带一些元数据信息。eureka server将它储存在一个双层map中，第一层key是服务名，第二层key是实例名。</p><blockquote><p>在服务注册时，需确认一下eureka.client.register-with-eureka=true参数是否正确。改值默认为true，若设置为false将不会注册。</p></blockquote><p><strong>服务同步：</strong></p><p>服务提供者的服务信息可以通过注册中心集群中任意一个获取到。</p><p><strong>服务续约renew</strong></p><p>服务提供者维持一个心跳用来持续告诉eureka server，防止被server从服务列表清除。</p><pre><code class="hljs yaml"><span class="hljs-comment"># 续约任务的调用隔离时间，默认30s</span><span class="hljs-string">eureka.instance.lease-renewal-interval-in-seconds=30</span><span class="hljs-comment"># 服务失效时间，默认90s</span><span class="hljs-string">eureka.instance.lease-expiration-duration-in-seconds=30</span></code></pre><h4 id="2）服务消费者"><a href="#2）服务消费者" class="headerlink" title="2）服务消费者"></a>2）服务消费者</h4><p><strong>获取服务：</strong></p><p>客户端通过rest请求，访问获取服务列表，eureka server会维护一份只读的服务清单返回给客户端</p><pre><code class="hljs yaml"><span class="hljs-comment"># 是否需要获取服务列表，默认为true，客户端需要开启</span><span class="hljs-string">eureka.client.fetch-registry=true</span><span class="hljs-comment"># 缓存清单的更新时间，默认30s</span><span class="hljs-string">eureka.client.registry-fetch-interval-seconds=30</span></code></pre><p><strong>服务调用：</strong></p><p>服务消费者在获取到服务清单到，通过服务名根据一定的策略选择一个服务实例进行调用。</p><p><strong>服务下线：</strong></p><p>客户端正常关闭时，会触发一个rest请求给server，server接收到该请求后，将该服务状态置为下线DOWN，并把该下线事件传播出去。</p><h4 id="3）服务注册中心"><a href="#3）服务注册中心" class="headerlink" title="3）服务注册中心"></a>3）服务注册中心</h4><p><strong>失效剔除：</strong></p><p>server在启动的时候会创建一个定时任务，默认每隔60s将服务清单中超时（默认90s）没有续约的服务剔除。</p><p><strong>自我保护：</strong></p><p>默认在15分钟内，若心跳失败的比例低于85%，server会将当前的服务实例清单保护起来，让这些实例不会过期。但是假设保护期内服务异常，客户端拿到失效的实例，就会出现调用失败的情况，所以客户端需要有容错机制。如请求重试、断路器机制。</p><pre><code class="hljs ini"><span class="hljs-comment"># 关闭保护机制</span><span class="hljs-attr">eureka.server.enable-self-preservation</span>=<span class="hljs-literal">false</span></code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;一、eureka是什么&quot;&gt;&lt;a href=&quot;#一、eureka是什么&quot; class=&quot;headerlink&quot; title=&quot;一、eureka是什么&quot;&gt;&lt;/a&gt;一、eureka是什么&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;服务治理可以说是微服务架构中核心的模块，它主要用来实现各
      
    
    </summary>
    
    
      <category term="springCloud" scheme="http://yoursite.com/categories/springCloud/"/>
    
    
      <category term="eureka" scheme="http://yoursite.com/tags/eureka/"/>
    
  </entry>
  
  <entry>
    <title>【并发】3大JUC工具类</title>
    <link href="http://yoursite.com/2020/06/07/%E3%80%90%E5%B9%B6%E5%8F%91%E3%80%913%E5%A4%A7JUC%E5%B7%A5%E5%85%B7%E7%B1%BB/"/>
    <id>http://yoursite.com/2020/06/07/%E3%80%90%E5%B9%B6%E5%8F%91%E3%80%913%E5%A4%A7JUC%E5%B7%A5%E5%85%B7%E7%B1%BB/</id>
    <published>2020-06-07T07:40:08.000Z</published>
    <updated>2020-06-07T10:33:45.445Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、减法计数器countDownLatch"><a href="#一、减法计数器countDownLatch" class="headerlink" title="一、减法计数器countDownLatch"></a>一、减法计数器countDownLatch</h2><p>CountDownLatch用于监听某些初始化操作，等待初始化执行完毕，通知主线程继续工作，允许一个或者多个线程等待其他线程完成操作。</p><p>通俗的讲就是<strong>实现线程等待</strong>，主线程<code>countDown.await();</code>进行阻塞，其他线程<code>countDown.countDown();</code>进行计数器-1操作，当计数器归零后，主线程唤醒继续操作。</p><blockquote><p> 要实现线程等待还有一个方法就是jion方法。Join用于让当前执行线程等待“Join线程”执行结束，实现原理是，不停的检查Join线程是否存活，如果存活则让当前线程永远等待下去，如果Join线程终止，则调用this.notifyAll方法唤醒等待的线程。</p></blockquote><blockquote><p>CountDownLatch其实也是来做这件事的，而且比Join更强大，使用起来也很轻便。</p></blockquote><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyCountDownLatch</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        CountDownLatch countDownLatch = <span class="hljs-keyword">new</span> CountDownLatch(<span class="hljs-number">2</span>);<span class="hljs-comment">// 线程a在执行后，经过await进行阻塞，当其他线程将countDownLatch减为0后，a继续执行</span>        <span class="hljs-keyword">new</span> Thread(()-&gt;&#123;            System.out.println(Thread.currentThread().getName() + <span class="hljs-string">"开始执行"</span>);            <span class="hljs-keyword">try</span> &#123;                countDownLatch.await();            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;                e.printStackTrace();            &#125;            System.out.println(Thread.currentThread().getName() + <span class="hljs-string">"执行完成"</span>);        &#125;, <span class="hljs-string">"a"</span>).start();        <span class="hljs-keyword">new</span> Thread(()-&gt;&#123;            System.out.println(Thread.currentThread().getName() + <span class="hljs-string">"开始执行"</span>);            countDownLatch.countDown();            System.out.println(Thread.currentThread().getName() + <span class="hljs-string">"执行完成"</span>);        &#125;, <span class="hljs-string">"b"</span>).start();        <span class="hljs-keyword">new</span> Thread(()-&gt;&#123;            System.out.println(Thread.currentThread().getName() + <span class="hljs-string">"开始执行"</span>);            countDownLatch.countDown();            System.out.println(Thread.currentThread().getName() + <span class="hljs-string">"执行完成"</span>);        &#125;, <span class="hljs-string">"c"</span>).start();    &#125;&#125;</code></pre><blockquote><p>CountDownLatch是通过一个计数器来实现的，当我们在new 一个CountDownLatch对象的时候需要带入该计数器值，该值就表示了线程的数量。每当一个线程完成自己的任务后，计数器的值就会减1。当计数器的值变为0时，就表示所有的线程均已经完成了任务，然后就可以恢复等待的线程继续执行了。</p></blockquote><h2 id="二、加法计数器Cyclicbarrier"><a href="#二、加法计数器Cyclicbarrier" class="headerlink" title="二、加法计数器Cyclicbarrier"></a>二、加法计数器Cyclicbarrier</h2><p>Cyclicbarrier指的是可循环使用的屏障，主要是让一组线程到达一个屏障之后被阻塞，当最后一个线程到达时，屏障才会开门，所有被屏障拦截的线程才会继续干活。</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyCyclicBarrier</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<span class="hljs-comment">//        CyclicBarrier cyclicBarrier = new CyclicBarrier(5);</span>        <span class="hljs-comment">// 线程都ready后，会先执行该 barrierAction ，再执行各子线程的下一步任务</span>        CyclicBarrier cyclicBarrier = <span class="hljs-keyword">new</span> CyclicBarrier(<span class="hljs-number">5</span>, ()-&gt; System.out.println(<span class="hljs-string">"all is ready"</span>));        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++) &#123;            <span class="hljs-keyword">new</span> Thread(()-&gt;&#123;                System.out.println(Thread.currentThread().getName()+<span class="hljs-string">" is ready"</span>);<span class="hljs-comment">//                int numberWaiting = cyclicBarrier.getNumberWaiting();</span>                <span class="hljs-keyword">try</span> &#123;                    cyclicBarrier.await();                &#125; <span class="hljs-keyword">catch</span> (InterruptedException | BrokenBarrierException e) &#123;                    e.printStackTrace();                &#125;                System.out.println(Thread.currentThread().getName()+<span class="hljs-string">" is going"</span>);            &#125;, <span class="hljs-string">"线程"</span>+i).start();        &#125;        System.out.println(<span class="hljs-string">"this is main"</span>);    &#125;&#125;</code></pre><h3 id="1、区别"><a href="#1、区别" class="headerlink" title="1、区别"></a>1、区别</h3><ul><li>CountDownLatch的计数器只能使用一次。而CyclicBarrier的计数器可以使用reset() 方法重置。</li><li>CountDownLatch的作用是允许1或N个线程等待其他线程完成执行；而CyclicBarrier则是允许N个线程相互等待。</li><li>CountDownLatch的计数器无法被重置；CyclicBarrier的计数器可以被重置后使用，因此它被称为是循环的barrier。</li></ul><h3 id="2、使用场景"><a href="#2、使用场景" class="headerlink" title="2、使用场景"></a>2、使用场景</h3><ul><li>确保某个计算在其需要的所有的资源都被初始化之后才继续执行。</li><li>确保某个服务在其依赖的所有其他服务都已经启动之后才启动。</li><li>等待直到某个操作所有参与者都准备就绪再继续执行。</li></ul><p><a href="https://www.javazhiyin.com/14737.html" target="_blank" rel="noopener">J.U.C之并发工具类：CyclicBarrier</a></p><p><a href="https://www.javazhiyin.com/14681.html" target="_blank" rel="noopener">J.U.C之并发工具类：CountDownLatch</a></p><h2 id="三、信号量semaphore"><a href="#三、信号量semaphore" class="headerlink" title="三、信号量semaphore"></a>三、信号量semaphore</h2><ul><li>信号量维护了一个许可集，线程通过acquire()获得许可，在达到许可上限时，会阻塞其他acquire()的线程。已获得许可的线程进行 release() 后，被阻塞的线程才可获得许可。</li><li>信号量，一般用于限流，或者限制访问某些资源的线程数目。</li><li>Semaphore默认选择非公平锁。可通过构造函数传入true，声明为公平锁。</li><li>当信号量Semaphore = 1 时，它可以当作互斥锁使用。其中0、1就相当于它的状态，当=1时表示其他线程可以获取，当=0时，排他，即其他线程必须要等待。</li></ul><pre><code class="hljs livescript">public <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MySemaphore</span> &#123;</span>    public static <span class="hljs-literal">void</span> main(String[] args) &#123;        Semaphore semaphore = <span class="hljs-keyword">new</span> Semaphore(<span class="hljs-number">3</span>);        <span class="hljs-keyword">for</span> (int i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;            <span class="hljs-keyword">new</span> Thread<span class="hljs-function"><span class="hljs-params">(()-&gt;&#123;</span></span><span class="hljs-function"><span class="hljs-params">                <span class="hljs-keyword">try</span> &#123;</span></span><span class="hljs-function"><span class="hljs-params">                    semaphore.acquire();</span></span><span class="hljs-function"><span class="hljs-params">                    System.out.println(Thread.currentThread().getName()+<span class="hljs-string">"进行占位"</span>);</span></span><span class="hljs-function"><span class="hljs-params">                    TimeUnit.SECONDS.sleep(<span class="hljs-number">1</span>);</span></span><span class="hljs-function"><span class="hljs-params">                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;</span></span><span class="hljs-function"><span class="hljs-params">                    e.printStackTrace();</span></span><span class="hljs-function"><span class="hljs-params">                &#125; <span class="hljs-keyword">finally</span> &#123;</span></span><span class="hljs-function"><span class="hljs-params">                    semaphore.release();</span></span><span class="hljs-function"><span class="hljs-params">                    System.out.println(Thread.currentThread().getName()+<span class="hljs-string">"释放位置"</span>);</span></span><span class="hljs-function"><span class="hljs-params">                &#125;</span></span><span class="hljs-function"><span class="hljs-params">            &#125;, <span class="hljs-string">"thread-"</span>+i)</span>.<span class="hljs-title">start</span><span class="hljs-params">()</span>;</span><span class="hljs-function">        &#125;</span><span class="hljs-function"></span><span class="hljs-function">    &#125;</span><span class="hljs-function">&#125;</span></code></pre><p><a href="https://www.javazhiyin.com/14648.html" target="_blank" rel="noopener">J.U.C之并发工具类：Semaphore</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;一、减法计数器countDownLatch&quot;&gt;&lt;a href=&quot;#一、减法计数器countDownLatch&quot; class=&quot;headerlink&quot; title=&quot;一、减法计数器countDownLatch&quot;&gt;&lt;/a&gt;一、减法计数器countDownLatch&lt;/
      
    
    </summary>
    
    
      <category term="java" scheme="http://yoursite.com/categories/java/"/>
    
    
      <category term="thread" scheme="http://yoursite.com/tags/thread/"/>
    
  </entry>
  
  <entry>
    <title>【并发】阻塞队列（BlockingQueue）</title>
    <link href="http://yoursite.com/2020/06/07/%E3%80%90%E5%B9%B6%E5%8F%91%E3%80%91%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97/"/>
    <id>http://yoursite.com/2020/06/07/%E3%80%90%E5%B9%B6%E5%8F%91%E3%80%91%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97/</id>
    <published>2020-06-07T01:43:26.000Z</published>
    <updated>2020-06-07T07:41:03.947Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、什么是阻塞队列"><a href="#一、什么是阻塞队列" class="headerlink" title="一、什么是阻塞队列"></a>一、什么是阻塞队列</h2><p>阻塞队列是一种特殊的支持阻塞的插入和移除的特殊容器。</p><p>阻塞插入：</p><ul><li>当队列满时，向队列中插入元素的线程会被阻塞，直到队列中有元素被移除。</li><li>即队列不满时，才能插入元素，否则阻塞。</li></ul><p>阻塞移除：</p><ul><li>当队列为空时，从队列中移除数据的线程会被阻塞，直到队列中有新的元素被添加。</li><li>即队列不为空时，才能取出元素，否则阻塞。</li></ul><h2 id="二、常见方法"><a href="#二、常见方法" class="headerlink" title="二、常见方法"></a>二、常见方法</h2><table><thead><tr><th>方法</th><th>备注</th></tr></thead><tbody><tr><td>add/remove</td><td>增删元素，失败抛出异常</td></tr><tr><td>offer/poll</td><td>增删元素，可设置等待时间，失败或超时返回false</td></tr><tr><td>put/take</td><td>增删元素，一直等待</td></tr></tbody></table><h2 id="三、常见阻塞队列"><a href="#三、常见阻塞队列" class="headerlink" title="三、常见阻塞队列"></a>三、常见阻塞队列</h2><p><code>BlockingQueue</code>是一个接口，主要有下面7种实现类：</p><table><thead><tr><th>实现</th><th>备注</th></tr></thead><tbody><tr><td>ArrayBlockingQueue</td><td>基于数组的阻塞队列实现，在其内部，维护了一个定长数组，以便缓存队列中的数据对象；<br />其内部没实现读写分离，也就意味着生产和消费不能完全并行；<br />长度是需要自己定义的，可以指定先进先出或者先进后出，也被称为“有界队列”</td></tr><tr><td>LinkedBlockingQueue</td><td>基于链表的阻塞队列，其内部维持着一个数据缓冲队列（该队列由一个链表构成）；<br />LinkedBlockingQueue之所以能够高效的处理并发数据，是因为其内部实现采用分离锁（读写分离两个锁），从而实现生产者和消费者操作完全并发执行，也是一个“无界队列”</td></tr><tr><td>PriorityBlockingQueue</td><td>基于优先级的阻塞队列（优先级的判断通过构造函数传入的Compator（比较器）对象决定，也就是说传入队列的对象必须实现Comparable接口），<br />在实现PriorityBlockingQueue时，内部控制线程同步的锁采用的是公平锁，是一个“无界队列”<br />PriorityBlockingQueue调用take后需要重新排序，调一次重新排一次</td></tr><tr><td>DelayQueue</td><td>带有延迟时间的无界阻塞Queue，其中的元素只有当指定的延迟时间到了，才能够从队列中获取该元素。<br />DelayQueue中的元素必须实现Delayed接口，DelayQueue是一个没有大小限制的队列，<br />应用场景比较多，比如对缓存超时的数据进行移除，任务超时处理，空间连接的关闭等等</td></tr><tr><td>SynchronousQueue</td><td>不存储任何元素的队列，生产者产生的数据直接会被消费者获取并消费，<br />即每一个put操作必须等待一个take操作，否则不能继续添加元素，<br />或者可以理解为是只能存储一个元素的队列，存一个就满了，该元素必须被移除掉，才能继续添加</td></tr><tr><td>LinkedTransferQueue</td><td>一个由链表结构组成的无界阻塞传输队列，主要体现在LinkedTransferQueue多2个方法<br />transfer(E)：如果当前有消费者正在等待消费，则生产者直接把元素传输给消费者，如果当前没有消费者正在等待消费，则生产者将元素存放在队列的tail节点上，并等到该元素被消费才返回（采用自旋等待）；<br />tryTransfer(E,long,TimeUnit)：将元素立刻给消费者，如果没有消费者就等待指定时间。时间到时，如果还没有消费者则失败返回false；</td></tr><tr><td>LinkedBlockingDeque</td><td>由链表结构组成的双向阻塞队列，即可以从队列的两端插入和移出元素</td></tr></tbody></table><h2 id="四、阻塞队列的底层实现"><a href="#四、阻塞队列的底层实现" class="headerlink" title="四、阻塞队列的底层实现"></a>四、阻塞队列的底层实现</h2><p>阻塞队列的底层是<strong>等待通知机制</strong>来实现的：</p><p>当生产者往一个满队列中添加元素时，生产者会被阻塞；等消费者从该队列中消费了一个元素后，会通知阻塞的插入操作的生产者线程，可以继续执行添加操作。</p><p>当消费者从一个空队列中移除元素时，消费者会被阻塞；等生产者向队列中增加了一个元素后，会通知阻塞的移除操作的消费者线程，可以继续执行移除操作。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;一、什么是阻塞队列&quot;&gt;&lt;a href=&quot;#一、什么是阻塞队列&quot; class=&quot;headerlink&quot; title=&quot;一、什么是阻塞队列&quot;&gt;&lt;/a&gt;一、什么是阻塞队列&lt;/h2&gt;&lt;p&gt;阻塞队列是一种特殊的支持阻塞的插入和移除的特殊容器。&lt;/p&gt;
&lt;p&gt;阻塞插入：&lt;/p
      
    
    </summary>
    
    
      <category term="java" scheme="http://yoursite.com/categories/java/"/>
    
    
      <category term="thread blockingQueue" scheme="http://yoursite.com/tags/thread-blockingQueue/"/>
    
  </entry>
  
  <entry>
    <title>【并发】生产者消费者</title>
    <link href="http://yoursite.com/2020/06/05/%E3%80%90%E5%B9%B6%E5%8F%91%E3%80%91%E7%94%9F%E4%BA%A7%E8%80%85%E6%B6%88%E8%B4%B9%E8%80%85/"/>
    <id>http://yoursite.com/2020/06/05/%E3%80%90%E5%B9%B6%E5%8F%91%E3%80%91%E7%94%9F%E4%BA%A7%E8%80%85%E6%B6%88%E8%B4%B9%E8%80%85/</id>
    <published>2020-06-05T13:44:03.000Z</published>
    <updated>2020-06-07T07:40:54.141Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、生产者消费者"><a href="#一、生产者消费者" class="headerlink" title="一、生产者消费者"></a>一、生产者消费者</h2><p>生产者和消费者在同一时间段内共用同一段存储空间，生产者put数据，消费者take数据</p><p>阻塞队列就相当于一个缓冲区，平衡了生产者和消费者的处理能力，将他们解耦。</p><h2 id="二、四种实现生产者消费者模型"><a href="#二、四种实现生产者消费者模型" class="headerlink" title="二、四种实现生产者消费者模型"></a>二、四种实现生产者消费者模型</h2><h3 id="1、Object的wait-notify-方法"><a href="#1、Object的wait-notify-方法" class="headerlink" title="1、Object的wait() / notify()方法"></a>1、Object的wait() / notify()方法</h3><p>wait/notify 是Object的方法，因此我们可以给任何对象实现同步机制。</p><p>wait：当缓冲区满时，生产者/消费者放弃锁，让度cpu，使自己处于等待状态。</p><p>notify：当生产者/消费者 生产/消费 时，放弃锁，向其他线程发出可执行的通知，使自己处于等待状态。</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ProducerConsumer</span> </span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> CAPACITY = <span class="hljs-number">5</span>;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Queue&lt;Integer&gt; queue = <span class="hljs-keyword">new</span> LinkedList&lt;Integer&gt;();    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        <span class="hljs-comment">// 模拟生产者</span>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">3</span>; i++) &#123;            <span class="hljs-keyword">new</span> Thread(()-&gt; produce(),<span class="hljs-string">"procuder-"</span>+ i).start();        &#125;        <span class="hljs-comment">// 模拟消费者</span>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++) &#123;            <span class="hljs-keyword">new</span> Thread(()-&gt; consume(),<span class="hljs-string">"consumer-"</span>+ i).start();        &#125;        <span class="hljs-comment">// 主线程睡眠，便于看效果</span>        <span class="hljs-keyword">try</span> &#123;            TimeUnit.SECONDS.sleep(<span class="hljs-number">2</span>);        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;            e.printStackTrace();        &#125;        System.exit(<span class="hljs-number">0</span>);    &#125;    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">consume</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>) &#123;            <span class="hljs-keyword">synchronized</span> (queue) &#123;                <span class="hljs-keyword">while</span> (queue.isEmpty()) &#123;                    <span class="hljs-keyword">try</span> &#123;                        <span class="hljs-comment">// 空队列，则不能消费</span>                        System.out.println(Thread.currentThread().getName() + <span class="hljs-string">" 等待生产"</span>);                        queue.wait();                    &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;                        e.printStackTrace();                    &#125;                &#125;                <span class="hljs-comment">// 队列不为空，则正常消费</span>                Integer poll = queue.poll();                System.out.println(Thread.currentThread().getName() + <span class="hljs-string">" 消费了"</span> + poll);                queue.notifyAll();                <span class="hljs-comment">// 线程睡眠，便于看效果</span>                <span class="hljs-keyword">try</span> &#123;                    TimeUnit.MILLISECONDS.sleep(<span class="hljs-number">100</span>);                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;                    e.printStackTrace();                &#125;            &#125;        &#125;    &#125;    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">produce</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">int</span> k = <span class="hljs-number">0</span>;        <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>) &#123;            <span class="hljs-keyword">synchronized</span> (queue) &#123;                <span class="hljs-keyword">while</span> (queue.size() == CAPACITY) &#123;                    <span class="hljs-keyword">try</span> &#123;                        <span class="hljs-comment">// 满了则wait</span>                        System.out.println(Thread.currentThread().getName() + <span class="hljs-string">" 等待消费"</span>);                        queue.wait();                    &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;                        e.printStackTrace();                    &#125;                &#125;                <span class="hljs-comment">// 没满则往queue中添加元素</span>                System.out.println(Thread.currentThread().getName() + <span class="hljs-string">" 生产了"</span> + k);                queue.offer(k++);                queue.notifyAll();                <span class="hljs-comment">// 线程睡眠，便于看效果</span>                <span class="hljs-keyword">try</span> &#123;                    TimeUnit.MILLISECONDS.sleep(<span class="hljs-number">100</span>);                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;                    e.printStackTrace();                &#125;            &#125;        &#125;    &#125;&#125;</code></pre><blockquote><p>使用while进行size=queueSize、isEmpty的判断，使用if会造成虚假唤醒。</p></blockquote><h3 id="2、Lock中condition的await-signal-方法"><a href="#2、Lock中condition的await-signal-方法" class="headerlink" title="2、Lock中condition的await()/signal()方法"></a>2、Lock中condition的await()/signal()方法</h3><p>通过在lock对象上调用newCondition()，将变量和锁对象进行绑定，进而控制并发资源的安全。</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LockCondition</span> </span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> CAPACITY = <span class="hljs-number">5</span>;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> ReentrantLock lock = <span class="hljs-keyword">new</span> ReentrantLock();    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Condition fullCondition = lock.newCondition();    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Condition emptyCondition = lock.newCondition();    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Queue&lt;Integer&gt; queue = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">3</span>; i++) &#123;            <span class="hljs-keyword">new</span> Thread(() -&gt; produce(), <span class="hljs-string">"product-"</span> + i).start();        &#125;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">3</span>; i++) &#123;            <span class="hljs-keyword">new</span> Thread(() -&gt; consume(), <span class="hljs-string">"consumer-"</span> + i).start();        &#125;        <span class="hljs-comment">// 主线程睡眠，便于看效果</span>        <span class="hljs-keyword">try</span> &#123;            TimeUnit.SECONDS.sleep(<span class="hljs-number">2</span>);        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;            e.printStackTrace();        &#125;        System.exit(<span class="hljs-number">0</span>);    &#125;    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">consume</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>) &#123;            <span class="hljs-keyword">if</span> (lock.tryLock()) &#123;                <span class="hljs-keyword">try</span> &#123;                    <span class="hljs-keyword">while</span> (queue.isEmpty()) &#123;                        <span class="hljs-comment">// 队列为空，释放锁，通知生产者去生产</span>                        System.out.println(Thread.currentThread().getName() + <span class="hljs-string">" 队列为空，等待生产"</span>);                        emptyCondition.await();                    &#125;                    Integer poll = queue.poll();                    System.out.println(Thread.currentThread().getName() + <span class="hljs-string">" 消费了 "</span> + poll);                    <span class="hljs-comment">//唤醒其他所有生产者、消费者</span>                    fullCondition.signalAll();                    emptyCondition.signalAll();                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;                    e.printStackTrace();                &#125; <span class="hljs-keyword">finally</span> &#123;                    <span class="hljs-keyword">if</span> (lock.isHeldByCurrentThread()) &#123;                        lock.unlock();                    &#125;                &#125;            &#125;            <span class="hljs-comment">// 线程睡眠，便于看效果</span>            <span class="hljs-keyword">try</span> &#123;                TimeUnit.MILLISECONDS.sleep(<span class="hljs-keyword">new</span> Random().nextInt(<span class="hljs-number">100</span>));            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;                e.printStackTrace();            &#125;        &#125;    &#125;    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">produce</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>) &#123;            <span class="hljs-keyword">int</span> k = <span class="hljs-number">0</span>;            <span class="hljs-keyword">if</span> (lock.tryLock()) &#123;                <span class="hljs-keyword">try</span> &#123;                    <span class="hljs-keyword">while</span> (queue.size() == CAPACITY) &#123;                        <span class="hljs-comment">// 队列满了，释放锁，通知消费者去消费</span>                        System.out.println(Thread.currentThread().getName() + <span class="hljs-string">" 队列满了，等待消费"</span>);                        fullCondition.await();                    &#125;                    System.out.println(Thread.currentThread().getName() + <span class="hljs-string">" 生产了"</span> + k);                    queue.offer(k++);                    <span class="hljs-comment">//唤醒其他所有生产者、消费者</span>                    emptyCondition.signalAll();                    fullCondition.signalAll();                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;                    e.printStackTrace();                &#125; <span class="hljs-keyword">finally</span> &#123;                    <span class="hljs-keyword">if</span> (lock.isHeldByCurrentThread()) &#123;                        lock.unlock();                    &#125;                &#125;            &#125;            <span class="hljs-comment">// 线程睡眠，便于看效果</span>            <span class="hljs-keyword">try</span> &#123;                TimeUnit.MILLISECONDS.sleep(<span class="hljs-keyword">new</span> Random().nextInt(<span class="hljs-number">100</span>));            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;                e.printStackTrace();            &#125;        &#125;    &#125;&#125;</code></pre><blockquote><p><strong>await和signal需组合使用</strong>。在案例中阻塞时用了await，但是唤醒时用的notify，导致运行过程中一直报错<code>IllegalMonitorStateException</code></p></blockquote><h3 id="3、使用blockQueue阻塞队列方法"><a href="#3、使用blockQueue阻塞队列方法" class="headerlink" title="3、使用blockQueue阻塞队列方法"></a>3、使用blockQueue阻塞队列方法</h3><p>jdk对2方式的一种封装，可直接使用。</p><p>在juc下，有ArrayBlockingQueue、LinkedBlockingQueue、SynchronousQueue、PriorityBlockingQueue四种实现。</p><p>实现生产者-消费者模型使用 ArrayBlockingQueue或者 LinkedBlockingQueue即可。</p><pre><code class="hljs livescript">public <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyBlockingQueue</span> &#123;</span>    private static final int CAPICITY = <span class="hljs-number">3</span>;    private static final int MAX = <span class="hljs-number">30</span>;    private static final LinkedBlockingQueue&lt;Integer&gt; queue = <span class="hljs-keyword">new</span> LinkedBlockingQueue&lt;&gt;(CAPICITY);    public static <span class="hljs-literal">void</span> main(String[] args) &#123;        <span class="hljs-keyword">for</span> (int i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">3</span>; i++) &#123;            <span class="hljs-keyword">new</span> Thread<span class="hljs-function"><span class="hljs-params">(() -&gt; produce(), <span class="hljs-string">"product-"</span> + i)</span>.<span class="hljs-title">start</span><span class="hljs-params">()</span>;</span><span class="hljs-function">        &#125;</span><span class="hljs-function"></span><span class="hljs-function">        <span class="hljs-title">for</span> <span class="hljs-params">(int i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">3</span>; i++)</span> &#123;</span><span class="hljs-function">            <span class="hljs-title">new</span> <span class="hljs-title">Thread</span><span class="hljs-params">(() -&gt; consume(), <span class="hljs-string">"consumer-"</span> + i)</span>.<span class="hljs-title">start</span><span class="hljs-params">()</span>;</span><span class="hljs-function">        &#125;</span><span class="hljs-function"></span><span class="hljs-function">        // 主线程睡眠，便于看效果</span><span class="hljs-function">        <span class="hljs-title">try</span> &#123;</span><span class="hljs-function">            <span class="hljs-title">TimeUnit</span>.<span class="hljs-title">SECONDS</span>.<span class="hljs-title">sleep</span><span class="hljs-params">(<span class="hljs-number">2</span>)</span>;</span><span class="hljs-function">        &#125; <span class="hljs-title">catch</span> <span class="hljs-params">(InterruptedException e)</span> &#123;</span><span class="hljs-function">            <span class="hljs-title">e</span>.<span class="hljs-title">printStackTrace</span><span class="hljs-params">()</span>;</span><span class="hljs-function">        &#125;</span><span class="hljs-function"></span><span class="hljs-function">        <span class="hljs-title">System</span>.<span class="hljs-title">exit</span><span class="hljs-params">(<span class="hljs-number">0</span>)</span>;</span><span class="hljs-function">    &#125;</span><span class="hljs-function"></span><span class="hljs-function">    <span class="hljs-title">static</span> <span class="hljs-title">void</span> <span class="hljs-title">produce</span><span class="hljs-params">()</span> &#123;</span><span class="hljs-function">        <span class="hljs-title">int</span> <span class="hljs-title">k</span> = 0;</span><span class="hljs-function">        <span class="hljs-title">while</span> <span class="hljs-params">(k &lt; MAX)</span> &#123;</span><span class="hljs-function">            <span class="hljs-title">try</span> &#123;</span><span class="hljs-function">                <span class="hljs-title">System</span>.<span class="hljs-title">out</span>.<span class="hljs-title">println</span><span class="hljs-params">(Thread.currentThread().getName() + <span class="hljs-string">" 生产了"</span> + k)</span>;</span><span class="hljs-function">                <span class="hljs-title">queue</span>.<span class="hljs-title">put</span><span class="hljs-params">(k++)</span>;</span><span class="hljs-function">            &#125; <span class="hljs-title">catch</span> <span class="hljs-params">(InterruptedException e)</span> &#123;</span><span class="hljs-function">                <span class="hljs-title">e</span>.<span class="hljs-title">printStackTrace</span><span class="hljs-params">()</span>;</span><span class="hljs-function">            &#125;</span><span class="hljs-function"></span><span class="hljs-function">            // 线程睡眠，便于看效果</span><span class="hljs-function">            <span class="hljs-title">try</span> &#123;</span><span class="hljs-function">                <span class="hljs-title">TimeUnit</span>.<span class="hljs-title">MILLISECONDS</span>.<span class="hljs-title">sleep</span><span class="hljs-params">(<span class="hljs-keyword">new</span> Random().nextInt(<span class="hljs-number">100</span>))</span>;</span><span class="hljs-function">            &#125; <span class="hljs-title">catch</span> <span class="hljs-params">(InterruptedException e)</span> &#123;</span><span class="hljs-function">                <span class="hljs-title">e</span>.<span class="hljs-title">printStackTrace</span><span class="hljs-params">()</span>;</span><span class="hljs-function">            &#125;</span><span class="hljs-function">        &#125;</span><span class="hljs-function">    &#125;</span><span class="hljs-function"></span><span class="hljs-function">    <span class="hljs-title">static</span> <span class="hljs-title">void</span> <span class="hljs-title">consume</span><span class="hljs-params">()</span> &#123;</span><span class="hljs-function">        <span class="hljs-title">while</span> <span class="hljs-params">(<span class="hljs-literal">true</span>)</span> &#123;</span><span class="hljs-function">            <span class="hljs-title">try</span> &#123;</span><span class="hljs-function">                <span class="hljs-title">Integer</span> <span class="hljs-title">take</span> = <span class="hljs-title">queue</span>.<span class="hljs-title">take</span><span class="hljs-params">()</span>;</span><span class="hljs-function">                <span class="hljs-title">System</span>.<span class="hljs-title">out</span>.<span class="hljs-title">println</span><span class="hljs-params">(Thread.currentThread().getName() + <span class="hljs-string">"消费了"</span> + take)</span>;</span><span class="hljs-function">            &#125; <span class="hljs-title">catch</span> <span class="hljs-params">(InterruptedException e)</span> &#123;</span><span class="hljs-function">                <span class="hljs-title">e</span>.<span class="hljs-title">printStackTrace</span><span class="hljs-params">()</span>;</span><span class="hljs-function">            &#125;</span><span class="hljs-function"></span><span class="hljs-function">            // 线程睡眠，便于看效果</span><span class="hljs-function">            <span class="hljs-title">try</span> &#123;</span><span class="hljs-function">                <span class="hljs-title">TimeUnit</span>.<span class="hljs-title">MILLISECONDS</span>.<span class="hljs-title">sleep</span><span class="hljs-params">(<span class="hljs-keyword">new</span> Random().nextInt(<span class="hljs-number">100</span>))</span>;</span><span class="hljs-function">            &#125; <span class="hljs-title">catch</span> <span class="hljs-params">(InterruptedException e)</span> &#123;</span><span class="hljs-function">                <span class="hljs-title">e</span>.<span class="hljs-title">printStackTrace</span><span class="hljs-params">()</span>;</span><span class="hljs-function">            &#125;</span><span class="hljs-function"></span><span class="hljs-function">        &#125;</span><span class="hljs-function">    &#125;</span><span class="hljs-function"></span><span class="hljs-function">&#125;</span></code></pre><blockquote><p><code>put()</code>方法：类似于我们上面的生产者线程，容量达到最大时，自动阻塞。</p></blockquote><blockquote><p><code>take()</code>方法：类似于我们上面的消费者线程，容量为0时，自动阻塞。</p></blockquote><h2 id="4、PipedInputStream-PipedOutputStream"><a href="#4、PipedInputStream-PipedOutputStream" class="headerlink" title="4、PipedInputStream / PipedOutputStream"></a>4、<strong>PipedInputStream</strong> / PipedOutputStream</h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;一、生产者消费者&quot;&gt;&lt;a href=&quot;#一、生产者消费者&quot; class=&quot;headerlink&quot; title=&quot;一、生产者消费者&quot;&gt;&lt;/a&gt;一、生产者消费者&lt;/h2&gt;&lt;p&gt;生产者和消费者在同一时间段内共用同一段存储空间，生产者put数据，消费者take数据&lt;/p&gt;
      
    
    </summary>
    
    
      <category term="java" scheme="http://yoursite.com/categories/java/"/>
    
    
      <category term="thread queue" scheme="http://yoursite.com/tags/thread-queue/"/>
    
  </entry>
  
  <entry>
    <title>springboot自定义starter</title>
    <link href="http://yoursite.com/2020/06/03/springboot%E8%87%AA%E5%AE%9A%E4%B9%89starter/"/>
    <id>http://yoursite.com/2020/06/03/springboot%E8%87%AA%E5%AE%9A%E4%B9%89starter/</id>
    <published>2020-06-03T14:46:40.000Z</published>
    <updated>2020-06-03T15:02:44.539Z</updated>
    
    <content type="html"><![CDATA[<h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>按照约定，官方的为spring-boot-xxx-starter ，非官方的为 xxx-spring-boot-starter</p><h2 id="一、Spring-Boot-starter机制"><a href="#一、Spring-Boot-starter机制" class="headerlink" title="一、Spring Boot starter机制"></a>一、Spring Boot starter机制</h2><ul><li><p>Spring Boot中的starter是一种非常重要的机制，应用者只需要在maven中引入starter依赖，Spring Boot就能自动扫描到要加载的信息并启动相应的默认配置。</p></li><li><p>starter让我们摆脱了各种依赖库的处理，需要配置各种信息的困扰。</p></li><li><p>Spring Boot会自动通过classpath路径下的类发现需要的Bean，并注册进IOC容器。</p></li><li><p>Spring Boot提供了针对日常企业应用研发各种场景的spring-boot-starter依赖模块。所有这些依赖模块都遵循着约定成俗的默认配置，并允许我们调整这些配置，即遵循“约定大于配置”的理念。</p></li></ul><h2 id="二、自定义starter的条件"><a href="#二、自定义starter的条件" class="headerlink" title="二、自定义starter的条件"></a>二、自定义starter的条件</h2><p>如果想自定义Starter，首选需要实现自动化配置，而要实现自动化配置需要满足以下两个条件：</p><ol><li>能够自动配置项目所需要的配置信息，也就是自动加载依赖环境；</li><li>能够根据项目提供的信息自动生成Bean，并且注册到Bean管理容器中；</li></ol><h2 id="三、自定义starter代码部分"><a href="#三、自定义starter代码部分" class="headerlink" title="三、自定义starter代码部分"></a>三、自定义starter代码部分</h2><h3 id="1、pom文件"><a href="#1、pom文件" class="headerlink" title="1、pom文件"></a>1、pom文件</h3><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">project</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">"http://maven.apache.org/POM/4.0.0"</span></span><span class="hljs-tag">         <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">"http://www.w3.org/2001/XMLSchema-instance"</span></span><span class="hljs-tag">         <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">modelVersion</span>&gt;</span>4.0.0<span class="hljs-tag">&lt;/<span class="hljs-name">modelVersion</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.ztf<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>orange-spring-boot-starter<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.0-SNAPSHOT<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span>        <span class="hljs-comment">&lt;!-- https://mvnrepository.com/artifact/org.springframework.boot/spring-boot-autoconfigure --&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-autoconfigure<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.3.0.RELEASE<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-configuration-processor<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.3.0.RELEASE<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>            <span class="hljs-comment">&lt;!--该依赖只能在本项目中传递，不会传递到引用该项目的父项目中，父项目有需要需主动引用该依赖。--&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">optional</span>&gt;</span>true<span class="hljs-tag">&lt;/<span class="hljs-name">optional</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.projectlombok<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>lombok<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.18.6<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">optional</span>&gt;</span>true<span class="hljs-tag">&lt;/<span class="hljs-name">optional</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">project</span>&gt;</span></code></pre><h3 id="2、定义XxxProperties-属性配置类，"><a href="#2、定义XxxProperties-属性配置类，" class="headerlink" title="2、定义XxxProperties 属性配置类，"></a>2、定义XxxProperties 属性配置类，</h3><ul><li>设置属性前缀，用于在application.properties中配置。</li></ul><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.ztf;<span class="hljs-keyword">import</span> lombok.Data;<span class="hljs-keyword">import</span> org.springframework.boot.context.properties.ConfigurationProperties;<span class="hljs-meta">@ConfigurationProperties</span>(prefix = <span class="hljs-string">"local.orange"</span>)<span class="hljs-meta">@Data</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyProperties</span> </span>&#123;    <span class="hljs-keyword">private</span> String id;    <span class="hljs-keyword">private</span> String name;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> age;&#125;</code></pre><h3 id="3、定义XxxService逻辑操作类"><a href="#3、定义XxxService逻辑操作类" class="headerlink" title="3、定义XxxService逻辑操作类"></a>3、定义XxxService逻辑操作类</h3><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.ztf;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyService</span> </span>&#123;    MyProperties myProperties;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setMyProperties</span><span class="hljs-params">(MyProperties myProperties)</span> </span>&#123;        <span class="hljs-keyword">this</span>.myProperties = myProperties;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">MyService</span><span class="hljs-params">(MyProperties myProperties)</span> </span>&#123;        <span class="hljs-keyword">this</span>.myProperties = myProperties;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">helloWorld</span><span class="hljs-params">()</span> </span>&#123;        System.out.println(<span class="hljs-string">"hi, 我叫: "</span> + myProperties.getName() +                <span class="hljs-string">", id:"</span> + myProperties.getId() + <span class="hljs-string">"岁"</span>                + <span class="hljs-string">", 年龄: "</span> + myProperties.getAge());    &#125;&#125;</code></pre><h3 id="4、定义XxxAutoConfiguration自动配置类"><a href="#4、定义XxxAutoConfiguration自动配置类" class="headerlink" title="4、定义XxxAutoConfiguration自动配置类"></a>4、定义XxxAutoConfiguration自动配置类</h3><ul><li>用于完成Bean创建等工作。</li></ul><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.ztf;<span class="hljs-keyword">import</span> org.springframework.beans.factory.annotation.Autowired;<span class="hljs-keyword">import</span> org.springframework.boot.autoconfigure.condition.ConditionalOnClass;<span class="hljs-keyword">import</span> org.springframework.boot.autoconfigure.condition.ConditionalOnMissingBean;<span class="hljs-keyword">import</span> org.springframework.boot.autoconfigure.condition.ConditionalOnProperty;<span class="hljs-keyword">import</span> org.springframework.boot.context.properties.EnableConfigurationProperties;<span class="hljs-keyword">import</span> org.springframework.context.annotation.Bean;<span class="hljs-keyword">import</span> org.springframework.context.annotation.Configuration;<span class="hljs-meta">@Configuration</span><span class="hljs-meta">@EnableConfigurationProperties</span>(MyProperties<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span><span class="hljs-class">@<span class="hljs-title">ConditionalOnClass</span>(<span class="hljs-title">MyService</span>.<span class="hljs-title">class</span>)</span><span class="hljs-class">@<span class="hljs-title">ConditionalOnProperty</span>(<span class="hljs-title">prefix</span> </span>= <span class="hljs-string">"local.orange"</span>, value = <span class="hljs-string">"enabled"</span>, matchIfMissing = <span class="hljs-keyword">true</span>)<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyServiceAutoConfiguration</span> </span>&#123;    <span class="hljs-meta">@Autowired</span>    MyProperties myProperties;    <span class="hljs-meta">@Bean</span>    <span class="hljs-meta">@ConditionalOnMissingBean</span>(MyService<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span><span class="hljs-class">    <span class="hljs-title">public</span> <span class="hljs-title">MyService</span> <span class="hljs-title">myService</span>() </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> MyService(myProperties);    &#125;&#125;</code></pre><h3 id="5、在spring-factories中声明"><a href="#5、在spring-factories中声明" class="headerlink" title="5、在spring.factories中声明"></a>5、在spring.factories中声明</h3><ul><li><p>在resources下创建目录META-INF，在 META-INF 目录下创建 spring.factories，在SpringBoot启动时会根据此文件来加载项目的自动化配置类。</p></li><li><p>spring.factories内容如下：</p></li></ul><pre><code class="hljs java">org.springframework.boot.autoconfigure.EnableAutoConfiguration=com.ztf.MyServiceAutoConfiguration</code></pre><h2 id="四、自定义starter使用"><a href="#四、自定义starter使用" class="headerlink" title="四、自定义starter使用"></a>四、自定义starter使用</h2><h3 id="1、pom中引用自定义starter的jar"><a href="#1、pom中引用自定义starter的jar" class="headerlink" title="1、pom中引用自定义starter的jar"></a>1、pom中引用自定义starter的jar</h3><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.ztf<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>orange-spring-boot-starter<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.0-SNAPSHOT<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre><h3 id="2、yml配置文件中声明参数"><a href="#2、yml配置文件中声明参数" class="headerlink" title="2、yml配置文件中声明参数"></a>2、yml配置文件中声明参数</h3><pre><code class="hljs yaml"><span class="hljs-comment">## 自定义的一个starter</span><span class="hljs-attr">local:</span>  <span class="hljs-attr">orange:</span>    <span class="hljs-attr">id:</span> <span class="hljs-number">007</span>    <span class="hljs-attr">name:</span> <span class="hljs-string">myorange</span>    <span class="hljs-attr">age:</span> <span class="hljs-number">18</span></code></pre><h3 id="3、项目中使用"><a href="#3、项目中使用" class="headerlink" title="3、项目中使用"></a>3、项目中使用</h3><pre><code class="hljs java"><span class="hljs-meta">@Autowired</span>MyService myService;<span class="hljs-meta">@GetMapping</span>(<span class="hljs-string">"/test"</span>)<span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">testMyStarter</span><span class="hljs-params">()</span> </span>&#123;  myService.helloWorld();  <span class="hljs-keyword">return</span> <span class="hljs-string">"ok"</span>;&#125;</code></pre><h2 id="六、总结"><a href="#六、总结" class="headerlink" title="六、总结"></a>六、总结</h2><ol><li>Spring Boot在启动时扫描项目所依赖的JAR包，寻找包含spring.factories文件的JAR包，</li><li>然后读取spring.factories文件获取配置的自动配置类AutoConfiguration，</li><li>然后将自动配置类下满足条件(@ConditionalOnXxx)的@Bean放入到Spring容器中(Spring Context)</li><li>这样使用者就可以直接用来注入，因为该类已经在容器中了</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;写在前面&quot;&gt;&lt;a href=&quot;#写在前面&quot; class=&quot;headerlink&quot; title=&quot;写在前面&quot;&gt;&lt;/a&gt;写在前面&lt;/h2&gt;&lt;p&gt;按照约定，官方的为spring-boot-xxx-starter ，非官方的为 xxx-spring-boot-starte
      
    
    </summary>
    
    
      <category term="java" scheme="http://yoursite.com/categories/java/"/>
    
    
      <category term="springboot" scheme="http://yoursite.com/tags/springboot/"/>
    
  </entry>
  
  <entry>
    <title>mac环境变量配置</title>
    <link href="http://yoursite.com/2020/06/03/mac%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E9%85%8D%E7%BD%AE/"/>
    <id>http://yoursite.com/2020/06/03/mac%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E9%85%8D%E7%BD%AE/</id>
    <published>2020-06-03T13:10:43.000Z</published>
    <updated>2020-06-03T13:13:25.334Z</updated>
    
    <content type="html"><![CDATA[<h2 id="gradle环境变量配置"><a href="#gradle环境变量配置" class="headerlink" title="gradle环境变量配置"></a>gradle环境变量配置</h2><pre><code class="hljs xml">vi ~/.bash_profile# 增加gradle环境变量，如下：export GRADLE_HOME=/Users/orange/Documents/gradle-6.4export PATH=$PATH:$GRADLE_HOME/bin# 刷新source ~/.bash_profile# 查看版本gradle -version</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;gradle环境变量配置&quot;&gt;&lt;a href=&quot;#gradle环境变量配置&quot; class=&quot;headerlink&quot; title=&quot;gradle环境变量配置&quot;&gt;&lt;/a&gt;gradle环境变量配置&lt;/h2&gt;&lt;pre&gt;&lt;code class=&quot;hljs xml&quot;&gt;vi ~/
      
    
    </summary>
    
    
      <category term="idea" scheme="http://yoursite.com/categories/idea/"/>
    
    
      <category term="环境变量" scheme="http://yoursite.com/tags/%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/"/>
    
  </entry>
  
  <entry>
    <title>mybatis-generator</title>
    <link href="http://yoursite.com/2020/06/02/mybatis-generator/"/>
    <id>http://yoursite.com/2020/06/02/mybatis-generator/</id>
    <published>2020-06-02T13:36:54.000Z</published>
    <updated>2020-06-03T12:18:35.200Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-作用"><a href="#1-作用" class="headerlink" title="1.作用"></a>1.作用</h2><p>用来自动生成MyBatis的 mapper、dao、entity </p><h2 id="2-使用"><a href="#2-使用" class="headerlink" title="2.使用"></a>2.使用</h2><p>MyBatis Generator的使用方式有4种：</p><ul><li>命令行生成</li><li>Maven方式生成</li><li>使用Ant任务生成</li><li>使用Java代码生成</li></ul><p>其中推荐使用Maven方式进行代码生成，因为集成和使用比较简单。</p><h2 id="3-代码自动生成配置"><a href="#3-代码自动生成配置" class="headerlink" title="3.代码自动生成配置"></a>3.代码自动生成配置</h2><h3 id="Step1：配置pom中plugin依赖"><a href="#Step1：配置pom中plugin依赖" class="headerlink" title="Step1：配置pom中plugin依赖"></a>Step1：配置pom中plugin依赖</h3><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">plugin</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.mybatis.generator<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mybatis-generator-maven-plugin<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.4.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">executions</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">execution</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">id</span>&gt;</span>Generate MyBatis Artifacts<span class="hljs-tag">&lt;/<span class="hljs-name">id</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">phase</span>&gt;</span>package<span class="hljs-tag">&lt;/<span class="hljs-name">phase</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">goals</span>&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">goal</span>&gt;</span>generate<span class="hljs-tag">&lt;/<span class="hljs-name">goal</span>&gt;</span>            <span class="hljs-tag">&lt;/<span class="hljs-name">goals</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">execution</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">executions</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">configuration</span>&gt;</span>        <span class="hljs-comment">&lt;!--允许移动生成的文件 --&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">verbose</span>&gt;</span>true<span class="hljs-tag">&lt;/<span class="hljs-name">verbose</span>&gt;</span>        <span class="hljs-comment">&lt;!-- 是否覆盖 --&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">overwrite</span>&gt;</span>true<span class="hljs-tag">&lt;/<span class="hljs-name">overwrite</span>&gt;</span>        <span class="hljs-comment">&lt;!-- 自动生成的配置 --&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">configurationFile</span>&gt;</span>src/main/resources/generatorConfig.xml<span class="hljs-tag">&lt;/<span class="hljs-name">configurationFile</span>&gt;</span>        <span class="hljs-comment">&lt;!--将当前pom的依赖项添加到生成器的类路径中--&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">includeCompileDependencies</span>&gt;</span>true<span class="hljs-tag">&lt;/<span class="hljs-name">includeCompileDependencies</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">configuration</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">plugin</span>&gt;</span></code></pre><h3 id="Step2：配置generatorConfig-xml文件"><a href="#Step2：配置generatorConfig-xml文件" class="headerlink" title="Step2：配置generatorConfig.xml文件"></a>Step2：配置generatorConfig.xml文件</h3><pre><code class="hljs dust"><span class="xml"><span class="hljs-meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><span class="xml"><span class="hljs-comment">&lt;!--mybatis的代码生成器相关配置--&gt;</span></span><span class="xml"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">generatorConfiguration</span></span></span><span class="xml">        PUBLIC "-//mybatis.org//DTD MyBatis Generator Configuration 1.0//EN"</span><span class="xml">        "http://mybatis.org/dtd/mybatis-generator-config_1_0.dtd"&gt;</span><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">generatorConfiguration</span>&gt;</span></span><span class="xml">    <span class="hljs-comment">&lt;!-- 引入配置文件 --&gt;</span></span><span class="xml">    <span class="hljs-tag">&lt;<span class="hljs-name">properties</span> <span class="hljs-attr">resource</span>=<span class="hljs-string">"application.yml"</span>/&gt;</span>   </span><span class="xml">    <span class="hljs-tag">&lt;<span class="hljs-name">context</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"Mysql"</span> <span class="hljs-attr">targetRuntime</span>=<span class="hljs-string">"MyBatis3Simple"</span> <span class="hljs-attr">defaultModelType</span>=<span class="hljs-string">"flat"</span>&gt;</span></span><span class="xml">        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"autoDelimitKeywords"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"true"</span> /&gt;</span></span><span class="xml">        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"beginningDelimiter"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"`"</span> /&gt;</span></span><span class="xml">        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"endingDelimiter"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"`"</span> /&gt;</span></span><span class="xml">        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"javaFileEncoding"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"utf-8"</span> /&gt;</span></span><span class="xml">        <span class="hljs-tag">&lt;<span class="hljs-name">plugin</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"org.mybatis.generator.plugins.SerializablePlugin"</span> /&gt;</span></span><span class="xml">        <span class="hljs-tag">&lt;<span class="hljs-name">commentGenerator</span> &gt;</span></span><span class="xml">            <span class="hljs-comment">&lt;!-- 不生成注释 --&gt;</span></span><span class="xml">            <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"suppressAllComments"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"true"</span>/&gt;</span></span><span class="xml">            <span class="hljs-comment">&lt;!-- 不生成注释代时间戳--&gt;</span></span><span class="xml">            <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"suppressDate"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"true"</span> /&gt;</span></span><span class="xml">        <span class="hljs-tag">&lt;/<span class="hljs-name">commentGenerator</span>&gt;</span></span><span class="xml">        <span class="hljs-comment">&lt;!--数据库链接地址账号密码--&gt;</span></span><span class="xml">        <span class="hljs-comment">&lt;!--&lt;jdbcConnection driverClass="$</span></span><span class="hljs-template-variable">&#123;spring.datasource.driver-class-name&#125;</span><span class="xml"><span class="hljs-comment">"--&gt;</span></span><span class="xml">                        <span class="hljs-comment">&lt;!--connectionURL="$</span></span><span class="hljs-template-variable">&#123;spring.datasource.url&#125;</span><span class="xml"><span class="hljs-comment">"--&gt;</span></span><span class="xml">                        <span class="hljs-comment">&lt;!--userId="$</span></span><span class="hljs-template-variable">&#123;spring.datasource.username&#125;</span><span class="xml"><span class="hljs-comment">"--&gt;</span></span><span class="xml">                        <span class="hljs-comment">&lt;!--password="$</span></span><span class="hljs-template-variable">&#123;spring.datasource.password&#125;</span><span class="xml"><span class="hljs-comment">"&gt;--&gt;</span></span><span class="xml">        <span class="hljs-comment">&lt;!--&lt;/jdbcConnection&gt;--&gt;</span></span><span class="xml">        <span class="hljs-tag">&lt;<span class="hljs-name">jdbcConnection</span> <span class="hljs-attr">driverClass</span>=<span class="hljs-string">"com.mysql.cj.jdbc.Driver"</span></span></span><span class="xml">            connectionURL="jdbc:mysql://localhost:3306/display"</span><span class="xml">            userId="root"</span><span class="xml">            password="P@ssw0rd"&gt;</span><span class="xml">        <span class="hljs-tag">&lt;/<span class="hljs-name">jdbcConnection</span>&gt;</span></span><span class="xml">        <span class="hljs-comment">&lt;!-- 类型转换 --&gt;</span></span><span class="xml">        <span class="hljs-tag">&lt;<span class="hljs-name">javaTypeResolver</span>&gt;</span></span><span class="xml">            <span class="hljs-comment">&lt;!-- 是否使用bigDecimal， false可自动转化以下类型（Long, Integer, Short, etc.） --&gt;</span></span><span class="xml">            <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"forceBigDecimals"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"false"</span>/&gt;</span></span><span class="xml">        <span class="hljs-tag">&lt;/<span class="hljs-name">javaTypeResolver</span>&gt;</span></span><span class="xml">        <span class="hljs-comment">&lt;!--生成Model类存放位置--&gt;</span></span><span class="xml">        <span class="hljs-tag">&lt;<span class="hljs-name">javaModelGenerator</span> <span class="hljs-attr">targetPackage</span>=<span class="hljs-string">"com.ztf.mybatisplus.bean"</span> <span class="hljs-attr">targetProject</span>=<span class="hljs-string">"src/main/java"</span>&gt;</span></span><span class="xml">            <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"enableSubPackages"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"true"</span>/&gt;</span></span><span class="xml">            <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"trimStrings"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"true"</span>/&gt;</span></span><span class="xml">        <span class="hljs-tag">&lt;/<span class="hljs-name">javaModelGenerator</span>&gt;</span></span><span class="xml">        <span class="hljs-comment">&lt;!-- 生成mapxml文件 --&gt;</span></span><span class="xml">        <span class="hljs-tag">&lt;<span class="hljs-name">sqlMapGenerator</span> <span class="hljs-attr">targetPackage</span>=<span class="hljs-string">"mapper"</span> <span class="hljs-attr">targetProject</span>=<span class="hljs-string">"src/main/resources/mybatis"</span> &gt;</span></span><span class="xml">            <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"enableSubPackages"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"false"</span> /&gt;</span></span><span class="xml">        <span class="hljs-tag">&lt;/<span class="hljs-name">sqlMapGenerator</span>&gt;</span></span><span class="xml">        <span class="hljs-comment">&lt;!-- 生成mapper java文件 --&gt;</span></span><span class="xml">        <span class="hljs-tag">&lt;<span class="hljs-name">javaClientGenerator</span> <span class="hljs-attr">targetPackage</span>=<span class="hljs-string">"com.ztf.mybatisplus.dao"</span> <span class="hljs-attr">targetProject</span>=<span class="hljs-string">"src/main/java"</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"XMLMAPPER"</span> &gt;</span></span><span class="xml">            <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"enableSubPackages"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"false"</span> /&gt;</span></span><span class="xml">        <span class="hljs-tag">&lt;/<span class="hljs-name">javaClientGenerator</span>&gt;</span></span><span class="xml"><span class="hljs-comment">&lt;!--具体解析的表，建议配置domainObjectName属性，避免带上表前缀T_--&gt;</span></span><span class="xml">        <span class="hljs-tag">&lt;<span class="hljs-name">table</span> <span class="hljs-attr">tableName</span>=<span class="hljs-string">"t_corp"</span> <span class="hljs-attr">enableCountByExample</span>=<span class="hljs-string">"true"</span> <span class="hljs-attr">domainObjectName</span>=<span class="hljs-string">"Corp"</span></span></span><span class="xml">               enableUpdateByExample="true" enableDeleteByExample="true"</span><span class="xml">               enableSelectByExample="true" selectByExampleQueryId="true"&gt;</span><span class="xml">            <span class="hljs-comment">&lt;!--&lt;generatedKey column="id" sqlStatement="Mysql" identity="true" /&gt;--&gt;</span></span><span class="xml">        <span class="hljs-tag">&lt;/<span class="hljs-name">table</span>&gt;</span></span><span class="xml">        <span class="hljs-comment">&lt;!--&lt;table tableName="user_log" enableCountByExample="true" --&gt;</span></span><span class="xml">               <span class="hljs-comment">&lt;!--enableUpdateByExample="true" enableDeleteByExample="true" --&gt;</span></span><span class="xml">               <span class="hljs-comment">&lt;!--enableSelectByExample="true" selectByExampleQueryId="true"&gt;--&gt;</span></span><span class="xml">            <span class="hljs-comment">&lt;!--&lt;generatedKey column="id" sqlStatement="Mysql" identity="true" /&gt;--&gt;</span></span><span class="xml">        <span class="hljs-comment">&lt;!--&lt;/table&gt;--&gt;</span></span><span class="xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">context</span>&gt;</span></span><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">generatorConfiguration</span>&gt;</span></span></code></pre><h2 id="4-注意事项"><a href="#4-注意事项" class="headerlink" title="4.注意事项"></a>4.注意事项</h2><ul><li>MyBatis Generator 只会覆盖旧的 po、dao、而 mapper.xml 不会覆盖，而是追加，这样做的目的是防止用户自己写的 sql 语句一不小心都被 MyBatis Generator 给覆盖了</li></ul><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- 是否覆盖 --&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">overwrite</span>&gt;</span>true<span class="hljs-tag">&lt;/<span class="hljs-name">overwrite</span>&gt;</span></code></pre><ul><li>一般配置了 <strong>includeCompileDependencies</strong> 后就不需要配置其他依赖了，因为 <strong>includeCompileDependencies</strong> 会将当前 pom 的 <strong>dependencies</strong> 中所有 <strong>Compile</strong> 期的依赖全部添加到生成器的类路径中。</li></ul><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--将当前pom的依赖项添加到生成器的类路径中--&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">includeCompileDependencies</span>&gt;</span>true<span class="hljs-tag">&lt;/<span class="hljs-name">includeCompileDependencies</span>&gt;</span></code></pre><ul><li>数据库文件yml方式加载不进来配置，写成<code>application.properties&quot;</code>方式就可以</li></ul><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- 引入配置文件 --&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">properties</span> <span class="hljs-attr">resource</span>=<span class="hljs-string">"application-dev.properties"</span>/&gt;</span></code></pre><ul><li>context属性</li></ul><pre><code class="hljs xml">id : 随便填，保证多个 context id 不重复就行defaultModelType ： 可以不填，默认值 conditional，flat表示一张表对应一个potargetRuntime ：可以不填，默认值 MyBatis3，常用的还有 MyBatis3Simple。MyBatis3Simple生成的 dao 和 mapper.xml 内容较少，但也包含了最常用的。</code></pre><ul><li>context的子元素要求有序</li></ul><pre><code class="hljs angelscript"><span class="hljs-number">1.</span> **<span class="hljs-keyword">property</span>** (<span class="hljs-number">0.</span>.N)<span class="hljs-number">2.</span> **plugin** (<span class="hljs-number">0.</span>.N)<span class="hljs-number">3.</span> **commentGenerator** (<span class="hljs-number">0</span> <span class="hljs-keyword">or</span> <span class="hljs-number">1</span>)<span class="hljs-number">4.</span> **jdbcConnection** (需要connectionFactory 或 jdbcConnection)<span class="hljs-number">5.</span> **javaTypeResolver** (<span class="hljs-number">0</span> <span class="hljs-keyword">or</span> <span class="hljs-number">1</span>)<span class="hljs-number">6.</span> **javaModelGenerator** (至少<span class="hljs-number">1</span>个)<span class="hljs-number">7.</span> **sqlMapGenerator** (<span class="hljs-number">0</span> <span class="hljs-keyword">or</span> <span class="hljs-number">1</span>)<span class="hljs-number">8.</span> **javaClientGenerator** (<span class="hljs-number">0</span> <span class="hljs-keyword">or</span> <span class="hljs-number">1</span>)<span class="hljs-number">9.</span> **table** (<span class="hljs-number">1.</span>.N)</code></pre><ul><li>commentGenerator 默认生成注释和时间戳，可显式的声明某一项不生成。<strong>建议全部显式不生成。</strong></li></ul><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">commentGenerator</span>&gt;</span>    <span class="hljs-comment">&lt;!-- 不希望生成的注释中包含时间戳 --&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"suppressDate"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"true"</span>/&gt;</span>    <span class="hljs-comment">&lt;!-- 不希望生成的注释中包含注释 --&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"suppressAllComments"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"true"</span>/&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">commentGenerator</span>&gt;</span></code></pre><ul><li><code>type=&quot;XMLMAPPER&quot;</code> 会将接口的实现放在 mapper.xml中，也推荐这样配置。也可以设置  <code>type=&quot;ANNOTATEDMAPPER&quot;</code>，接口的实现通过注解写在接口上面</li><li>一个 table 对应一张表，如果想同时生成多张表，需要配置多个 table</li><li><strong>domainObjectName</strong> 不配置时，它会按照帕斯卡命名法将表名转换成类名，建议配置该属性，避免带上表前缀T_</li></ul><pre><code class="hljs routeros">&lt;domainObjectRenamingRule <span class="hljs-attribute">searchString</span>=<span class="hljs-string">"^T"</span> <span class="hljs-attribute">replaceString</span>=<span class="hljs-string">""</span> /&gt;</code></pre><ul><li>表字段也会默认带上<code>c_</code>、<code>d_</code>，可设置去掉</li></ul><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- 这个意思就是匹配，开头的任意个非下划线(_)的字符，也就是这种如：c_，d_ 等等 --&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">columnRenamingRule</span> <span class="hljs-attr">searchString</span>=<span class="hljs-string">"^[^_]+"</span> <span class="hljs-attr">replaceString</span>=<span class="hljs-string">""</span>/&gt;</span>  <span class="hljs-comment">&lt;!-- 也可如下只去掉c_--&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">columnRenamingRule</span> <span class="hljs-attr">searchString</span>=<span class="hljs-string">"^c_"</span> <span class="hljs-attr">replaceString</span>=<span class="hljs-string">""</span> /&gt;</span></code></pre><ul><li><strong>enableXXXByExample</strong> 默认为true，但只有在<code>targetRuntime=&quot;MyBatis3&quot;</code>时才生效。当 <code>targetRuntime=&quot;MyBatis3Simple&quot;</code>时，<strong>enableXXXByExample</strong> 不管为true、还是false 都不生效。一般建议全设置为false，true的话会生成很多Example帮助类，造成很多sonar问题。</li></ul><h2 id="4-参考"><a href="#4-参考" class="headerlink" title="4.参考"></a>4.参考</h2><p><a href="https://segmentfault.com/a/1190000016570268" target="_blank" rel="noopener">Spring Boot （七）MyBatis代码自动生成和辅助插件</a></p><p><a href="https://juejin.im/post/5db694e3e51d452a2e25ba45" target="_blank" rel="noopener">MyBatis Generator 超详细配置</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;1-作用&quot;&gt;&lt;a href=&quot;#1-作用&quot; class=&quot;headerlink&quot; title=&quot;1.作用&quot;&gt;&lt;/a&gt;1.作用&lt;/h2&gt;&lt;p&gt;用来自动生成MyBatis的 mapper、dao、entity &lt;/p&gt;
&lt;h2 id=&quot;2-使用&quot;&gt;&lt;a href=&quot;#
      
    
    </summary>
    
    
      <category term="mybatis" scheme="http://yoursite.com/categories/mybatis/"/>
    
    
      <category term="mybatis-generator" scheme="http://yoursite.com/tags/mybatis-generator/"/>
    
  </entry>
  
  <entry>
    <title>性能优化策略</title>
    <link href="http://yoursite.com/2020/06/01/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E7%AD%96%E7%95%A5/"/>
    <id>http://yoursite.com/2020/06/01/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E7%AD%96%E7%95%A5/</id>
    <published>2020-06-01T12:42:04.000Z</published>
    <updated>2020-06-01T13:25:08.525Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、时空转换"><a href="#一、时空转换" class="headerlink" title="一、时空转换"></a>一、时空转换</h2><h3 id="1-1-时间换空间"><a href="#1-1-时间换空间" class="headerlink" title="1.1 时间换空间"></a>1.1 时间换空间</h3><ul><li>场景1: 降低内存空间的占用。</li><li>场景2: 降低数据的大小来方便网络传输和外部存储。</li></ul><p>具体方式：</p><p>1、改变数据结构或者数据格式，减少要存储的数据大小。</p><p>2、使用压缩算法，压缩内存中的数据，使用时解压。</p><p>3、把内存中的数据存储到外部的、更便宜的存储设备中，需要时再取回来。</p><blockquote><p>这些节省内存空间的方法，一般都需要付出时间的代价。</p></blockquote><blockquote><p>衡量任何压缩算法，基本上看三个指标：压缩比例、压缩速度以及使用内存。</p></blockquote><blockquote><p>如果系统的瓶颈在<strong>网络传输速度或者存储空间大小</strong>上，那就尽量采取高压缩比的算法。</p></blockquote><h3 id="1-2-空间换时间"><a href="#1-2-空间换时间" class="headerlink" title="1.2 空间换时间"></a>1.2 空间换时间</h3><ul><li>场景：要求快速响应。</li></ul><p>具体方式：</p><p>1、对数据和服务进行多份拷贝，尽大可能的覆盖更多的用户。</p><blockquote><p>典型案例：集群</p></blockquote><h2 id="二、预处理和延后处理"><a href="#二、预处理和延后处理" class="headerlink" title="二、预处理和延后处理"></a>二、预处理和延后处理</h2><h3 id="2-1-预处理-提前处理"><a href="#2-1-预处理-提前处理" class="headerlink" title="2.1 预处理/提前处理"></a>2.1 预处理/提前处理</h3><p>使用场景：</p><p>1、web静态资源提前加载，preload 和 prefetch。</p><p>2、文件系统预读功能。提前从磁盘读取下一次的数据。</p><blockquote><p>这个功能对顺序读取十分有效，可以减少磁盘请求的数量</p></blockquote><h3 id="2-2-延后-惰性处理"><a href="#2-2-延后-惰性处理" class="headerlink" title="2.2 延后/惰性处理"></a>2.2 延后/惰性处理</h3><ul><li>尽量将操作推迟到必须执行的时刻。</li></ul><p>使用场景：</p><p>1、COW（copy on write）写时复制。多线程读取共享资源时，不进行复制操作，当某个线程需要对资源进行修改时，才拷贝一份到工作内存，使其不会影响其他线程。</p><h2 id="三、并行和并发"><a href="#三、并行和并发" class="headerlink" title="三、并行和并发"></a>三、并行和并发</h2><h2 id="四、缓存-批量合并"><a href="#四、缓存-批量合并" class="headerlink" title="四、缓存/批量合并"></a>四、缓存/批量合并</h2><h3 id="4-1-缓存"><a href="#4-1-缓存" class="headerlink" title="4.1 缓存"></a>4.1 缓存</h3><ul><li>缓存的本质是加速访问。</li></ul><p>使用场景：</p><p>1、对于一个基于 Web 的应用服务，前端会有浏览器缓存，有 CDN 存放在边缘服务器上，有反向代理提供的静态内容缓存；后端则还会有服务器本地缓存。</p><p>2、程序设计中，对于可能重复创建和销毁，且创建销毁代价很大的对象（比如套接字和线程），也可以缓存，对应的缓存形式，就是连接池和线程池等。</p><p>3、对于消耗较大的计算，也可以将计算结果缓存起来，下次可以直接读取结果。比如对递归代码的一个有效优化手段，就是缓存中间结果。</p><h3 id="4-2批量合并"><a href="#4-2批量合并" class="headerlink" title="4.2批量合并"></a>4.2批量合并</h3><ul><li>在有 IO（比如网络 IO 和磁盘 IO）的时候，合并操作和批量操作往往能提升吞吐量，提高性能。</li></ul><p>使用场景：</p><p>1、批量 IO 读写。就是在有多次 IO 的时候，可以把它们合并成一次读写数据。这样可以减少读写时间和协议负担。</p><p>2、对数据库的读写操作，也可以尽量合并。比如，对键值数据库的查询，最好一次查询多个键，而不要分成多次。</p><p>3、涉及到网络请求的时候，网络传输的时间可能远大于请求的处理时间，因此合并网络请求也很有必要。</p><h2 id="五、更高效的算法和数据结构"><a href="#五、更高效的算法和数据结构" class="headerlink" title="五、更高效的算法和数据结构"></a>五、更高效的算法和数据结构</h2><h2 id="附录："><a href="#附录：" class="headerlink" title="附录："></a>附录：</h2><p><a href="https://www.toutiao.com/i6832247243278385671/" target="_blank" rel="noopener">参考文档</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;一、时空转换&quot;&gt;&lt;a href=&quot;#一、时空转换&quot; class=&quot;headerlink&quot; title=&quot;一、时空转换&quot;&gt;&lt;/a&gt;一、时空转换&lt;/h2&gt;&lt;h3 id=&quot;1-1-时间换空间&quot;&gt;&lt;a href=&quot;#1-1-时间换空间&quot; class=&quot;headerlink
      
    
    </summary>
    
    
      <category term="总结" scheme="http://yoursite.com/categories/%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="性能优化" scheme="http://yoursite.com/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>服务熔断</title>
    <link href="http://yoursite.com/2020/05/31/%E6%9C%8D%E5%8A%A1%E7%86%94%E6%96%AD/"/>
    <id>http://yoursite.com/2020/05/31/%E6%9C%8D%E5%8A%A1%E7%86%94%E6%96%AD/</id>
    <published>2020-05-31T14:43:58.000Z</published>
    <updated>2020-05-31T15:45:41.762Z</updated>
    
    <content type="html"><![CDATA[<h1 id="服务熔断"><a href="#服务熔断" class="headerlink" title="服务熔断"></a>服务熔断</h1><ul><li>hystrix，是一个用于处理分布式系统延迟和容错的库，它能够保证在一个子服务出问题的情况下，不会导致整体服务失败，避免级联雪崩，以提高分布式系统的弹性。</li><li>“断路器”本身是一个开关装置，当某个服务单元发生故障后，向调用方返回一个服务预期的、可处理的备选响应，而不是长时间等待或者抛出一个服务端无法处理的异常。这样就保证了调用方线程不会被长时间占用，从而避免故障在分布式系统中蔓延，甚至雪崩。</li></ul><h2 id="1、服务降级（客户端提供异常响应）"><a href="#1、服务降级（客户端提供异常响应）" class="headerlink" title="1、服务降级（客户端提供异常响应）"></a>1、服务降级（客户端提供异常响应）</h2><ul><li>限制其他低相关服务的访问，使他们占用计算机较少的资源，从而保障主服务拥有更多的资源，使其能正常访问。</li></ul><pre><code class="hljs java"><span class="hljs-comment">// 配置文件默认关闭，需手动开启</span>feign:  hystrix:    enabled: true # 启用服务降级<span class="hljs-meta">@FeignClient</span>(name = <span class="hljs-string">"MYCLOUD-PROVIDER"</span>, fallback = HystrixConsumerService<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span><span class="hljs-class"><span class="hljs-title">public</span> <span class="hljs-title">interface</span> <span class="hljs-title">CorpConsumerService</span> </span>&#123;    <span class="hljs-meta">@GetMapping</span>(<span class="hljs-string">"/corps/&#123;id&#125;"</span>)    <span class="hljs-function">Corp <span class="hljs-title">getCorp</span><span class="hljs-params">(@PathVariable(<span class="hljs-string">"id"</span>)</span> String id)</span>;    <span class="hljs-meta">@GetMapping</span>(<span class="hljs-string">"/corps"</span>)    <span class="hljs-function">List&lt;Corp&gt; <span class="hljs-title">getCorps</span><span class="hljs-params">()</span></span>;&#125;<span class="hljs-comment">// 客户端熔断回调缺省值处理</span><span class="hljs-comment">// 假设服务端未启动，即这么处理</span><span class="hljs-meta">@Service</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HystrixConsumerService</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">CorpConsumerService</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> Corp <span class="hljs-title">getCorp</span><span class="hljs-params">(String id)</span> </span>&#123;        <span class="hljs-keyword">return</span> Corp.builder().id(id).name(<span class="hljs-string">"HystrixConsumerService"</span>).age(<span class="hljs-number">40</span>).build();    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;Corp&gt; <span class="hljs-title">getCorps</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;    &#125;&#125;</code></pre><h2 id="2、服务熔断（服务端返回合适的异常响应）"><a href="#2、服务熔断（服务端返回合适的异常响应）" class="headerlink" title="2、服务熔断（服务端返回合适的异常响应）"></a>2、服务熔断（服务端返回合适的异常响应）</h2><ul><li>熔断机制是对微服务雪崩效应的一种链路保护机制。</li><li>当扇出链路的某个微服务不可用或者响应时间太长时，会进行服务的降级，<strong>进而熔断该节点的微服务调用，快速返回错误的响应信息，当检测到该微服务调用响应正常后恢复调用链路。</strong></li><li>hystrix会监控微服务之间的调用状况，当失败的调用到一定阈值，缺省是5s内20ci调用失败就会触发。熔断机制的注解是@HystrixCommand。</li></ul><pre><code class="hljs java"><span class="hljs-comment">// 启动类配置enable</span><span class="hljs-meta">@SpringBootApplication</span><span class="hljs-meta">@EnableEurekaClient</span><span class="hljs-meta">@EnableHystrix</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CorpProvider8005</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        SpringApplication.run(CorpProvider8005<span class="hljs-class">.<span class="hljs-keyword">class</span>, <span class="hljs-title">args</span>)</span>;    &#125;&#125;<span class="hljs-comment">// 添加@HystrixCommand注解</span><span class="hljs-comment">// 发生异常时，会调用hystrixCorp方法，控制台无异常堆栈</span><span class="hljs-meta">@GetMapping</span>(<span class="hljs-string">"/corps/&#123;id&#125;"</span>)<span class="hljs-meta">@HystrixCommand</span>(fallbackMethod = <span class="hljs-string">"hystrixCorp"</span>)<span class="hljs-function">Corp <span class="hljs-title">getCorp</span><span class="hljs-params">(@PathVariable(<span class="hljs-string">"id"</span>)</span> String id) </span>&#123;  Corp corp = corpService.getCorp(id);  <span class="hljs-keyword">if</span> (corp == <span class="hljs-keyword">null</span>) &#123;    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(<span class="hljs-string">"id "</span> + id + <span class="hljs-string">" 不存在"</span>);  &#125;  <span class="hljs-keyword">return</span> corp;&#125;<span class="hljs-function">Corp <span class="hljs-title">hystrixCorp</span><span class="hljs-params">(@PathVariable(<span class="hljs-string">"id"</span>)</span> String id) </span>&#123;  <span class="hljs-keyword">return</span> Corp.builder().id(id).name(<span class="hljs-string">"hystrix"</span>).age(<span class="hljs-number">30</span>).build();&#125;</code></pre><h2 id="3、服务限流"><a href="#3、服务限流" class="headerlink" title="3、服务限流"></a>3、服务限流</h2><h2 id="4、实时监控"><a href="#4、实时监控" class="headerlink" title="4、实时监控"></a>4、实时监控</h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;服务熔断&quot;&gt;&lt;a href=&quot;#服务熔断&quot; class=&quot;headerlink&quot; title=&quot;服务熔断&quot;&gt;&lt;/a&gt;服务熔断&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;hystrix，是一个用于处理分布式系统延迟和容错的库，它能够保证在一个子服务出问题的情况下，不会导致整体服务失
      
    
    </summary>
    
    
      <category term="java" scheme="http://yoursite.com/categories/java/"/>
    
    
      <category term="springCloud hystrix" scheme="http://yoursite.com/tags/springCloud-hystrix/"/>
    
  </entry>
  
  <entry>
    <title>负载均衡</title>
    <link href="http://yoursite.com/2020/05/31/%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/"/>
    <id>http://yoursite.com/2020/05/31/%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/</id>
    <published>2020-05-31T13:32:48.000Z</published>
    <updated>2020-05-31T14:47:12.805Z</updated>
    
    <content type="html"><![CDATA[<h1 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h1><ul><li><p>LB（load balance）：简单的说就是将用户请求平摊分配到多个服务器上，从而达到系统的高可用。</p></li><li><p>常见的负载均衡软件有nginx、lvx</p></li><li><p>常见分类</p><ul><li>集中式LB：在服务的消费方和服务方使用独立的Lb方式，如nginx，由它负责请求转发。</li><li>进程式LB：将LB逻辑集成到消费方，消费方从注册中心获取可用的服务，再从这里面选一个进行访问，如ribbon。</li></ul></li></ul><h2 id="ribbon-负载均衡"><a href="#ribbon-负载均衡" class="headerlink" title="ribbon 负载均衡"></a>ribbon 负载均衡</h2><pre><code class="hljs java"><span class="hljs-comment">// 配置类</span><span class="hljs-meta">@Configuration</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RestTemplateConfig</span> </span>&#123;    <span class="hljs-meta">@Bean</span>    <span class="hljs-meta">@LoadBalanced</span>    <span class="hljs-function">RestTemplate <span class="hljs-title">restTemplate</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> RestTemplate();    &#125;&#125;<span class="hljs-comment">// controller调用</span><span class="hljs-comment">// 第二版根据服务名去访问，需要将restTemplate注解为@LoadBalanced才会生效</span><span class="hljs-keyword">private</span> String service = <span class="hljs-string">"http://MYCLOUD-PROVIDER"</span>;<span class="hljs-meta">@RequestMapping</span>(<span class="hljs-string">"/consumer/corps/&#123;id&#125;"</span>)<span class="hljs-function">Corp <span class="hljs-title">getCorp</span><span class="hljs-params">(@PathVariable(<span class="hljs-string">"id"</span>)</span> String id) </span>&#123;  String url = service + <span class="hljs-string">"/corps/"</span>;  <span class="hljs-keyword">return</span> restTemplate.getForObject(url + id, Corp<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;&#125;</code></pre><blockquote><p>使用服务名去调用，restful风格</p></blockquote><h2 id="feign-负载均衡"><a href="#feign-负载均衡" class="headerlink" title="feign 负载均衡"></a>feign 负载均衡</h2><ul><li>feign是声明式的web service客户端，只需提供一个接口，添加注解就可以了。</li><li>feign是ribbon的封装，以面向对象方式的去访问。</li><li>feign不需要去显式的声明restTemplate</li></ul><blockquote><p>使用接口注解去调用</p></blockquote><pre><code class="hljs java"><span class="hljs-comment">// 逻辑处理类，映射路径为实际接口路径</span><span class="hljs-meta">@FeignClient</span>(name = <span class="hljs-string">"MYCLOUD-PROVIDER"</span>)<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">CorpConsumerService</span> </span>&#123;    <span class="hljs-meta">@GetMapping</span>(<span class="hljs-string">"/corps/&#123;id&#125;"</span>)    <span class="hljs-function">Corp <span class="hljs-title">getCorp</span><span class="hljs-params">(@PathVariable(<span class="hljs-string">"id"</span>)</span> String id)</span>;    <span class="hljs-meta">@GetMapping</span>(<span class="hljs-string">"/corps"</span>)    <span class="hljs-function">List&lt;Corp&gt; <span class="hljs-title">getCorps</span><span class="hljs-params">()</span></span>;&#125;<span class="hljs-comment">// 启动类配置enable</span><span class="hljs-meta">@SpringBootApplication</span><span class="hljs-meta">@EnableEurekaClient</span><span class="hljs-meta">@EnableFeignClients</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CorpConsumer8002</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        SpringApplication.run(CorpConsumer8002<span class="hljs-class">.<span class="hljs-keyword">class</span>, <span class="hljs-title">args</span>)</span>;    &#125;&#125;</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;负载均衡&quot;&gt;&lt;a href=&quot;#负载均衡&quot; class=&quot;headerlink&quot; title=&quot;负载均衡&quot;&gt;&lt;/a&gt;负载均衡&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;LB（load balance）：简单的说就是将用户请求平摊分配到多个服务器上，从而达到系统的高可用。&lt;/
      
    
    </summary>
    
    
      <category term="java" scheme="http://yoursite.com/categories/java/"/>
    
    
      <category term="springCloud ribbon" scheme="http://yoursite.com/tags/springCloud-ribbon/"/>
    
  </entry>
  
  <entry>
    <title>eureka对比zookeeper</title>
    <link href="http://yoursite.com/2020/05/31/eureka%E5%AF%B9%E6%AF%94zookeeper/"/>
    <id>http://yoursite.com/2020/05/31/eureka%E5%AF%B9%E6%AF%94zookeeper/</id>
    <published>2020-05-31T13:09:42.000Z</published>
    <updated>2020-06-09T14:52:36.481Z</updated>
    
    <content type="html"><![CDATA[<h1 id="cap原则"><a href="#cap原则" class="headerlink" title="cap原则"></a>cap原则</h1><h2 id="一、回顾"><a href="#一、回顾" class="headerlink" title="一、回顾"></a>一、回顾</h2><ul><li><p>ACID 原则</p><ul><li>关系数据库管理系统（Relational Database Management System：<em>RDBMS</em>），如mysql、oracle、sqlserver</li><li>A（atomicity）原子性</li><li>C（consistency）一致性</li><li>I（Isolation）隔离性</li><li>D（durability）持久性</li></ul></li><li><p>CAP原则</p><ul><li><p>一般用于redis、mongdb</p></li><li><p>C（consistency）一致性：</p><p>分布式环境下，一致性主要指数据在多个副本之间是否一致，（等同于所有节点访问同一份最新的数据副本）。</p><p>通过某个节点的写操作结果对后面通过其他节点的读操作可见，如果数据更新后并发访问情况下可立即感知其更新， 称为强一致性，如果允许之后部分或者全部感知不到该更新，称为弱一致性，若在之后一段时间后，一定可以感知该更新，称为最终一致性。</p></li><li><p>A（avaibility）可用性：</p><p>在集群中一部分节点故障后，集群整体是否还能响应客户端的读写请求。（对数据更新具备高可用性）</p></li><li><p>P（partition tolerance）分区容错性：</p><p>集群出现网络割裂时，集群还能继续提供一定的可用性和一致性，除非整个网络不可用，也即部分节点宕机或者无法与其他节点通信时，各分区间还可保持分布式系统的功能。</p></li></ul></li></ul><p><strong>著名的CAP理论指出，一个分布式系统不可能同时满足C(一致性)、A(可用性)和P(分区容错性)。由于分区容错性在是分布式系统中必须要保证的，因此我们只能在A和C之间进行权衡。zookeeper保证的是CP， 而eureka则是AP。</strong></p><ul><li><p>BASE理论</p><ul><li><p>BASE是Basically Available（基本可用）、Soft state（软状态）和Eventually consistent（最终一致性）三个短语的简写，BASE是对CAP中一致性和可用性权衡的结果，其来源于对大规模互联网系统分布式实践的结论，是基于CAP定理逐步演化而来的，其核心思想是即使无法做到强一致性（Strong consistency），但每个应用都可以根据自身的业务特点，采用适当的方式来使系统达到最终一致性（Eventual consistency）。</p></li><li><p>BASE之基本可用体现在两个方面： 1、响应时间上的损失：比如某些请求1秒内给出响应，有些请求可能会在5秒内给出响应 2、功能上的损失：例如对于电商系统来说，某些区域可能不能购买某些商品，又或者大促时，部分消费者被引流到降级页面。</p></li><li><p>BASE之弱状态： 也称为软状态，是指允许系统中的数据存在中间状态，并认为该状态不会影响系统的整体可用性，即允许系统在不同节点的数据副本之间存在一定的延时。</p></li><li><p>BASE之最终一致性： 系统中的数据副本在经过一段时间同步后，组中能够达到一个一致的状态。</p></li></ul></li></ul><h2 id="二、集群环境下如何保障数据一致性"><a href="#二、集群环境下如何保障数据一致性" class="headerlink" title="二、集群环境下如何保障数据一致性"></a>二、集群环境下如何保障数据一致性</h2><p>集群环境下有三种方式保障数据一致性：数据复制、WNR和集中存储。</p><p>1、数据复制：先向单节点写入，再复制到其他节点，zookeeper是这样实现的。或者多节点同时写入，但只适合多节点写入的数据不是相同数据的应用场景。在master-slave场景中， 同步复制（slave从master全部复制完成才给客户端返回写入成功）可保证强一致性，但会影响可用性；异步复制（数据写入master就返回写入成功，不需要等到slave复制完成， 之后master通过push向slave推送数据或者slave通过ull方式从master拉数据）可提供可用性但会降低一致性。</p><p>2、WNR：N代表总副本数，W代表每次写操作要保证的最少写成功的副本数，R代表每次读操作最少读取的副本数，当W+R&gt;N时，可保证每次读取的数据至少有一个副本具有最新的更新 （例如可以通过版本号或者时间戳判断是哪个副本的数据是最新的），多个写操作的顺序难以保证，可能导致多副本的写操作顺序不一致，Dynamo通过箱量时钟在保证最终一致性。</p><p>3、集中存储：借助可靠性较高的集中存储，比如NAS存储，分布式缓存（Redis）等。</p><h2 id="二、zookeeper保证的是CP"><a href="#二、zookeeper保证的是CP" class="headerlink" title="二、zookeeper保证的是CP"></a>二、zookeeper保证的是CP</h2><ul><li>放弃可用性，并不是完全没有可用性，是指允许响应超时的时间可以更长，比如报表可以运行10分钟左右，甚至在某些情况下允许超时。</li><li>Zookeeper会出现这样一种情况，当master节点因为网络故障与其他节点失去联系时，剩余节点会重新进行leader选举。问题在于，选举leader的时间太长，30 ~ 120s, 且选举期间整个Zookeeper集群都是不可用的，这就导致在选举期间注册服务瘫痪。在云部署的环境下，因网络问题使得Zookeeper集群失去master节点是较大概率会发生的事，虽然服务能够最终恢复，但是漫长的选举时间导致的注册长期不可用是不能容忍的。</li></ul><p><strong>zk集群：</strong></p><p>1、zk集群是一种对等集群，所有节点（机器）数据都一样。</p><p>2、集群节点之间靠心跳感知彼此的存在。 </p><p>3、所有写操作都在主节点，其他节点只能读，虽然也可以接收写请求，但是内部会把写操作转给主节点。 </p><p>4、通过选举机制选出主节点，从而保障了主节点的高可用，这样主节点就不是固定的，万一主节点宕机还可以重新选举出主节点。 </p><p>5、至少需要三个节点，而且节点个数必须是奇数。 </p><p>6、当一半以上的数据写入成功后，则返回写入成功，是最终一致性策略。</p><h2 id="三、eureka保证的是AP"><a href="#三、eureka保证的是AP" class="headerlink" title="三、eureka保证的是AP"></a>三、eureka保证的是AP</h2><ul><li><p>放弃一致性是放弃数据的强一致性，而保留数据的最终一致性，即数据最终是完全一致的，但有一个时间窗口的问题，这需要根据不同的业务来定义。</p></li><li><p>当向注册中心查询服务列表时，我们可以容忍注册中心返回的是几分钟以前的注册信息，但不能接受服务直接down掉不可用。也就是说，服务注册功能对可用性的要求要高于一致性。</p></li><li><p>Eureka在设计时就优先保证可用性。Eureka各个节点都是平等的，几个节点挂掉不会影响正常节点的工作，剩余的节点依然可以提供注册和查询服务。而Eureka的客户端在向某个Eureka注册或时如果发现连接失败，则会自动切换至其它节点，只要有一台Eureka还在，就能保证注册服务可用(保证可用性)，只不过查到的信息可能不是最新的(不保证强一致性)。</p></li><li><p>除此之外，Eureka还有一种自我保护机制，如果在15分钟内超过85%的节点都没有正常的心跳，那么Eureka就认为客户端与注册中心出现了网络故障，此时会出现以下几种情况：</p><ol><li>Eureka不再从注册列表中移除因为长时间没收到心跳而应该过期的服务。</li><li>Eureka仍然能够接受新服务的注册和查询请求，但是不会被同步到其它节点上(即保证当前节点依然可用) 。</li><li>当网络稳定时，当前实例新的注册信息会被同步到其它节点中。因此， Eureka可以很好的应对因网络故障导致部分节点失去联系的情况，而不会像zookeeper那样使整个注册服务瘫痪。</li></ol></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;cap原则&quot;&gt;&lt;a href=&quot;#cap原则&quot; class=&quot;headerlink&quot; title=&quot;cap原则&quot;&gt;&lt;/a&gt;cap原则&lt;/h1&gt;&lt;h2 id=&quot;一、回顾&quot;&gt;&lt;a href=&quot;#一、回顾&quot; class=&quot;headerlink&quot; title=&quot;一、回顾&quot;
      
    
    </summary>
    
    
      <category term="springCloud" scheme="http://yoursite.com/categories/springCloud/"/>
    
    
      <category term="eureka zookeeper" scheme="http://yoursite.com/tags/eureka-zookeeper/"/>
    
  </entry>
  
  <entry>
    <title>java8方法引用理解</title>
    <link href="http://yoursite.com/2020/05/31/java8%E6%96%B9%E6%B3%95%E5%BC%95%E7%94%A8%E7%90%86%E8%A7%A3/"/>
    <id>http://yoursite.com/2020/05/31/java8%E6%96%B9%E6%B3%95%E5%BC%95%E7%94%A8%E7%90%86%E8%A7%A3/</id>
    <published>2020-05-31T04:12:15.000Z</published>
    <updated>2020-05-31T04:13:16.886Z</updated>
    
    <content type="html"><![CDATA[<h2 id="什么是方法引用"><a href="#什么是方法引用" class="headerlink" title="什么是方法引用?"></a>什么是方法引用?</h2><p>方法引用可用于在不调用方法的情况下引用方法。它将方法视为Lambda表达式。它们只能作为语法糖来减少一些lambdas的冗长。在方法引用中，将包含方法的对象（或类）放在::运算符之前，将方法的名称放在不带参数的方法之后。例如：</p><pre><code class="hljs asciidoc"><span class="hljs-bullet">Object :: </span>methodName</code></pre><h2 id="为什么会出现方法引用？"><a href="#为什么会出现方法引用？" class="headerlink" title="为什么会出现方法引用？"></a>为什么会出现方法引用？</h2><p>在Java中，我们可以通过创建新对象来使用对象的引用,或者引用已有的对象，例如：</p><pre><code class="hljs lasso"><span class="hljs-comment">//创建新对象来引用该对象</span><span class="hljs-built_in">List</span> <span class="hljs-built_in">list</span> = <span class="hljs-literal">new</span> ArrayList();dosth(<span class="hljs-built_in">list</span>);<span class="hljs-comment">//引用已有的对象</span><span class="hljs-built_in">List</span> list2 = <span class="hljs-built_in">list</span>;dosth(list2);</code></pre><p>如果我们只在另一个方法中使用对象的方法，我们仍然必须将完整的对象作为参数传递。那么将方法作为参数传递不是更有效吗？</p><h2 id="方法引用这种语法糖不能用于所有的方法，它们只能用于只有一个方法的lambda表达式"><a href="#方法引用这种语法糖不能用于所有的方法，它们只能用于只有一个方法的lambda表达式" class="headerlink" title="方法引用这种语法糖不能用于所有的方法，它们只能用于只有一个方法的lambda表达式"></a>方法引用这种语法糖不能用于所有的方法，它们只能用于只有一个方法的lambda表达式</h2><pre><code class="hljs arduino"><span class="hljs-comment">//lambda转方法引用</span>Consumer&lt;<span class="hljs-keyword">String</span>&gt; c = s -&gt; System.out.<span class="hljs-built_in">println</span>(s);Consumer&lt;<span class="hljs-keyword">String</span>&gt; c = System.out::<span class="hljs-built_in">println</span>;</code></pre><p>换句话说，可以使用lambda表达式去代替一个匿名类，如果这个匿名类只有一个方法，就可以用更简短的方法引用来代替lambda表达式。</p><h2 id="静态方法引用"><a href="#静态方法引用" class="headerlink" title="静态方法引用"></a>静态方法引用</h2><pre><code class="hljs livescript"><span class="hljs-keyword">from</span><span class="hljs-function"><span class="hljs-params">(args)</span> -&gt;</span> Class.staticMethod(args)<span class="hljs-keyword">to</span>Class::staticMethod</code></pre><p>如上所述，我们不需要显式的传递参数，方法引用中会自动传递参数</p><pre><code class="hljs arduino">Consumer&lt;<span class="hljs-keyword">String</span>&gt; c1 = (s) -&gt; System.out.<span class="hljs-built_in">println</span>(s);Consumer&lt;<span class="hljs-keyword">String</span>&gt; c2 = System.out::<span class="hljs-built_in">println</span>;c2.accept(<span class="hljs-string">"Hello"</span>);</code></pre><p>当我们所使用的lambda表达式仅仅调用了一个静态方法，我们就可以使用静态方法引用。如下所示，将lambda表达式（匿名类）中的值判断提取成isMoreThanFifty这个静态方法，就可以使用静态方法引用这种语法糖。</p><pre><code class="hljs reasonml">public <span class="hljs-keyword">class</span> Numbers &#123;    <span class="hljs-comment">//将值判断提取成静态方法</span>    public static boolean is<span class="hljs-constructor">MoreThanFifty(<span class="hljs-params">int</span> <span class="hljs-params">n1</span>, <span class="hljs-params">int</span> <span class="hljs-params">n2</span>)</span> &#123;        return (n1 + n2) &gt; <span class="hljs-number">50</span>;    &#125;    <span class="hljs-comment">//公共接口方法</span>    public static List&lt;Integer&gt; find<span class="hljs-constructor">Numbers(List&lt;Integer&gt; <span class="hljs-params">l</span>, BiPredicate&lt;Integer, Integer&gt; <span class="hljs-params">p</span>)</span> &#123;        List&lt;Integer&gt; newList = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;<span class="hljs-literal">()</span>;        for (Integer i : l) &#123;            <span class="hljs-keyword">if</span> (p.test(i, i + <span class="hljs-number">10</span>)) &#123;                newList.add(i);            &#125;        &#125;        return newList;    &#125;    public static void main(String<span class="hljs-literal">[]</span> args) &#123;        List&lt;Integer&gt; <span class="hljs-built_in">list</span> = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Arrays</span>.</span></span><span class="hljs-keyword">as</span><span class="hljs-constructor">List(12, 5, 45, 18, 33, 24, 40)</span>;        <span class="hljs-comment">// Using an anonymous class</span>        List&lt;Integer&gt; res = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Numbers</span>.</span></span>find<span class="hljs-constructor">Numbers(<span class="hljs-params">list</span>, <span class="hljs-params">new</span> BiPredicate&lt;Integer, Integer&gt;()</span> &#123;            @Override            public boolean test(Integer integer, Integer integer2) &#123;                return <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Numbers</span>.</span></span>is<span class="hljs-constructor">MoreThanFifty(<span class="hljs-params">integer</span>, <span class="hljs-params">integer2</span>)</span>;            &#125;        &#125;);        res.stream<span class="hljs-literal">()</span>.for<span class="hljs-constructor">Each(System.<span class="hljs-params">out</span> :: <span class="hljs-params">println</span>)</span>;<span class="hljs-comment">//        res.stream().peek(System.out :: println).collect(Collectors.toList());</span>        <span class="hljs-comment">// Using a lambda expression</span>        <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Numbers</span>.</span></span>find<span class="hljs-constructor">Numbers(<span class="hljs-params">list</span>, (<span class="hljs-params">i1</span>, <span class="hljs-params">i2</span>)</span> -&gt; <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Numbers</span>.</span></span>is<span class="hljs-constructor">MoreThanFifty(<span class="hljs-params">i1</span>, <span class="hljs-params">i2</span>)</span>);        <span class="hljs-comment">// Using a method reference</span>        <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Numbers</span>.</span></span>find<span class="hljs-constructor">Numbers(<span class="hljs-params">list</span>, Numbers::<span class="hljs-params">isMoreThanFifty</span>)</span>;    &#125;&#125;</code></pre><h2 id="特定类型的对象的实例方法的方法引用"><a href="#特定类型的对象的实例方法的方法引用" class="headerlink" title="特定类型的对象的实例方法的方法引用"></a>特定类型的对象的实例方法的方法引用</h2><pre><code class="hljs livescript"><span class="hljs-keyword">from</span><span class="hljs-function"><span class="hljs-params">(obj, args)</span> -&gt;</span> obj.instanceMethod(args)<span class="hljs-keyword">to</span>ObjectType::instanceMethod</code></pre><ul><li>我们使用实例的类型而非实例本身</li><li>参数隐式传递<pre><code class="hljs zephir"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">People</span> </span>&#123;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">double</span> calculateWeight() &#123;        <span class="hljs-keyword">double</span> weight = <span class="hljs-number">0</span>;        <span class="hljs-comment">// Calculate weight</span>        <span class="hljs-keyword">return</span> weight;    &#125;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">List</span>&lt;<span class="hljs-keyword">Double</span>&gt; calculateAllWeight(<span class="hljs-keyword">List</span>&lt;People&gt; l, <span class="hljs-function"><span class="hljs-keyword">Function</span>&lt;<span class="hljs-title">People</span>, <span class="hljs-title">Double</span>&gt; <span class="hljs-title">f</span>) </span>&#123;        <span class="hljs-keyword">List</span>&lt;<span class="hljs-keyword">Double</span>&gt; results = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();        <span class="hljs-keyword">for</span> (People s : l) &#123;            results.add(f.apply(s));        &#125;        <span class="hljs-keyword">return</span> results;    &#125;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PeopleClient</span> </span>&#123;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> void main(String[] args) &#123;        <span class="hljs-keyword">List</span>&lt;People&gt; <span class="hljs-keyword">list</span> = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();        People p = <span class="hljs-keyword">new</span> People();        <span class="hljs-comment">// Using an anonymous class</span>        p.calculateAllWeight(<span class="hljs-keyword">list</span>, <span class="hljs-keyword">new</span> <span class="hljs-function"><span class="hljs-keyword">Function</span>&lt;<span class="hljs-title">People</span>, <span class="hljs-title">Double</span>&gt;<span class="hljs-params">()</span> </span>&#123;            @Override            <span class="hljs-keyword">public</span> <span class="hljs-keyword">Double</span> apply(People people) &#123;<span class="hljs-comment">// The object</span>                <span class="hljs-keyword">return</span> people.calculateWeight();<span class="hljs-comment">// The method</span>            &#125;        &#125;);        <span class="hljs-comment">// Using a lambda expression</span>        p.calculateAllWeight(<span class="hljs-keyword">list</span>, people -&gt; people.calculateWeight());        <span class="hljs-comment">// Using a method reference</span>        p.calculateAllWeight(<span class="hljs-keyword">list</span>, People::calculateWeight);    &#125;&#125;</code></pre>在这个例子中，我们没有给方法传递任何参数，关键在于对象的实例是lambda表达式的一个参数，我们通过实例的类型来完成对实例方法的引用。下面是另一个例子，在这个例子中，我们向方法引用中传递了两个参数。<pre><code class="hljs lasso"><span class="hljs-comment">//java中有一个Function接口可以接收一个参数，BiFunction接口接受两个参数，没有接受三个参数的，所以我们自定义一个TriFunction</span>interface TriFunction&lt;T, U, V, R&gt; &#123;  R apply(T t, U u, V v);&#125;<span class="hljs-comment">//然后定义一个类，接收两个参数，并且有一个返回值</span>class <span class="hljs-keyword">Sum</span> &#123;  <span class="hljs-built_in">Integer</span> doSum(<span class="hljs-built_in">String</span> s1, <span class="hljs-built_in">String</span> s2) &#123;    <span class="hljs-keyword">return</span> <span class="hljs-built_in">Integer</span>.parseInt(s1) + <span class="hljs-built_in">Integer</span>.parseInt(s1);  &#125;&#125;<span class="hljs-comment">//用匿名类实现TriFunction，来包装doSum()</span>TriFunction&lt;<span class="hljs-keyword">Sum</span>, <span class="hljs-built_in">String</span>, <span class="hljs-built_in">String</span>, <span class="hljs-built_in">Integer</span>&gt; anonymous =  <span class="hljs-literal">new</span> TriFunction&lt;<span class="hljs-keyword">Sum</span>, <span class="hljs-built_in">String</span>, <span class="hljs-built_in">String</span>, <span class="hljs-built_in">Integer</span>&gt;() &#123;    @Override    <span class="hljs-keyword">public</span> <span class="hljs-built_in">Integer</span> apply(<span class="hljs-keyword">Sum</span> s, <span class="hljs-built_in">String</span> arg1, <span class="hljs-built_in">String</span> arg2) &#123;      <span class="hljs-keyword">return</span> s.doSum(arg1, arg2);    &#125;&#125;;System.out.println(anonymous.apply(<span class="hljs-literal">new</span> <span class="hljs-keyword">Sum</span>(), <span class="hljs-string">"1"</span>, <span class="hljs-string">"4"</span>));<span class="hljs-comment">//使用lambda表达式来包装</span>TriFunction&lt;<span class="hljs-keyword">Sum</span>, <span class="hljs-built_in">String</span>, <span class="hljs-built_in">String</span>, <span class="hljs-built_in">Integer</span>&gt; lambda =  (<span class="hljs-keyword">Sum</span> s, <span class="hljs-built_in">String</span> arg1, <span class="hljs-built_in">String</span> arg2) -&gt; s.doSum(arg1, arg2);System.out.println(lambda.apply(<span class="hljs-literal">new</span> <span class="hljs-keyword">Sum</span>(), <span class="hljs-string">"1"</span>, <span class="hljs-string">"4"</span>));<span class="hljs-comment">//使用方法引用</span>TriFunction&lt;<span class="hljs-keyword">Sum</span>, <span class="hljs-built_in">String</span>, <span class="hljs-built_in">String</span>, <span class="hljs-built_in">Integer</span>&gt; mRef = <span class="hljs-keyword">Sum</span><span class="hljs-type">::doSum</span>;System.out.println(mRef.apply(<span class="hljs-literal">new</span> <span class="hljs-keyword">Sum</span>(), <span class="hljs-string">"1"</span>, <span class="hljs-string">"4"</span>));</code></pre></li><li>第一个参数是要执行的方法的实例对象</li><li>第二、三个参数是传递的其他参数</li><li>最后一个参数是要执行的方法的返回值类型</li></ul><h2 id="已有对象的实例方法引用"><a href="#已有对象的实例方法引用" class="headerlink" title="已有对象的实例方法引用"></a>已有对象的实例方法引用</h2><pre><code class="hljs livescript"><span class="hljs-keyword">from</span><span class="hljs-function"><span class="hljs-params">(args)</span> -&gt;</span> obj.instanceMethod(args)<span class="hljs-keyword">to</span>obj::instanceMethod</code></pre><p>直接引用已经在其他地方实例化的对象的一个方法，本身不需要再实现一次</p><pre><code class="hljs arduino"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Car</span> &#123;</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> id;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">String</span> color;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getId</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> id;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setId</span><span class="hljs-params">(<span class="hljs-keyword">int</span> id)</span> </span>&#123;        <span class="hljs-keyword">this</span>.id = id;    &#125;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Mechanic</span> &#123;</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">fix</span><span class="hljs-params">(Car c)</span> </span>&#123;        System.out.<span class="hljs-built_in">println</span>(<span class="hljs-string">"Fixing car "</span> + c.getId());    &#125;&#125;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">InstanceRef</span> &#123;</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">String</span>[] args)</span> </span>&#123;        InstanceRef instanceRef = <span class="hljs-keyword">new</span> InstanceRef();        <span class="hljs-keyword">final</span> Mechanic mechanic = <span class="hljs-keyword">new</span> Mechanic();        Car car = <span class="hljs-keyword">new</span> Car();        <span class="hljs-comment">// Using an anonymous class</span>        instanceRef.execute(car, <span class="hljs-keyword">new</span> Consumer&lt;Car&gt;() &#123;            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> accept(Car c) &#123;                mechanic.fix(c);            &#125;        &#125;);        <span class="hljs-comment">// Using a lambda expression</span>        instanceRef.execute(car, car1 -&gt; mechanic.fix(car1));        <span class="hljs-comment">//Using a method reference</span>        instanceRef.execute(car, mechanic::fix);    &#125;    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">execute</span><span class="hljs-params">(Car car, Consumer&lt;Car&gt; c)</span> </span>&#123;        c.accept(car);    &#125;&#125;</code></pre><h2 id="构造方法引用"><a href="#构造方法引用" class="headerlink" title="构造方法引用"></a>构造方法引用</h2><pre><code class="hljs livescript"><span class="hljs-keyword">from</span><span class="hljs-function"><span class="hljs-params">(args)</span> -&gt;</span> <span class="hljs-keyword">new</span> ClassName(args)<span class="hljs-keyword">to</span>ClassName::<span class="hljs-keyword">new</span></code></pre><p>这个lambda表达式唯一能做的就是创建一个新对象，我们通过关键字new来引用类的构造函数。与其他情况一样，参数（如果有）不会在方法引用中传递。</p><p><strong>无参构造</strong></p><pre><code class="hljs dart"><span class="hljs-comment">// Using an anonymous class</span>Supplier&lt;<span class="hljs-built_in">List</span>&lt;<span class="hljs-built_in">String</span>&gt;&gt; s = <span class="hljs-keyword">new</span> Supplier() &#123;  public <span class="hljs-built_in">List</span>&lt;<span class="hljs-built_in">String</span>&gt; <span class="hljs-keyword">get</span>() &#123;    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ArrayList&lt;<span class="hljs-built_in">String</span>&gt;();  &#125;&#125;;<span class="hljs-built_in">List</span>&lt;<span class="hljs-built_in">String</span>&gt; l = s.<span class="hljs-keyword">get</span>();<span class="hljs-comment">// Using a lambda expression</span>Supplier&lt;<span class="hljs-built_in">List</span>&lt;<span class="hljs-built_in">String</span>&gt;&gt; s = () -&gt; <span class="hljs-keyword">new</span> ArrayList&lt;<span class="hljs-built_in">String</span>&gt;();<span class="hljs-built_in">List</span>&lt;<span class="hljs-built_in">String</span>&gt; l = s.<span class="hljs-keyword">get</span>();<span class="hljs-comment">// Using a method reference</span>Supplier&lt;<span class="hljs-built_in">List</span>&lt;<span class="hljs-built_in">String</span>&gt;&gt; s = ArrayList::<span class="hljs-keyword">new</span>;<span class="hljs-built_in">List</span>&lt;<span class="hljs-built_in">String</span>&gt; l = s.<span class="hljs-keyword">get</span>();</code></pre><p><strong>带参构造</strong></p><pre><code class="hljs lasso"><span class="hljs-comment">// Using a anonymous class</span>BiFunction&lt;<span class="hljs-built_in">String</span>, <span class="hljs-built_in">String</span>, <span class="hljs-built_in">Locale</span>&gt; f = <span class="hljs-literal">new</span> BiFunction&lt;<span class="hljs-built_in">String</span>, <span class="hljs-built_in">String</span>, <span class="hljs-built_in">Locale</span>&gt;() &#123;  <span class="hljs-keyword">public</span> <span class="hljs-built_in">Locale</span> apply(<span class="hljs-built_in">String</span> lang, <span class="hljs-built_in">String</span> country) &#123;    <span class="hljs-keyword">return</span> <span class="hljs-literal">new</span> <span class="hljs-built_in">Locale</span>(lang, country);  &#125;&#125;;<span class="hljs-built_in">Locale</span> loc = f.apply(<span class="hljs-string">"en"</span>,<span class="hljs-string">"UK"</span>);<span class="hljs-comment">// Using a lambda expression</span>BiFunction&lt;<span class="hljs-built_in">String</span>, <span class="hljs-built_in">String</span>, <span class="hljs-built_in">Locale</span>&gt; f = (lang, country) -&gt; <span class="hljs-literal">new</span> <span class="hljs-built_in">Locale</span>(lang, country);<span class="hljs-built_in">Locale</span> loc = f.apply(<span class="hljs-string">"en"</span>,<span class="hljs-string">"UK"</span>);<span class="hljs-comment">// Using a method reference</span>BiFunction&lt;<span class="hljs-built_in">String</span>, <span class="hljs-built_in">String</span>, <span class="hljs-built_in">Locale</span>&gt; f = <span class="hljs-built_in">Locale</span><span class="hljs-type">::new</span>;<span class="hljs-built_in">Locale</span> loc = f.apply(<span class="hljs-string">"en"</span>,<span class="hljs-string">"UK"</span>);</code></pre><p>如果有三个及以上的参数的构造函数，则必须创建自己的函数接口。引用构造函数与引用静态方法非常相似，区别在于构造函数“方法名称”是new。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>如果使用了方法引用之后能让代码变的更加整洁，就使用它。实际使用中，一种使用方式是将代码包裹在一个方法中，而非使用一个单独的类或者lambda表达式，然后使用方法引用的方式进行调用。方法引用常用于java8的另一种新特性Streams中，而基于方法引用的设计模式也会更加具有拓展性。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;什么是方法引用&quot;&gt;&lt;a href=&quot;#什么是方法引用&quot; class=&quot;headerlink&quot; title=&quot;什么是方法引用?&quot;&gt;&lt;/a&gt;什么是方法引用?&lt;/h2&gt;&lt;p&gt;方法引用可用于在不调用方法的情况下引用方法。它将方法视为Lambda表达式。它们只能作为语法糖来
      
    
    </summary>
    
    
      <category term="java" scheme="http://yoursite.com/categories/java/"/>
    
    
      <category term="stream" scheme="http://yoursite.com/tags/stream/"/>
    
  </entry>
  
  <entry>
    <title>java8新特性之Stream</title>
    <link href="http://yoursite.com/2020/05/31/java8%E6%96%B0%E7%89%B9%E6%80%A7%E4%B9%8BStream/"/>
    <id>http://yoursite.com/2020/05/31/java8%E6%96%B0%E7%89%B9%E6%80%A7%E4%B9%8BStream/</id>
    <published>2020-05-31T04:07:12.000Z</published>
    <updated>2020-05-31T04:09:19.626Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>Stream API与InputStream和OutputStream是完全不同的概念，<strong>Stream API是对Java中集合操作的增强，可以利用它进行各种过滤、排序、分组、聚合等操作</strong>。Stream API配合Lambda表达式可以加大的提高代码可读性和编码效率，Stream API也支持并行操作。</p><h3 id="流不是集合，它不关心数据的存放，只关注如何处理数据"><a href="#流不是集合，它不关心数据的存放，只关注如何处理数据" class="headerlink" title="流不是集合，它不关心数据的存放，只关注如何处理数据"></a>流不是集合，它不关心数据的存放，只关注如何处理数据</h3><p>Stream API主要用于处理集合操作，不过它的处理方式与传统的方式不同，称为“数据流处理”。流（Stream）类似于关系数据库的查询操作，是一种声明式操作。比如要从数据库中获取所有年龄大于20岁的用户的名称，并按照用户的创建时间进行排序，用一条SQL语句就可以搞定，不过使用Java程序实现就会显得有些繁琐，这时候可以使用流：</p><pre><code class="hljs lasso"><span class="hljs-built_in">List</span>&lt;<span class="hljs-built_in">String</span>&gt; userNames = users.stream()    .filter(user -&gt; user.getAge() &gt; <span class="hljs-number">20</span>)    .sorted(comparing(User<span class="hljs-type">::getCreationDate</span>))    .<span class="hljs-built_in">map</span>(User<span class="hljs-type">::getUserName</span>)    .collect(toList());</code></pre><p>在Java中，集合是一种数据结构，或者说是一种容器，用于存放数据，流不是容器，它不关心数据的存放，只关注如何处理。可以把流当做是Java中的Iterator，不过它比Iterator强大多了。</p><h3 id="流使用内部迭代方式处理数据"><a href="#流使用内部迭代方式处理数据" class="headerlink" title="流使用内部迭代方式处理数据"></a>流使用内部迭代方式处理数据</h3><p>流与集合另一个区别在于他们的遍历方式，遍历集合通常使用for-each方式，这种方式称为外部迭代，而流使用内部迭代方式，也就是说它帮你把迭代的工作做了，你只需要给出一个函数来告诉它接下来要干什么：</p><pre><code class="hljs reasonml"><span class="hljs-comment">// 外部迭代</span>List&lt;String&gt; <span class="hljs-built_in">list</span> = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Arrays</span>.</span></span><span class="hljs-keyword">as</span><span class="hljs-constructor">List(<span class="hljs-string">"A"</span>, <span class="hljs-string">"B"</span>, <span class="hljs-string">"C"</span>, <span class="hljs-string">"D"</span>)</span>;for (String str : <span class="hljs-built_in">list</span>) &#123;    <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(str);&#125;<span class="hljs-comment">// 内部迭代</span><span class="hljs-built_in">list</span>.stream<span class="hljs-literal">()</span>.for<span class="hljs-constructor">Each(System.<span class="hljs-params">out</span>::<span class="hljs-params">println</span>)</span>;</code></pre><p>外部迭代更像是作文题，我们不仅要控制元素的迭代方式，还需要定义怎么操作元素；内部迭代更像是填空题，我们只用关注如何操作元素就可以了。</p><h3 id="流只能遍历一次"><a href="#流只能遍历一次" class="headerlink" title="流只能遍历一次"></a>流只能遍历一次</h3><p>流只能遍历一次，遍历结束后，这个流就被关闭掉了。如果要重新遍历，可以从数据源（集合）中重新获取一个流。如果你对一个流遍历两次，就会抛出java.lang.IllegalStateException异常：</p><pre><code class="hljs reasonml">List&lt;String&gt; <span class="hljs-built_in">list</span> = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Arrays</span>.</span></span><span class="hljs-keyword">as</span><span class="hljs-constructor">List(<span class="hljs-string">"A"</span>, <span class="hljs-string">"B"</span>, <span class="hljs-string">"C"</span>, <span class="hljs-string">"D"</span>)</span>;Stream&lt;String&gt; stream = <span class="hljs-built_in">list</span>.stream<span class="hljs-literal">()</span>;stream.for<span class="hljs-constructor">Each(System.<span class="hljs-params">out</span>::<span class="hljs-params">println</span>)</span>;stream.for<span class="hljs-constructor">Each(System.<span class="hljs-params">out</span>::<span class="hljs-params">println</span>)</span>; <span class="hljs-comment">// 这里会抛出java.lang.IllegalStateException异常，因为流已经被关闭</span></code></pre><h3 id="流通常由三部分构成："><a href="#流通常由三部分构成：" class="headerlink" title="流通常由三部分构成："></a>流通常由三部分构成：</h3><ol><li>数据源：数据源一般用于流的获取，比如本文开头那个过滤用户的例子中users.stream()方法。</li><li>中间处理：中间处理包括对流中元素的一系列处理，如：过滤（filter()），映射（map()），排序（sorted()）。</li><li>终端处理：终端处理会生成结果，结果可以是任何不是流值，如List<String>；也可以不返回结果，如stream.forEach(System.out::println)就是将结果打印到控制台中，并没有返回。</li></ol><h2 id="创建流"><a href="#创建流" class="headerlink" title="创建流"></a>创建流</h2><h3 id="由值创建流"><a href="#由值创建流" class="headerlink" title="由值创建流"></a>由值创建流</h3><p>使用静态方法Stream.of()创建流，该方法接收一个变长参数：</p><pre><code class="hljs arduino"><span class="hljs-built_in">Stream</span>&lt;<span class="hljs-built_in">Stream</span>&gt; stream = <span class="hljs-built_in">Stream</span>.of(<span class="hljs-string">"A"</span>, <span class="hljs-string">"B"</span>, <span class="hljs-string">"C"</span>, <span class="hljs-string">"D"</span>);<span class="hljs-comment">//也可以使用静态方法Stream.empty()创建一个空的流：</span><span class="hljs-built_in">Stream</span>&lt;<span class="hljs-built_in">Stream</span>&gt; stream = <span class="hljs-built_in">Stream</span>.empty();</code></pre><h3 id="由数组、集合-创建流"><a href="#由数组、集合-创建流" class="headerlink" title="由数组、集合 创建流"></a>由数组、集合 创建流</h3><p>使用静态方法Arrays.stream()从数组创建一个流，该方法接收一个数组参数：</p><pre><code class="hljs armasm"><span class="hljs-keyword">String[] </span><span class="hljs-keyword">strs </span>= &#123;<span class="hljs-string">"A"</span>, <span class="hljs-string">"B"</span>, <span class="hljs-string">"C"</span>, <span class="hljs-string">"D"</span>&#125;<span class="hljs-comment">;</span><span class="hljs-keyword">Stream&lt;Stream&gt; </span><span class="hljs-keyword">stream </span>= Arrays.<span class="hljs-keyword">stream(strs);</span></code></pre><h3 id="通过文件生成流"><a href="#通过文件生成流" class="headerlink" title="通过文件生成流"></a>通过文件生成流</h3><p>使用java.nio.file.Files类中的很多静态方法都可以获取流，比如Files.lines()方法，该方法接收一个java.nio.file.Path对象，返回一个由文件行构成的字符串流：</p><pre><code class="hljs reasonml">Stream&lt;String&gt; stream = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Files</span>.</span></span>lines(<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Paths</span>.</span></span>get(<span class="hljs-string">"text.txt"</span>), <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Charset</span>.</span></span>default<span class="hljs-constructor">Charset()</span>);</code></pre><h3 id="通过函数创建流"><a href="#通过函数创建流" class="headerlink" title="通过函数创建流"></a>通过函数创建流</h3><p>java.util.stream.Stream中有两个静态方法用于从函数生成流，他们分别是Stream.generate()和Stream.iterate()：</p><pre><code class="hljs reasonml"><span class="hljs-comment">// iteartor 打印100以内的所有偶数</span><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Stream</span>.</span></span>iterate(<span class="hljs-number">0</span>, n -&gt; n + <span class="hljs-number">2</span>).limit(<span class="hljs-number">51</span>).for<span class="hljs-constructor">Each(System.<span class="hljs-params">out</span>::<span class="hljs-params">println</span>)</span>;<span class="hljs-comment">// generate 打印10个Hello Man!</span><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Stream</span>.</span></span>generate(<span class="hljs-literal">()</span> -&gt; <span class="hljs-string">"Hello Man!"</span>).limit(<span class="hljs-number">10</span>).for<span class="hljs-constructor">Each(System.<span class="hljs-params">out</span>::<span class="hljs-params">println</span>)</span>;</code></pre><p>值得注意的是，这两个方法生成的流都是无限流，没有固定大小，可以无穷的计算下去，可以使用limit()来限制边界。</p><pre><code class="hljs reasonml"><span class="hljs-comment">//一般来说，iterate()用于生成一系列值，比如生成以当前时间开始之后的10天的日期：</span><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Stream</span>.</span></span>iterate(<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">LocalDate</span>.</span></span>now<span class="hljs-literal">()</span>, date -&gt; date.plus<span class="hljs-constructor">Days(1)</span>).limit(<span class="hljs-number">10</span>).for<span class="hljs-constructor">Each(System.<span class="hljs-params">out</span>::<span class="hljs-params">println</span>)</span>;<span class="hljs-comment">//generate()方法用于生成一些随机数，比如生成10个UUID：</span><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Stream</span>.</span></span>generate(<span class="hljs-literal">()</span> -&gt; <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">UUID</span>.</span></span>random<span class="hljs-constructor">UUID()</span>.<span class="hljs-keyword">to</span><span class="hljs-constructor">String()</span>).limit(<span class="hljs-number">10</span>).for<span class="hljs-constructor">Each(System.<span class="hljs-params">out</span>::<span class="hljs-params">println</span>)</span>;</code></pre><h3 id="collect-toList-将流中的值转换为集合"><a href="#collect-toList-将流中的值转换为集合" class="headerlink" title="collect(toList())将流中的值转换为集合"></a>collect(toList())将流中的值转换为集合</h3><pre><code class="hljs reasonml"><span class="hljs-comment">//of从初识值生成新的stream，再通过collect(toList())生成新的集合</span>List&lt;String&gt; collect = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Stream</span>.</span></span><span class="hljs-keyword">of</span>(<span class="hljs-string">"aa"</span>, <span class="hljs-string">"bb"</span>, <span class="hljs-string">"cc"</span>, <span class="hljs-string">"aa"</span>, <span class="hljs-string">"bb"</span>).collect(<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Collectors</span>.</span></span><span class="hljs-keyword">to</span><span class="hljs-constructor">List()</span>);</code></pre><p>of是惰性求值，不生成新的集合，通过collect(toList())这种及早求值才生成新的集合。返回值是stream就是惰性求值，返回值为另一个值或者空就是及早求值。</p><h3 id="惰性求值与及早求值的区别"><a href="#惰性求值与及早求值的区别" class="headerlink" title="惰性求值与及早求值的区别"></a>惰性求值与及早求值的区别</h3><pre><code class="hljs processing"><span class="hljs-comment">//如下加count就是及早求值，会sout输出strs。不加count，程序不输出任何信息</span>strs.stream().<span class="hljs-built_in">filter</span>(<span class="hljs-built_in">str</span> -&gt; &#123;    System.out.<span class="hljs-built_in">println</span>(<span class="hljs-built_in">str</span>);    <span class="hljs-keyword">return</span> <span class="hljs-built_in">str</span>.startsWith(<span class="hljs-string">"a"</span>);&#125;).count();</code></pre><p>过滤+计数，只循环了一次。只执行fileter会返回一个stream，他不是一个新集合，仅仅是创建新集合的配方。</p><h2 id="流常用方法"><a href="#流常用方法" class="headerlink" title="流常用方法"></a>流常用方法</h2><h3 id="过滤和排序"><a href="#过滤和排序" class="headerlink" title="过滤和排序"></a>过滤和排序</h3><pre><code class="hljs angelscript">Stream.of(<span class="hljs-number">1</span>, <span class="hljs-number">8</span>, <span class="hljs-number">5</span>, <span class="hljs-number">2</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">9</span>, <span class="hljs-number">2</span>, <span class="hljs-number">0</span>, <span class="hljs-number">4</span>, <span class="hljs-number">8</span>)    .filter(n -&gt; n &gt; <span class="hljs-number">2</span>)     <span class="hljs-comment">// 对元素过滤，保留大于2的元素</span>    .distinct()             <span class="hljs-comment">// 去重，类似于SQL语句中的DISTINCT</span>    .skip(<span class="hljs-number">1</span>)                <span class="hljs-comment">// 跳过前面1个元素</span>    .limit(<span class="hljs-number">2</span>)               <span class="hljs-comment">// 返回开头2个元素，类似于SQL语句中的SELECT TOP</span>    .sorted()               <span class="hljs-comment">// 对结果排序</span>    .forEach(System.<span class="hljs-keyword">out</span>::println);</code></pre><p>filter 对集合的值进行过滤，必须返回true或者false</p><h3 id="查找和匹配"><a href="#查找和匹配" class="headerlink" title="查找和匹配"></a>查找和匹配</h3><pre><code class="hljs reasonml"><span class="hljs-comment">//检查流中的任意元素是否包含字符串"PHP"</span>boolean match1 = get<span class="hljs-constructor">Stream()</span>.any<span class="hljs-constructor">Match(<span class="hljs-params">s</span> -&gt; <span class="hljs-params">s</span>.<span class="hljs-params">equals</span>(<span class="hljs-string">"PHP"</span>)</span>);<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(match1);boolean match2 = get<span class="hljs-constructor">Stream()</span>.collect(<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Collectors</span>.</span></span><span class="hljs-keyword">to</span><span class="hljs-constructor">List()</span>).contains(<span class="hljs-string">"PHP"</span>);<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(match2);<span class="hljs-comment">// 检查流中的所有元素是否都包含字符串"#"</span>boolean hasAllMatch = get<span class="hljs-constructor">Stream()</span>.all<span class="hljs-constructor">Match(<span class="hljs-params">s</span> -&gt; <span class="hljs-params">s</span>.<span class="hljs-params">contains</span>(<span class="hljs-string">"#"</span>)</span>);<span class="hljs-comment">// 检查流中的任意元素是否没有以"C"开头的字符串</span>boolean hasNoneMatch = get<span class="hljs-constructor">Stream()</span>.none<span class="hljs-constructor">Match(<span class="hljs-params">s</span> -&gt; <span class="hljs-params">s</span>.<span class="hljs-params">startsWith</span>(<span class="hljs-string">"C"</span>)</span>);<span class="hljs-comment">// 查找元素</span>Optional&lt;String&gt; element = get<span class="hljs-constructor">Stream()</span>.ilter(s -&gt; s.contains(<span class="hljs-string">"C"</span>))    <span class="hljs-comment">// .findFirst()     // 查找第一个元素</span>    .find<span class="hljs-constructor">Any()</span>;         <span class="hljs-comment">// 查找任意元素</span> <span class="hljs-comment">//获取初始流   </span><span class="hljs-keyword">private</span> static Stream&lt;String&gt; get<span class="hljs-constructor">Stream()</span> &#123;    return <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Stream</span>.</span></span><span class="hljs-keyword">of</span>(<span class="hljs-string">"Java"</span>, <span class="hljs-string">"C#"</span>, <span class="hljs-string">"PHP"</span>, <span class="hljs-string">"C++"</span>, <span class="hljs-string">"Python"</span>);&#125;</code></pre><ol><li>每次都需要重新getStream()来获取新的流，因为之前的流已经使用并且关闭了。可以理解为若返回值不是stream，则表示已经结束了流操作</li><li>findAny的返回类型是一个Optional<T>类（java.util.Optional），它一个容器类，代表一个值存在或不存在，用来避免控制正异常。</li><li>findFirst()和findAny()返回的都是第一个元素，通过查看javadoc描述，大致意思是findAny()是为了提高并行操作时的性能。数据大时可findany。</li></ol><h3 id="归约"><a href="#归约" class="headerlink" title="归约"></a>归约</h3><p>归约操作就是将流中的元素进行合并，形成一个新的值，常见的归约操作包括求和，求最大值或最小值。归约操作一般使用reduce()方法，与map()方法搭配使用，可以处理一些很复杂的归约操作。</p><pre><code class="hljs lasso"><span class="hljs-comment">// 获取流</span><span class="hljs-built_in">List</span>&lt;Book&gt; books = Arrays.asList(   <span class="hljs-literal">new</span> Book(<span class="hljs-string">"Java编程思想"</span>, <span class="hljs-string">"Bruce Eckel"</span>, <span class="hljs-string">"机械工业出版社"</span>, <span class="hljs-number">108.00</span>D),   <span class="hljs-literal">new</span> Book(<span class="hljs-string">"Java 8实战"</span>, <span class="hljs-string">"Mario Fusco"</span>, <span class="hljs-string">"人民邮电出版社"</span>, <span class="hljs-number">79.00</span>D),   <span class="hljs-literal">new</span> Book(<span class="hljs-string">"MongoDB权威指南（第2版）"</span>, <span class="hljs-string">"Kristina Chodorow"</span>, <span class="hljs-string">"人民邮电出版社"</span>, <span class="hljs-number">69.00</span>D));<span class="hljs-comment">// 计算所有图书的总价</span>Optional&lt;Double&gt; totalPrice = books.stream()       .<span class="hljs-built_in">map</span>(Book<span class="hljs-type">::getPrice</span>)       .reduce((n, m) -&gt; n + m);<span class="hljs-comment">// 价格最高的图书</span>Optional&lt;Book&gt; expensive = books.stream().<span class="hljs-keyword">max</span>(Comparator.comparing(Book<span class="hljs-type">::getPrice</span>));<span class="hljs-comment">// 价格最低的图书</span>Optional&lt;Book&gt; cheapest = books.stream().<span class="hljs-keyword">min</span>(Comparator.comparing(Book<span class="hljs-type">::getPrice</span>));<span class="hljs-comment">// 计算总数</span>long count = books.stream().count()</code></pre><h3 id="reduce从一组值中生成一个值，如累加。"><a href="#reduce从一组值中生成一个值，如累加。" class="headerlink" title="reduce从一组值中生成一个值，如累加。"></a>reduce从一组值中生成一个值，如累加。</h3><pre><code class="hljs angelscript"><span class="hljs-comment">//0初始值，total总值，index循环的每一个值。</span>Integer num = Stream.of(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>).reduce(<span class="hljs-number">0</span>, (total, index) -&gt; total + index);</code></pre><h3 id="max-min-传入comparator进行大小比较，返回Optional对象"><a href="#max-min-传入comparator进行大小比较，返回Optional对象" class="headerlink" title="max(min) 传入comparator进行大小比较，返回Optional对象"></a>max(min) 传入comparator进行大小比较，返回Optional对象</h3><pre><code class="hljs maxima">//Optional对象(代表一个可能存在也可能不存在的值，NPE方案),通过<span class="hljs-built_in">get</span>拿到Optional对象中的值Integer <span class="hljs-built_in">integer</span> = Stream.of(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>).<span class="hljs-built_in">min</span>(Comparator.comparing(<span class="hljs-built_in">num</span> -&gt; <span class="hljs-built_in">num</span>)).<span class="hljs-built_in">get</span>();</code></pre><h3 id="map-将流中的值转换为新值"><a href="#map-将流中的值转换为新值" class="headerlink" title="map 将流中的值转换为新值"></a>map 将流中的值转换为新值</h3><pre><code class="hljs reasonml"><span class="hljs-comment">//将list小写处理成大写</span><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Stream</span>.</span></span><span class="hljs-keyword">of</span>(<span class="hljs-string">"aa"</span>, <span class="hljs-string">"bb"</span>, <span class="hljs-string">"cc"</span>, <span class="hljs-string">"aa"</span>, <span class="hljs-string">"bb"</span>).map(str -&gt; str.<span class="hljs-keyword">to</span><span class="hljs-constructor">UpperCase()</span>).collect(<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Collectors</span>.</span></span><span class="hljs-keyword">to</span><span class="hljs-constructor">List()</span>);</code></pre><h3 id="flatmap-把多个stream合并成一个stream并返回"><a href="#flatmap-把多个stream合并成一个stream并返回" class="headerlink" title="flatmap 把多个stream合并成一个stream并返回"></a>flatmap 把多个stream合并成一个stream并返回</h3><p>与map()方法类似的还有一个flatMap()，flatMap()方法让你把一个流中的每个值都换成另一个流，然后把所有的流连接起来成为一个新的流。</p><pre><code class="hljs reasonml"><span class="hljs-comment">//传统for循环</span>List&lt;String&gt; names0 = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;<span class="hljs-literal">()</span>;for (Company company : data) &#123;    List&lt;User&gt; users = company.get<span class="hljs-constructor">Uesrs()</span>;    for (User user : users) &#123;        <span class="hljs-keyword">if</span> (user.get<span class="hljs-constructor">Age()</span> &gt; <span class="hljs-number">30</span>) &#123;            names0.add(user.get<span class="hljs-constructor">Name()</span>);        &#125;    &#125;&#125;<span class="hljs-comment">//lambda方式1</span>List&lt;String&gt; names1 = data.stream<span class="hljs-literal">()</span>    .flat<span class="hljs-constructor">Map(<span class="hljs-params">company</span> -&gt; <span class="hljs-params">company</span>.<span class="hljs-params">getUesrs</span>()</span>.stream<span class="hljs-literal">()</span>)    .filter(user -&gt; user.get<span class="hljs-constructor">Age()</span> &gt; <span class="hljs-number">30</span>)    .map(user -&gt; user.get<span class="hljs-constructor">Name()</span>)    .collect(<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Collectors</span>.</span></span><span class="hljs-keyword">to</span><span class="hljs-constructor">List()</span>);<span class="hljs-comment">//lambda方式2</span>List&lt;String&gt; names2 = data.stream<span class="hljs-literal">()</span>    .map(Company::getUesrs)    .flat<span class="hljs-constructor">Map(Collection::<span class="hljs-params">stream</span>)</span>    .filter(user -&gt; user.get<span class="hljs-constructor">Age()</span> &gt; <span class="hljs-number">30</span>)    .map(User::getName)    .collect(<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Collectors</span>.</span></span><span class="hljs-keyword">to</span><span class="hljs-constructor">List()</span>);</code></pre><p>使用flatMap()方法的效果是，各个数组并不是分别映射成一个流，而是映射成流的内容。所有使用map(Arrays::stream)时生成的单个流都被合并起来，也就是对流扁平化操作。</p><h3 id="peek-用于记录中间值（输出流中的值），不会改变流。一般用作日志输出，断点调试。"><a href="#peek-用于记录中间值（输出流中的值），不会改变流。一般用作日志输出，断点调试。" class="headerlink" title="peek 用于记录中间值（输出流中的值），不会改变流。一般用作日志输出，断点调试。"></a>peek 用于记录中间值（输出流中的值），不会改变流。一般用作日志输出，断点调试。</h3><pre><code class="hljs reasonml">List&lt;Integer&gt; nums = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Stream</span>.</span></span><span class="hljs-keyword">of</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>).collect(<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Collectors</span>.</span></span><span class="hljs-keyword">to</span><span class="hljs-constructor">List()</span>);nums.stream<span class="hljs-literal">()</span>.filter(num -&gt; num &gt; <span class="hljs-number">3</span>).peek(num -&gt; &#123;    <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(num);&#125;).collect(<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Collectors</span>.</span></span><span class="hljs-keyword">to</span><span class="hljs-constructor">List()</span>);</code></pre><h2 id="数据收集"><a href="#数据收集" class="headerlink" title="数据收集"></a>数据收集</h2><p>前面总结了如何创建流以及流处理，接下来总结下数据收集。数据收集是流式数据处理的终端处理，<strong>与中间处理不同的是，终端处理会消耗流，也就是说，终端处理之后，这个流就会被关闭，如果再进行中间处理，就会抛出异常</strong>。数据收集主要使用collect方法，该方法也属于归约操作，像reduce()方法那样可以接收各种做法作为参数，将流中的元素累积成一个汇总结果，具体的做法是通过定义新的Collector接口来定义的。</p><h3 id="可以静态导入Collectors和Comparator两个类，这样就不用再去写Collectors-counting-和Comparator-comparing-。"><a href="#可以静态导入Collectors和Comparator两个类，这样就不用再去写Collectors-counting-和Comparator-comparing-。" class="headerlink" title="可以静态导入Collectors和Comparator两个类，这样就不用再去写Collectors.counting()和Comparator.comparing()。"></a>可以静态导入Collectors和Comparator两个类，这样就不用再去写Collectors.counting()和Comparator.comparing()。</h3><pre><code class="hljs gradle"><span class="hljs-keyword">import</span> <span class="hljs-keyword">static</span> java.util.stream.Collectors.*;<span class="hljs-keyword">import</span> <span class="hljs-keyword">static</span> java.util.Comparator.*;<span class="hljs-comment">// 求和</span><span class="hljs-keyword">long</span> <span class="hljs-keyword">count</span> = books.stream().<span class="hljs-keyword">collect</span>(counting());<span class="hljs-comment">// 价格最高的图书</span>Optional&lt;Book&gt; expensive = books.stream().<span class="hljs-keyword">collect</span>(maxBy(comparing(Book::getPrice)));<span class="hljs-comment">// 价格最低的图书</span>Optional&lt;Book&gt; cheapest = books.stream().<span class="hljs-keyword">collect</span>(minBy(comparing(Book::getPrice)));</code></pre><h3 id="收集顺序"><a href="#收集顺序" class="headerlink" title="收集顺序"></a>收集顺序</h3><pre><code class="hljs plain">进有序，出有序；进无序，出无序。</code></pre><h3 id="特定收集器"><a href="#特定收集器" class="headerlink" title="特定收集器"></a>特定收集器</h3><pre><code class="hljs reasonml">stream.collect(<span class="hljs-keyword">to</span><span class="hljs-constructor">Collection(TreeSet::<span class="hljs-params">new</span>)</span>);</code></pre><h3 id="字符串操作joining"><a href="#字符串操作joining" class="headerlink" title="字符串操作joining"></a>字符串操作joining</h3><pre><code class="hljs reasonml"><span class="hljs-comment">//将流中的字符串通过逗号连接成一个新的字符串</span>String str = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Stream</span>.</span></span><span class="hljs-keyword">of</span>(<span class="hljs-string">"A"</span>, <span class="hljs-string">"B"</span>, <span class="hljs-string">"C"</span>, <span class="hljs-string">"D"</span>).collect(joining(<span class="hljs-string">","</span>));List&lt;Integer&gt; data = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Stream</span>.</span></span><span class="hljs-keyword">of</span>(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>).collect(<span class="hljs-keyword">to</span><span class="hljs-constructor">List()</span>);List&lt;Integer&gt; integers = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Arrays</span>.</span></span><span class="hljs-keyword">as</span><span class="hljs-constructor">List(1, 2, 3, 4, 5)</span>;<span class="hljs-comment">//前后缀拼接</span><span class="hljs-comment">//传统for循环</span>StringBuilder sb = <span class="hljs-keyword">new</span> <span class="hljs-constructor">StringBuilder(<span class="hljs-string">"["</span>)</span>;for (Integer num : integers) &#123;    sb.append(num).append(<span class="hljs-string">", "</span>);&#125;sb.append(<span class="hljs-string">"]"</span>);<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(sb);<span class="hljs-comment">//lambda循环（map是为了将int转为string）</span>String str = data.stream<span class="hljs-literal">()</span>.map(String::valueOf).collect(joining(<span class="hljs-string">","</span>, <span class="hljs-string">"["</span>, <span class="hljs-string">"]"</span>));<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(str);</code></pre><h3 id="数据分块（parttitioningBy，将流分解成两个集合），传入一个pridicate对象来判断属于哪部分。"><a href="#数据分块（parttitioningBy，将流分解成两个集合），传入一个pridicate对象来判断属于哪部分。" class="headerlink" title="数据分块（parttitioningBy，将流分解成两个集合），传入一个pridicate对象来判断属于哪部分。"></a>数据分块（parttitioningBy，将流分解成两个集合），传入一个pridicate对象来判断属于哪部分。</h3><pre><code class="hljs pgsql">//数据分块：将数据分成<span class="hljs-keyword">true</span>和<span class="hljs-keyword">false</span>两部分Map&lt;<span class="hljs-type">Boolean</span>, List&lt;<span class="hljs-keyword">User</span>&gt;&gt; res = users.stream().collect(partitioningBy(<span class="hljs-keyword">user</span> -&gt; <span class="hljs-keyword">user</span>.getName().length() &gt; <span class="hljs-number">3</span>));</code></pre><h3 id="数据分组（groupingBy）"><a href="#数据分组（groupingBy）" class="headerlink" title="数据分组（groupingBy）"></a>数据分组（groupingBy）</h3><pre><code class="hljs lasso"><span class="hljs-comment">//数据分组：将数据以某个key值分成多部分</span><span class="hljs-built_in">Map</span>&lt;<span class="hljs-built_in">String</span>, <span class="hljs-built_in">List</span>&lt;User&gt;&gt; result = users.stream().collect(groupingBy(user -&gt; user.getAddress()));<span class="hljs-built_in">Map</span>&lt;<span class="hljs-built_in">String</span>, <span class="hljs-built_in">List</span>&lt;User&gt;&gt; result = users.stream().collect(groupingBy(User<span class="hljs-type">::getAddress</span>));</code></pre><h3 id="组合收集器（下游收集器），在主收集器中应用下级收集器，对结果进行再次封装。"><a href="#组合收集器（下游收集器），在主收集器中应用下级收集器，对结果进行再次封装。" class="headerlink" title="组合收集器（下游收集器），在主收集器中应用下级收集器，对结果进行再次封装。"></a>组合收集器（下游收集器），在主收集器中应用下级收集器，对结果进行再次封装。</h3><pre><code class="hljs reasonml"><span class="hljs-comment">//将数据分组后，不是返回每组的数据，而是统计每组的个数返回。</span>Map&lt;String, Long&gt; collect1 = users.stream<span class="hljs-literal">()</span>.collect(grouping<span class="hljs-constructor">By(User::<span class="hljs-params">getName</span>, <span class="hljs-params">counting</span>()</span>));<span class="hljs-comment">//通过mapping可以进行其他二次收集。</span>Map&lt;String, List&lt;String&gt;&gt; collect2 = users.stream<span class="hljs-literal">()</span>.collect(grouping<span class="hljs-constructor">By(User::<span class="hljs-params">getAddress</span>, <span class="hljs-params">mapping</span>(User::<span class="hljs-params">getName</span>, <span class="hljs-params">toList</span>()</span>) ));函数拆分示例：collect( grouping<span class="hljs-constructor">By(<span class="hljs-params">key1</span>,  <span class="hljs-params">mapping</span>(<span class="hljs-params">key2</span>,  <span class="hljs-params">value</span>)</span>  )  )</code></pre><h2 id="进阶集合操作"><a href="#进阶集合操作" class="headerlink" title="进阶集合操作"></a>进阶集合操作</h2><h3 id="map的foreach循环"><a href="#map的foreach循环" class="headerlink" title="map的foreach循环"></a>map的foreach循环</h3><pre><code class="hljs lasso"><span class="hljs-built_in">Map</span>&lt;<span class="hljs-built_in">String</span>, <span class="hljs-built_in">Integer</span>&gt; <span class="hljs-keyword">cache</span> = <span class="hljs-literal">new</span> HashMap&lt;&gt;();<span class="hljs-built_in">Map</span>&lt;<span class="hljs-built_in">String</span>, <span class="hljs-built_in">List</span>&lt;User&gt;&gt; users = <span class="hljs-literal">new</span> HashMap&lt;<span class="hljs-built_in">String</span>, <span class="hljs-built_in">List</span>&lt;User&gt;&gt;();<span class="hljs-comment">//传统for循环</span>for (<span class="hljs-built_in">Map</span>.Entry&lt;<span class="hljs-built_in">String</span>, <span class="hljs-built_in">List</span>&lt;User&gt;&gt; entry : users.entrySet()) &#123;    <span class="hljs-built_in">String</span> key = entry.getKey();    <span class="hljs-built_in">List</span>&lt;User&gt; value = entry.getValue();    <span class="hljs-keyword">cache</span>.put(key, value.size());&#125;<span class="hljs-comment">//lambda方式</span>users.forEach((key, value) -&gt; &#123;    <span class="hljs-keyword">cache</span>.put(key, value.size());&#125;);</code></pre><h3 id="computeIfAbsent"><a href="#computeIfAbsent" class="headerlink" title="computeIfAbsent"></a>computeIfAbsent</h3><p>根据key获取某个值，若值不存在，丛数据库中取</p><pre><code class="hljs pgsql">//传统方式<span class="hljs-built_in">public</span> List&lt;<span class="hljs-keyword">User</span>&gt; getUserByName(String <span class="hljs-type">name</span>) &#123;    List&lt;<span class="hljs-keyword">User</span>&gt; <span class="hljs-keyword">user</span> = users.<span class="hljs-keyword">get</span>(<span class="hljs-type">name</span>);    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">user</span> == <span class="hljs-keyword">null</span>) &#123;        <span class="hljs-keyword">user</span> = readFromDB(<span class="hljs-type">name</span>);        users.put(<span class="hljs-type">name</span>, <span class="hljs-keyword">user</span>);    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-keyword">user</span>;&#125;//lambda方式<span class="hljs-built_in">public</span> List&lt;<span class="hljs-keyword">User</span>&gt; getUser1ByName(String <span class="hljs-type">name</span>) &#123;    <span class="hljs-keyword">return</span> users.computeIfAbsent(<span class="hljs-type">name</span>, this::readFromDB);&#125;private List&lt;<span class="hljs-keyword">User</span>&gt; readFromDB(String <span class="hljs-type">name</span>) &#123;    <span class="hljs-keyword">return</span> <span class="hljs-built_in">new</span> ArrayList&lt;&gt;();&#125;</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;p&gt;Stream API与InputStream和OutputStream是完全不同的概念，&lt;strong&gt;Stream API是对Java中集
      
    
    </summary>
    
    
      <category term="java" scheme="http://yoursite.com/categories/java/"/>
    
    
      <category term="stream" scheme="http://yoursite.com/tags/stream/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://yoursite.com/2020/05/31/hello-world/"/>
    <id>http://yoursite.com/2020/05/31/hello-world/</id>
    <published>2020-05-31T01:14:54.029Z</published>
    <updated>2020-05-31T01:14:54.029Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre><code class="hljs bash">$ hexo new <span class="hljs-string">"My New Post"</span></code></pre><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre><code class="hljs bash">$ hexo server</code></pre><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre><code class="hljs bash">$ hexo generate</code></pre><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre><code class="hljs bash">$ hexo deploy</code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.
      
    
    </summary>
    
    
    
  </entry>
  
</feed>

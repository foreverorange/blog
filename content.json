{"meta":{"title":"foreverorange","subtitle":"","description":"","author":"foreverorange","url":"http://yoursite.com","root":"/blog/"},"pages":[{"title":"about","date":"2020-02-23T11:20:33.000Z","updated":"2020-05-31T02:56:02.816Z","comments":true,"path":"about/index.html","permalink":"http://yoursite.com/about/index.html","excerpt":"","text":"这里写关于页的正文，支持 Markdown, HTML"}],"posts":[{"title":"ribbon源码分析","slug":"ribbon源码分析","date":"2020-06-15T12:55:28.000Z","updated":"2020-06-16T16:46:34.680Z","comments":true,"path":"2020/06/15/ribbon源码分析/","link":"","permalink":"http://yoursite.com/2020/06/15/ribbon%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/","excerpt":"","text":"一、@LoadBalanced注解唯一加的注解就是@LoadBalanced，如下所示 @Bean @LoadBalanced public RestTemplate restTemplate() &#123; return new RestTemplate(); &#125; 点进@LoadBalanced注解如下： /** * Annotation to mark a RestTemplate or WebClient bean to be configured to use a * LoadBalancerClient. * @author Spencer Gibb */ @Target(&#123; ElementType.FIELD, ElementType.PARAMETER, ElementType.METHOD &#125;) @Retention(RetentionPolicy.RUNTIME) @Documented @Inherited @Qualifier public @interface LoadBalanced &#123; &#125; 使用了@Qualifier注解进行限定标识 类注释意思是，该注解用于标记一个RestTemplate或者WebClient实例，它将会被配置成使用LoadBalancerClient 由此可以初步猜测，ribbon最终是通过LoadBalancerClient实现的客户端负载均衡。 二、jar包中META-INF/spring.factoriesorg.springframework.boot.autoconfigure.EnableAutoConfiguration=\\ org.springframework.cloud.netflix.ribbon.RibbonAutoConfiguration 声明了RibbonAutoConfiguration的自动配置类 1、ribbon自动配置 RibbonAutoConfiguration 点进去如下： /** * Auto configuration for Ribbon (client side load balancing). * * @author Spencer Gibb * @author Dave Syer * @author Biju Kunjummen */ @Configuration @Conditional(RibbonAutoConfiguration.RibbonClassesConditions.class) @RibbonClients @AutoConfigureAfter( name = \"org.springframework.cloud.netflix.eureka.EurekaClientAutoConfiguration\") @AutoConfigureBefore(&#123; LoadBalancerAutoConfiguration.class, AsyncLoadBalancerAutoConfiguration.class &#125;) @EnableConfigurationProperties(&#123; RibbonEagerLoadProperties.class, ServerIntrospectorProperties.class &#125;) public class RibbonAutoConfiguration &#123; ··· @Bean @ConditionalOnMissingBean(LoadBalancerClient.class) public LoadBalancerClient loadBalancerClient() &#123; return new RibbonLoadBalancerClient(springClientFactory()); &#125; @Bean @ConditionalOnMissingBean public SpringClientFactory springClientFactory() &#123; SpringClientFactory factory = new SpringClientFactory(); factory.setConfigurations(this.configurations); return factory; &#125; ··· public class SpringClientFactory extends NamedContextFactory&lt;RibbonClientSpecification&gt; &#123; static final String NAMESPACE = \"ribbon\"; public SpringClientFactory() &#123; super(RibbonClientConfiguration.class, NAMESPACE, \"ribbon.client.name\"); &#125; 可以看出，它声明了LoadBalancerClient的实例为RibbonLoadBalancerClient，在生成RibbonLoadBalancerClient时传入了springClientFactory()，其内部引入了RibbonClientConfiguration.class 2、ribbonClient实例配置/** * Ribbon client default connect timeout. */ public static final int DEFAULT_CONNECT_TIMEOUT = 1000; /** * Ribbon client default read timeout. */ public static final int DEFAULT_READ_TIMEOUT = 1000; /** * Ribbon client default Gzip Payload flag. */ public static final boolean DEFAULT_GZIP_PAYLOAD = true; @RibbonClientName private String name = \"client\"; // TODO: maybe re-instate autowired load balancers: identified by name they could be // associated with ribbon clients @Autowired private PropertiesFactory propertiesFactory; // 定义ribbonClientConfig的配置类 @Bean @ConditionalOnMissingBean public IClientConfig ribbonClientConfig() &#123; DefaultClientConfigImpl config = new DefaultClientConfigImpl(); config.loadProperties(this.name); config.set(CommonClientConfigKey.ConnectTimeout, DEFAULT_CONNECT_TIMEOUT); config.set(CommonClientConfigKey.ReadTimeout, DEFAULT_READ_TIMEOUT); config.set(CommonClientConfigKey.GZipPayload, DEFAULT_GZIP_PAYLOAD); return config; &#125; // 定义默认的负载均衡策略 @Bean @ConditionalOnMissingBean public IRule ribbonRule(IClientConfig config) &#123; if (this.propertiesFactory.isSet(IRule.class, name)) &#123; return this.propertiesFactory.get(IRule.class, config, name); &#125; ZoneAvoidanceRule rule = new ZoneAvoidanceRule(); rule.initWithNiwsConfig(config); return rule; &#125; // 定义默认的ping规则 @Bean @ConditionalOnMissingBean public IPing ribbonPing(IClientConfig config) &#123; if (this.propertiesFactory.isSet(IPing.class, name)) &#123; return this.propertiesFactory.get(IPing.class, config, name); &#125; return new DummyPing(); &#125; // 定义服务列表 @Bean @ConditionalOnMissingBean @SuppressWarnings(\"unchecked\") public ServerList&lt;Server&gt; ribbonServerList(IClientConfig config) &#123; if (this.propertiesFactory.isSet(ServerList.class, name)) &#123; return this.propertiesFactory.get(ServerList.class, config, name); &#125; ConfigurationBasedServerList serverList = new ConfigurationBasedServerList(); serverList.initWithNiwsConfig(config); return serverList; &#125; // 定义服务列表更新器 @Bean @ConditionalOnMissingBean public ServerListUpdater ribbonServerListUpdater(IClientConfig config) &#123; return new PollingServerListUpdater(config); &#125; // 定义负载均衡器，传入默认的rule和ping，生成ZoneAwareLoadBalancer默认负载均衡器 @Bean @ConditionalOnMissingBean public ILoadBalancer ribbonLoadBalancer(IClientConfig config, ServerList&lt;Server&gt; serverList, ServerListFilter&lt;Server&gt; serverListFilter, IRule rule, IPing ping, ServerListUpdater serverListUpdater) &#123; if (this.propertiesFactory.isSet(ILoadBalancer.class, name)) &#123; return this.propertiesFactory.get(ILoadBalancer.class, config, name); &#125; return new ZoneAwareLoadBalancer&lt;&gt;(config, rule, ping, serverList, serverListFilter, serverListUpdater); &#125; 3、负载均衡器自动配置 LoadBalancerAutoConfiguration 而在类的上方，使用了@AutoConfigureBefore({ LoadBalancerAutoConfiguration.class，点进去如下： /** * Auto-configuration for Ribbon (client-side load balancing). * * @author Spencer Gibb * @author Dave Syer * @author Will Tran * @author Gang Li */ @Configuration(proxyBeanMethods = false) @ConditionalOnClass(RestTemplate.class) @ConditionalOnBean(LoadBalancerClient.class) @EnableConfigurationProperties(LoadBalancerRetryProperties.class) public class LoadBalancerAutoConfiguration &#123; // 这里使用了@LoadBalanced注解进行限定，即只有被该注解标注的restTemplates才会被注入到list中 @LoadBalanced @Autowired(required = false) private List&lt;RestTemplate&gt; restTemplates = Collections.emptyList(); @Autowired(required = false) private List&lt;LoadBalancerRequestTransformer&gt; transformers = Collections.emptyList(); @Bean public SmartInitializingSingleton loadBalancedRestTemplateInitializerDeprecated( final ObjectProvider&lt;List&lt;RestTemplateCustomizer&gt;&gt; restTemplateCustomizers) &#123; // 这里返回了一个SmartInitializingSingleton实例 return () -&gt; restTemplateCustomizers.ifAvailable(customizers -&gt; &#123; // 循环限定注入的List&lt;RestTemplate&gt;，使用RestTemplateCustomizer进行定制 for (RestTemplate restTemplate : LoadBalancerAutoConfiguration.this.restTemplates) &#123; for (RestTemplateCustomizer customizer : customizers) &#123; customizer.customize(restTemplate); &#125; &#125; &#125;); &#125; ··· @Bean @ConditionalOnMissingBean public LoadBalancerRequestFactory loadBalancerRequestFactory( LoadBalancerClient loadBalancerClient) &#123; return new LoadBalancerRequestFactory(loadBalancerClient, this.transformers); &#125; @Configuration(proxyBeanMethods = false) @ConditionalOnMissingClass(\"org.springframework.retry.support.RetryTemplate\") static class LoadBalancerInterceptorConfig &#123; @Bean // 声明拦截器实例 public LoadBalancerInterceptor ribbonInterceptor( LoadBalancerClient loadBalancerClient, LoadBalancerRequestFactory requestFactory) &#123; return new LoadBalancerInterceptor(loadBalancerClient, requestFactory); &#125; @Bean @ConditionalOnMissingBean // 声明在SmartInitializingSingleton中用于定制的处理实例 public RestTemplateCustomizer restTemplateCustomizer( final LoadBalancerInterceptor loadBalancerInterceptor) &#123; 为restTemplate增加一个额外的拦截器loadBalancerInterceptor return restTemplate -&gt; &#123; List&lt;ClientHttpRequestInterceptor&gt; list = new ArrayList&lt;&gt;( restTemplate.getInterceptors()); list.add(loadBalancerInterceptor); restTemplate.setInterceptors(list); &#125;; &#125; ··· /** * Auto configuration for retry mechanism. */ @Configuration(proxyBeanMethods = false) @ConditionalOnClass(RetryTemplate.class) public static class RetryAutoConfiguration &#123; @Bean @ConditionalOnMissingBean public LoadBalancedRetryFactory loadBalancedRetryFactory() &#123; return new LoadBalancedRetryFactory() &#123; &#125;; &#125; &#125; ··· &#125; 可以看出，在LoadBalancerAutoConfiguration中，维护了一个List&lt;RestTemplate&gt;，并注入被LoadBalanced修饰的RestTemplate实例。之后对限定的RestTemplate实例增加一个LoadBalancerInterceptor拦截器。另外可以看出，重试机制使用的RetryTemplate.class，重试的时候也会走配置好的负载均衡拦截器。 PS：@Qualifier注解解读/** * This annotation may be used on a field or parameter as a qualifier for * candidate beans when autowiring. It may also be used to annotate other * custom annotations that can then in turn be used as qualifiers. * 1、该注解可以声明在一个字段或者参数上，用于表示在自动注入时，仅限定的候选实例才会被注入， * 例如同一个接口多个实现时，可以用它限定注入哪一个实例。 * 2、该注解也可以使用在一个自定义注解上，那么该自定义注解可以被当做限定词使用， * 可以理解为是@Qualifier(\"@xx\")这种限定 * @author Mark Fisher * @author Juergen Hoeller * @since 2.5 * @see Autowired */ @Target(&#123;ElementType.FIELD, ElementType.METHOD, ElementType.PARAMETER, ElementType.TYPE, ElementType.ANNOTATION_TYPE&#125;) @Retention(RetentionPolicy.RUNTIME) @Inherited @Documented public @interface Qualifier &#123; String value() default \"\"; &#125; 4、负载均衡拦截器 LoadBalancerInterceptor public class LoadBalancerInterceptor implements ClientHttpRequestInterceptor &#123; private LoadBalancerClient loadBalancer; private LoadBalancerRequestFactory requestFactory; public LoadBalancerInterceptor(LoadBalancerClient loadBalancer, LoadBalancerRequestFactory requestFactory) &#123; this.loadBalancer = loadBalancer; this.requestFactory = requestFactory; &#125; public LoadBalancerInterceptor(LoadBalancerClient loadBalancer) &#123; // for backwards compatibility this(loadBalancer, new LoadBalancerRequestFactory(loadBalancer)); &#125; @Override public ClientHttpResponse intercept(final HttpRequest request, final byte[] body, final ClientHttpRequestExecution execution) throws IOException &#123; final URI originalUri = request.getURI(); // 这里得到的就是我们在resttemplate中填写的服务名 String serviceName = originalUri.getHost(); Assert.state(serviceName != null, \"Request URI does not contain a valid hostname: \" + originalUri); // 这里可以看出，拦截器内部使用LoadBalancerClient实例进行实际调用 return this.loadBalancer.execute(serviceName, this.requestFactory.createRequest(request, body, execution)); &#125; &#125; 跟踪到这里才发现，通过注解对RestTemplate进行拦截，使用LoadBalancerClient做实际调用处理。 LoadBalancerClient就是之前声明的RibbonLoadBalancerClient，其具体处理如下： @Override public &lt;T&gt; T execute(String serviceId, LoadBalancerRequest&lt;T&gt; request) throws IOException &#123; return execute(serviceId, request, null); &#125; /** 使用key选择一个server来执行请求 * New: Execute a request by selecting server using a 'key'. The hint will have to be * the last parameter to not mess with the `execute(serviceId, ServiceInstance, * request)` method. This somewhat breaks the fluent coding style when using a lambda * to define the LoadBalancerRequest. * @param &lt;T&gt; returned request execution result type * @param serviceId id of the service to execute the request to * @param request to be executed * @param hint used to choose appropriate &#123;@link Server&#125; instance * @return request execution result * @throws IOException executing the request may result in an &#123;@link IOException&#125; */ public &lt;T&gt; T execute(String serviceId, LoadBalancerRequest&lt;T&gt; request, Object hint) throws IOException &#123; // 根据服务名获取一个ILoadBalancer负载均衡器处理实例 ILoadBalancer loadBalancer = getLoadBalancer(serviceId); Server server = getServer(loadBalancer, hint); if (server == null) &#123; throw new IllegalStateException(\"No instances available for \" + serviceId); &#125; RibbonServer ribbonServer = new RibbonServer(serviceId, server, isSecure(server, serviceId), serverIntrospector(serviceId).getMetadata(server)); return execute(serviceId, ribbonServer, request); &#125; 当一个被@LoadBalanced修饰的RestTemplate实例向外发送请求时，会被LoadBalancerInterceptor类的intercept函数拦截。之后通过originalUri.getHost()拿到具体的服务名，然后调用execute方法，根据服务名选择实例发起实际的请求。 protected Server getServer(ILoadBalancer loadBalancer, Object hint) &#123; if (loadBalancer == null) &#123; return null; &#125; // Use 'default' on a null hint, or just pass it on? return loadBalancer.chooseServer(hint != null ? hint : \"default\"); &#125; getServer方法使用ILoadBalancer获取了具体的服务。由第二小节ribbonClient实例配置中，我们知道，默认的loadBalancer是ZoneAwareLoadBalancer，通过ZoneAwareLoadBalancer的chooseServer方法获取到负载均衡策略分配到的服务实例server，将其包装成RibbonServer，继续执行execute方法： @Override public &lt;T&gt; T execute(String serviceId, ServiceInstance serviceInstance, LoadBalancerRequest&lt;T&gt; request) throws IOException &#123; Server server = null; if (serviceInstance instanceof RibbonServer) &#123; server = ((RibbonServer) serviceInstance).getServer(); &#125; if (server == null) &#123; throw new IllegalStateException(\"No instances available for \" + serviceId); &#125; RibbonLoadBalancerContext context = this.clientFactory .getLoadBalancerContext(serviceId); // 这里还使用了RibbonStatsRecorder来跟踪服务请求记录 RibbonStatsRecorder statsRecorder = new RibbonStatsRecorder(context, server); try &#123; // 回调LoadBalancerInterceptor中的LoadBalancerRequest的apply函数，向一个实际的服务发起请求 T returnVal = request.apply(serviceInstance); statsRecorder.recordStats(returnVal); return returnVal; &#125; // catch IOException and rethrow so RestTemplate behaves correctly catch (IOException ex) &#123; statsRecorder.recordStats(ex); throw ex; &#125; catch (Exception ex) &#123; statsRecorder.recordStats(ex); ReflectionUtils.rethrowRuntimeException(ex); &#125; return null; &#125; 回调LoadBalancerInterceptor中的LoadBalancerRequest的apply函数，向一个实际的服务发起请求。从而实现了一开始以服务名作为host的URI到host:port形式的实际请求地址的转换。 request.apply(serviceInstance)的具体实现如下 public LoadBalancerRequest&lt;ClientHttpResponse&gt; createRequest( final HttpRequest request, final byte[] body, final ClientHttpRequestExecution execution) &#123; return instance -&gt; &#123; // 接收传入的serviceInstance，将其包装成HttpRequest HttpRequest serviceRequest = new ServiceRequestWrapper(request, instance, this.loadBalancer); if (this.transformers != null) &#123; for (LoadBalancerRequestTransformer transformer : this.transformers) &#123; serviceRequest = transformer.transformRequest(serviceRequest, instance); &#125; &#125; // 调用ClientHttpRequestExecution并传入serviceRequest return execution.execute(serviceRequest, body); &#125;; &#125; class InterceptingClientHttpRequest extends AbstractBufferingClientHttpRequest &#123; ··· @Override public ClientHttpResponse execute(HttpRequest request, byte[] body) throws IOException &#123; if (this.iterator.hasNext()) &#123; ClientHttpRequestInterceptor nextInterceptor = this.iterator.next(); return nextInterceptor.intercept(request, body, this); &#125; else &#123; HttpMethod method = request.getMethod(); Assert.state(method != null, \"No standard HTTP method\"); // 这里真正创建请求，传入request.getURI()，即调用了上一步包装的HttpRequest.getURI() ClientHttpRequest delegate = requestFactory.createRequest(request.getURI(), method); request.getHeaders().forEach((key, value) -&gt; delegate.getHeaders().addAll(key, value)); if (body.length &gt; 0) &#123; if (delegate instanceof StreamingHttpOutputMessage) &#123; StreamingHttpOutputMessage streamingOutputMessage = (StreamingHttpOutputMessage) delegate; streamingOutputMessage.setBody(outputStream -&gt; StreamUtils.copy(body, outputStream)); &#125; else &#123; StreamUtils.copy(body, delegate.getBody()); &#125; &#125; return delegate.execute(); &#125; &#125; &#125; 包装类HttpRequest.getURI()方法如下： public class ServiceRequestWrapper extends HttpRequestWrapper &#123; private final ServiceInstance instance; private final LoadBalancerClient loadBalancer; @Override public URI getURI() &#123; // 这里获取URI时，调用了loadBalancer.reconstructURI方法 URI uri = this.loadBalancer.reconstructURI(this.instance, getRequest().getURI()); return uri; &#125; reconstructURI如下： private SpringClientFactory clientFactory; @Override public URI reconstructURI(ServiceInstance instance, URI original) &#123; Assert.notNull(instance, \"instance can not be null\"); // 获取服务id String serviceId = instance.getServiceId(); // 从SpringClientFactory中获取对应服务的负载均衡器的上下文对象 RibbonLoadBalancerContext context = this.clientFactory .getLoadBalancerContext(serviceId); URI uri; Server server; if (instance instanceof RibbonServer) &#123; // 根据ServiceInstance构建具体服务实例信息的Server对象 RibbonServer ribbonServer = (RibbonServer) instance; // 将springCloud定义的ServiceInstance转成netflix中需要的Server对象 server = ribbonServer.getServer(); uri = updateToSecureConnectionIfNeeded(original, ribbonServer); &#125; else &#123; server = new Server(instance.getScheme(), instance.getHost(), instance.getPort()); IClientConfig clientConfig = clientFactory.getClientConfig(serviceId); ServerIntrospector serverIntrospector = serverIntrospector(serviceId); uri = updateToSecureConnectionIfNeeded(original, clientConfig, serverIntrospector, server); &#125; // 使用上下文对象来构建服务实例的URL return context.reconstructURIWithServer(server, uri); &#125; SpringClientFactory是一个用来创建客户端负载均衡器的工厂类，它为每一个不同名的ribbon客户端生成不同的Spring上下文。 RibbonLoadBalancerContext时LoadBalancerContext的子类，用于存储负载均衡器本身的一些上下文内容和常用API操作，如reconstructURIWithServer。 reconstructURIWithServer如下： public URI reconstructURIWithServer(Server server, URI original) &#123; // 从server中获取host和port信息，然后和original中的其他信息进行拼接整合，形成最终要访问的服务实例的具体地址 String host = server.getHost(); int port = server.getPort(); String scheme = server.getScheme(); if (host.equals(original.getHost()) &amp;&amp; port == original.getPort() &amp;&amp; scheme == original.getScheme()) &#123; return original; &#125; if (scheme == null) &#123; scheme = original.getScheme(); &#125; if (scheme == null) &#123; scheme = deriveSchemeAndPortFromPartialUri(original).first(); &#125; try &#123; StringBuilder sb = new StringBuilder(); sb.append(scheme).append(\"://\"); if (!Strings.isNullOrEmpty(original.getRawUserInfo())) &#123; sb.append(original.getRawUserInfo()).append(\"@\"); &#125; sb.append(host); if (port &gt;= 0) &#123; sb.append(\":\").append(port); &#125; sb.append(original.getRawPath()); if (!Strings.isNullOrEmpty(original.getRawQuery())) &#123; sb.append(\"?\").append(original.getRawQuery()); &#125; if (!Strings.isNullOrEmpty(original.getRawFragment())) &#123; sb.append(\"#\").append(original.getRawFragment()); &#125; URI newURI = new URI(sb.toString()); return newURI; &#125; catch (URISyntaxException e) &#123; throw new RuntimeException(e); &#125; &#125; 5、负载均衡器接口 ILoadBalancer ILoadBalancer 中定义了负载均衡器的操作的接口： /** * Interface that defines the operations for a software loadbalancer. * A typical loadbalancer minimally need a set of servers to loadbalance for, a method to * mark a particular server to be out of rotation and a call that will choose a * server from the existing list of server. * 一个接口，用于定义软件负载均衡的操作。 * 一个典型的负载均衡器最少需要一组实例进行负载均衡。 * 一个方法去标记特定的服务不可用 * 一个调用，从现有的服务列表中选择一个服务 * @author stonse * */ public interface ILoadBalancer &#123; /** * Initial list of servers. * This API also serves to add additional ones at a later time * The same logical server (host:port) could essentially be added multiple times * (helpful in cases where you want to give more \"weightage\" perhaps ..) * 初始化服务列表。 * 也可以用于追加服务到列表中。 * 同一逻辑服务(host:port) 本质上可以多次添加。 * @param newServers new servers to add */ public void addServers(List&lt;Server&gt; newServers); /** * Choose a server from load balancer. * 根据key从负载均衡器中选择一个服务 * @param key An object that the load balancer may use to determine which server to return. null if * the load balancer does not use this parameter. * @return server chosen */ public Server chooseServer(Object key); /** * To be called by the clients of the load balancer to notify that a Server is down * else, the LB will think its still Alive until the next Ping cycle - potentially * (assuming that the LB Impl does a ping) * 由负载均衡器的客户端去调用，通知服务已关闭。否则LB将认为它仍然有效，直到下一个ping周期 * @param server Server to mark as down */ public void markServerDown(Server server); /**返回所有可用的服务列表 * @return Only the servers that are up and reachable. */ public List&lt;Server&gt; getReachableServers(); /**返回所有的服务列表（包含可用、不可用的） * @return All known servers, both reachable and unreachable. */ public List&lt;Server&gt; getAllServers(); &#125; Server对象包含了服务端节点的元数据信息，如host、port、以及一些部署信息。 ILoadBalancer的实现类，完整的类图如下： 从上面的类图可以看到，ILoadBalancer 有三个实现类，BaseLoadBalancer实现了基础的负载均衡，DynamicServerListLoadBalancer和ZoneAwareLoadBalancer则在策略上做了一些功能的扩展。他们之间是继承关系，最终的实现类是 ZoneAwareLoadBalancer。 很多东西都是定义在BaseLoadBalancer中的，先从 BaseLoadBalancer 中的 变量看： /** * A basic implementation of the load balancer where an arbitrary list of * servers can be set as the server pool. A ping can be set to determine the * liveness of a server. Internally, this class maintains an \"all\" server list * and an \"up\" server list and use them depending on what the caller asks for. * 一个基础的负载均衡器的实现类 * 默认的ping策略去查明存活的服务 * 维护一个所有服务的list和存活服务的list * @author stonse * */ public class BaseLoadBalancer extends AbstractLoadBalancer implements PrimeConnections.PrimeConnectionListener, IClientConfigAware &#123; private static Logger logger = LoggerFactory .getLogger(BaseLoadBalancer.class); // 默认的线性轮询负载均衡策略 private final static IRule DEFAULT_RULE = new RoundRobinRule(); // 串行ping策略 private final static SerialPingStrategy DEFAULT_PING_STRATEGY = new SerialPingStrategy(); private static final String DEFAULT_NAME = \"default\"; private static final String PREFIX = \"LoadBalancer_\"; protected IRule rule = DEFAULT_RULE; protected IPingStrategy pingStrategy = DEFAULT_PING_STRATEGY; protected IPing ping = null; // 所有服务列表 @Monitor(name = PREFIX + \"AllServerList\", type = DataSourceType.INFORMATIONAL) protected volatile List&lt;Server&gt; allServerList = Collections .synchronizedList(new ArrayList&lt;Server&gt;()); // 存续服务列表 @Monitor(name = PREFIX + \"UpServerList\", type = DataSourceType.INFORMATIONAL) protected volatile List&lt;Server&gt; upServerList = Collections .synchronizedList(new ArrayList&lt;Server&gt;()); // 客户端配置 private IClientConfig config; public BaseLoadBalancer(String name, IRule rule, LoadBalancerStats stats, IPing ping, IPingStrategy pingStrategy) &#123; logger.debug(\"LoadBalancer [&#123;&#125;]: initialized\", name); this.name = name; this.ping = ping; this.pingStrategy = pingStrategy; setRule(rule); setupPingTask(); lbStats = stats; init(); &#125; 从上面的变量信息我们可以看出一些东西： 默认的 负载均衡策略是随机负载均衡； 默认的Ping策略为串行化Ping； 使用了一个list来保存所有的服务列表，一个list来保存当前所有的存活状态的服务列表； 定义了客户端配置，用于初始化客户端以及负载均衡配置 。 PingTask定时验证服务器状态 分析完 BaseLoadBalancer ，DynamicServerListLoadBalancer 和 ZoneAwareLoadBalancer 基本大同小异： DynamicServerListLoadBalancer ：使用动态源的服务器， 即服务器列表可能是在运行时更改。 通过一些Filter函数来动态的过滤掉指定的服务器列表； ZoneAwareLoadBalancer ：这个负载均衡器适用于异地多机房的情况，在选择服务器的时候可以避免整个区域。LoadBalancer将计算并检查所有可用区域的区域统计信息。如果任何区域的“平均活动请求数”已达到配置的阈值，则该区域将从活动服务器列表中删除。如果多个区域已达到阈值，则将删除每台服务器上最活跃请求的区域。一旦删除了最坏的区域，将在其余区域中选择一个区域，其概率与其实例数成正比。服务器将从具有指定规则的选定区域返回。对于每个请求都将重复上述步骤，也就是说，每个区域相关的负载平衡决策都是在最新统计信息的帮助下实时做的。 三、总结使用@LoadBalanced注解标记RestTemplate，在LoadBalancerAutoConfiguration中注入被标记的RestTemplate，使用RestTemplateCustomizer（定制器）并为其增加LoadBalancerInterceptor的拦截器，拦截器中调用LoadBalancerClient（负载均衡客户端）进行处理，获取实际server信息，并回调request，将以逻辑服务名为host的URI转成具体的服务实例。而LoadBalancerClient（负载均衡客户端）内部实际还是调用netflix的 ILoadBalancer（负载均衡器）接口的实现（ZoneAwareLoadBalancer） 在ILoadBalancer （负载均衡器）中配置了PIng策略、负载均衡策略、服务列表信息。整个过程如下： @LoadBalanced–&gt;LoadBalancerAutoConfiguration–&gt;RestTemplateCustomizer–&gt;LoadBalancerInterceptor–&gt;LoadBalancerClient–&gt;ILoadBalancer 注解限定 –&gt; rest定制器 –&gt; 拦截器 –&gt; 客户端 –&gt; 负载均衡器","categories":[{"name":"springCloud","slug":"springCloud","permalink":"http://yoursite.com/categories/springCloud/"}],"tags":[{"name":"ribbon","slug":"ribbon","permalink":"http://yoursite.com/tags/ribbon/"}]},{"title":"eureka源码","slug":"eureka源码","date":"2020-06-13T13:35:50.000Z","updated":"2020-06-13T15:17:05.142Z","comments":true,"path":"2020/06/13/eureka源码/","link":"","permalink":"http://yoursite.com/2020/06/13/eureka%E6%BA%90%E7%A0%81/","excerpt":"","text":"一、两种方式禁用服务注册1、@EnableDiscoveryClient(autoRegister=false)2、spring.cloud.service-registry.auto-registration.enabled=false@Import(EnableDiscoveryClientImportSelector.class) public @interface EnableDiscoveryClient &#123; /** * If true, the ServiceRegistry will automatically register the local server. * @return - &#123;@code true&#125; if you want to automatically register. */ boolean autoRegister() default true; &#125; 该配置项默认为true，但是可以主动声明去禁用 @Import(EnableDiscoveryClientImportSelector.class)的源码如下： @Order(Ordered.LOWEST_PRECEDENCE - 100) public class EnableDiscoveryClientImportSelector extends SpringFactoryImportSelector&lt;EnableDiscoveryClient&gt; &#123; @Override public String[] selectImports(AnnotationMetadata metadata) &#123; // 父类loadFactoryNames方法，定义去加载了FACTORIES_RESOURCE_LOCATION = \"META-INF/spring.factories\";中所有的自动配置类 String[] imports = super.selectImports(metadata); AnnotationAttributes attributes = AnnotationAttributes.fromMap( metadata.getAnnotationAttributes(getAnnotationClass().getName(), true)); // 获取注解声明的autoRegister，从而调用实际处理 boolean autoRegister = attributes.getBoolean(\"autoRegister\"); if (autoRegister) &#123; List&lt;String&gt; importsList = new ArrayList&lt;&gt;(Arrays.asList(imports)); importsList.add( \"org.springframework.cloud.client.serviceregistry.AutoServiceRegistrationConfiguration\"); imports = importsList.toArray(new String[0]); &#125; else &#123; Environment env = getEnvironment(); if (ConfigurableEnvironment.class.isInstance(env)) &#123; ConfigurableEnvironment configEnv = (ConfigurableEnvironment) env; LinkedHashMap&lt;String, Object&gt; map = new LinkedHashMap&lt;&gt;(); // 从这里可以看出，其实还是通过这个方式处理的 map.put(\"spring.cloud.service-registry.auto-registration.enabled\", false); MapPropertySource propertySource = new MapPropertySource( \"springCloudDiscoveryClient\", map); configEnv.getPropertySources().addLast(propertySource); &#125; &#125; return imports; &#125; 二、springCloud对netflixEureka进行了封装打开spring-cloud-starter-netflix-eureka-client.jar，找到META-INF/spring.factories，内容如下： org.springframework.boot.autoconfigure.EnableAutoConfiguration=\\ org.springframework.cloud.netflix.eureka.config.EurekaClientConfigServerAutoConfiguration,\\ org.springframework.cloud.netflix.eureka.config.DiscoveryClientOptionalArgsConfiguration,\\ # EurekaClient的自动配置类 org.springframework.cloud.netflix.eureka.EurekaClientAutoConfiguration,\\ org.springframework.cloud.netflix.ribbon.eureka.RibbonEurekaAutoConfiguration,\\ # EurekaDiscoveryClient的自动配置类，默认就扫描加载了 org.springframework.cloud.netflix.eureka.EurekaDiscoveryClientConfiguration,\\ org.springframework.cloud.netflix.eureka.reactive.EurekaReactiveDiscoveryClientConfiguration,\\ org.springframework.cloud.netflix.eureka.loadbalancer.LoadBalancerEurekaAutoConfiguration org.springframework.cloud.bootstrap.BootstrapConfiguration=\\ org.springframework.cloud.netflix.eureka.config.EurekaConfigServerBootstrapConfiguration 打开EurekaDiscoveryClientConfiguration，发现，其构造是注入了netflix的EurekaClient，其本身也是一层包装 import com.netflix.discovery.EurekaClient; import com.netflix.discovery.EurekaClientConfig; @Bean @ConditionalOnMissingBean public EurekaDiscoveryClient discoveryClient(EurekaClient client, EurekaClientConfig clientConfig) &#123; return new EurekaDiscoveryClient(client, clientConfig); &#125; 点进去EurekaClient,其接口和实现类DiscoveryClient @ImplementedBy(DiscoveryClient.class) public interface EurekaClient extends LookupService &#123; ··· &#125; 在DiscoveryClient的构造函数中进行了定时任务的初始化 @Inject DiscoveryClient(ApplicationInfoManager applicationInfoManager, EurekaClientConfig config, AbstractDiscoveryClientOptionalArgs args, Provider&lt;BackupRegistry&gt; backupRegistryProvider, EndpointRandomizer endpointRandomizer) &#123; ··· // finally, init the schedule tasks (e.g. cluster resolvers, heartbeat, instanceInfo replicator, fetch initScheduledTasks(); ··· 三、服务获取/** * Initializes all scheduled tasks. */ private void initScheduledTasks() &#123; // 内部是EurekaClientConfigBean中的`eureka.client.fetch-registry=true`参数判断 if (clientConfig.shouldFetchRegistry()) &#123; // registry cache refresh timer int registryFetchIntervalSeconds = clientConfig.getRegistryFetchIntervalSeconds(); int expBackOffBound = clientConfig.getCacheRefreshExecutorExponentialBackOffBound(); // 声明了一个定时任务 cacheRefreshTask = new TimedSupervisorTask( \"cacheRefresh\", scheduler, cacheRefreshExecutor, registryFetchIntervalSeconds,//默认更新周期，30s TimeUnit.SECONDS, expBackOffBound, new CacheRefreshThread() ); scheduler.schedule( cacheRefreshTask, registryFetchIntervalSeconds, TimeUnit.SECONDS); &#125; ···· 服务获取的逻辑处理是一个单独的if 其判断依据就是eureka.client.fetch-registry=true参数 @ConfigurationProperties(EurekaClientConfigBean.PREFIX) public class EurekaClientConfigBean implements EurekaClientConfig, Ordered &#123; /** * Default prefix for Eureka client config properties. */ public static final String PREFIX = \"eureka.client\"; /** * Indicates whether this client should fetch eureka registry information from eureka * server. */ private boolean fetchRegistry = true; 四、服务注册/** * Initializes all scheduled tasks. */ private void initScheduledTasks() &#123; ··· if (clientConfig.shouldRegisterWithEureka()) &#123; ··· // InstanceInfo replicator instanceInfoReplicator = new InstanceInfoReplicator( this, instanceInfo, clientConfig.getInstanceInfoReplicationIntervalSeconds(), 2); // burstSize ··· instanceInfoReplicator.start(clientConfig.getInitialInstanceInfoReplicationIntervalSeconds()); &#125; else &#123; logger.info(\"Not registering with Eureka server per configuration\"); &#125; &#125; 创建了一个instanceInfoReplicator实例，start调用进行定时任务 定时任务具体如下： public void run() &#123; try &#123; discoveryClient.refreshInstanceInfo(); Long dirtyTimestamp = instanceInfo.isDirtyWithTime(); if (dirtyTimestamp != null) &#123; // 真是出发调用注册的地方就在这里 discoveryClient.register(); ··· &#125; /** * Register with the eureka service by making the appropriate REST call. */ boolean register() throws Throwable &#123; logger.info(PREFIX + \"&#123;&#125;: registering service...\", appPathIdentifier); EurekaHttpResponse&lt;Void&gt; httpResponse; try &#123; // 注册也是通过rest请求，传入了一个instanceInfo对象 httpResponse = eurekaTransport.registrationClient.register(instanceInfo); &#125; catch (Exception e) &#123; logger.warn(PREFIX + \"&#123;&#125; - registration failed &#123;&#125;\", appPathIdentifier, e.getMessage(), e); throw e; &#125; if (logger.isInfoEnabled()) &#123; logger.info(PREFIX + \"&#123;&#125; - registration status: &#123;&#125;\", appPathIdentifier, httpResponse.getStatusCode()); &#125; return httpResponse.getStatusCode() == Status.NO_CONTENT.getStatusCode(); &#125; 五、服务续约/** * Initializes all scheduled tasks. */ private void initScheduledTasks() &#123; ··· if (clientConfig.shouldRegisterWithEureka()) &#123; int renewalIntervalInSecs = instanceInfo.getLeaseInfo().getRenewalIntervalInSecs(); int expBackOffBound = clientConfig.getHeartbeatExecutorExponentialBackOffBound(); logger.info(\"Starting heartbeat executor: \" + \"renew interval is: &#123;&#125;\", renewalIntervalInSecs); // Heartbeat timer heartbeatTask = new TimedSupervisorTask( \"heartbeat\", scheduler, heartbeatExecutor, renewalIntervalInSecs, TimeUnit.SECONDS, expBackOffBound, new HeartbeatThread() ); scheduler.schedule( heartbeatTask, renewalIntervalInSecs, TimeUnit.SECONDS); ··· &#125; /** * The heartbeat task that renews the lease in the given intervals. */ private class HeartbeatThread implements Runnable &#123; public void run() &#123; if (renew()) &#123; lastSuccessfulHeartbeatTimestamp = System.currentTimeMillis(); &#125; &#125; &#125; /** * Renew with the eureka service by making the appropriate REST call */ boolean renew() &#123; EurekaHttpResponse&lt;InstanceInfo&gt; httpResponse; try &#123; // 续约也是rest方式 httpResponse = eurekaTransport.registrationClient.sendHeartBeat(instanceInfo.getAppName(), instanceInfo.getId(), instanceInfo, null); logger.debug(PREFIX + \"&#123;&#125; - Heartbeat status: &#123;&#125;\", appPathIdentifier, httpResponse.getStatusCode()); if (httpResponse.getStatusCode() == Status.NOT_FOUND.getStatusCode()) &#123; REREGISTER_COUNTER.increment(); logger.info(PREFIX + \"&#123;&#125; - Re-registering apps/&#123;&#125;\", appPathIdentifier, instanceInfo.getAppName()); long timestamp = instanceInfo.setIsDirtyWithTime(); boolean success = register(); if (success) &#123; instanceInfo.unsetIsDirty(timestamp); &#125; return success; &#125; return httpResponse.getStatusCode() == Status.OK.getStatusCode(); &#125; catch (Throwable e) &#123; logger.error(PREFIX + \"&#123;&#125; - was unable to send heartbeat!\", appPathIdentifier, e); return false; &#125; &#125; 声明了一个heartbeatTask定时任务进行续约，传入HeartbeatThread 服务续约也是rest方式 六、配置详解META-INF/spring.factories，内容中还有个EurekaClientAutoConfiguration，用于加载配置参数类 # EurekaClient的自动配置类 org.springframework.cloud.netflix.eureka.EurekaClientAutoConfiguration,\\ @Bean @ConditionalOnMissingBean(value = EurekaClientConfig.class, search = SearchStrategy.CURRENT) public EurekaClientConfigBean eurekaClientConfigBean(ConfigurableEnvironment env) &#123; return new EurekaClientConfigBean(); &#125; @Bean @ConditionalOnMissingBean(value = EurekaInstanceConfig.class, search = SearchStrategy.CURRENT) public EurekaInstanceConfigBean eurekaInstanceConfigBean(InetUtils inetUtils, ManagementMetadataProvider managementMetadataProvider) &#123;&#125; 可以查看EurekaClientConfigBean和EurekaInstanceConfigBean获取比官方文档更详细的解释说明 eureka的所有的配置信息，都是通过EurekaInstanceConfigBean加载的，真正注册时，内部包装成InstanceInfo进行传递 1、注册中心配置 eureka.client.serverUrl.defaultZone=xxx： private Map&lt;String, String&gt; serviceUrl = new HashMap&lt;&gt;(); &#123; this.serviceUrl.put(DEFAULT_ZONE, DEFAULT_URL); &#125; /** * Default Eureka URL. */ public static final String DEFAULT_URL = \"http://localhost:8761\" + DEFAULT_PREFIX + \"/\"; /** * Default availability zone if none is resolved based on region. */ public static final String DEFAULT_ZONE = \"defaultZone\"; 2、实例名配置 eureka.instance.instanceId 它是区分同一服务不同实例的唯一标识 实例名采用主机名作为唯一标识，规则如下 public static String getDefaultInstanceId(PropertyResolver resolver, boolean includeHostname) &#123; String vcapInstanceId = resolver.getProperty(\"vcap.application.instance_id\"); if (StringUtils.hasText(vcapInstanceId)) &#123; return vcapInstanceId; &#125; String hostname = null; if (includeHostname) &#123; hostname = resolver.getProperty(\"spring.cloud.client.hostname\"); &#125; String appName = resolver.getProperty(\"spring.application.name\"); String namePart = combineParts(hostname, SEPARATOR, appName); String indexPart = resolver.getProperty(\"spring.application.instance_id\", resolver.getProperty(\"server.port\")); return combineParts(namePart, SEPARATOR, indexPart); &#125; 即 ${spring.cloud.client.hostname}:${spring.application.name}:${spring.application.instance_id} 3、端点配置 homePageUrl、statusPageUrl、healthCheckUrl，即spring-boot-actuator模块提供的/info和/health端点 当应用设置了context-path时，端点也需要加上该前缀 xxx.context-path=/orange eureka.instance.statusPageUrlPath=$&#123;xxx.context-path&#125;/info eureka.instance.healthCheckUrlPath=$&#123;xxx.context-path&#125;/health 或者为了安全考虑，修改端点的原始路径 endpoints.info.path=/orangeInfo endpoints.health.path=/orangeHealth eureka.instance.statusPageUrlPath=$&#123;endpoints.info.path&#125; eureka.instance.healthCheckUrlPath=$&#123;endpoints.health.path&#125; 4、健康检查 客户端默认的心跳方式可以有效的检查客户端进程是否运行，但是无法保证客户端能否正常提供服务 可以把客户端的健康检查交给actuator # 在pom中引入Spring-boot-starter-actuator # 增加参数配置：eureka.client.healthcheck.enabled=true","categories":[{"name":"springCloud","slug":"springCloud","permalink":"http://yoursite.com/categories/springCloud/"}],"tags":[{"name":"eureka","slug":"eureka","permalink":"http://yoursite.com/tags/eureka/"}]},{"title":"eureka组件","slug":"eureka组件","date":"2020-06-09T12:50:00.000Z","updated":"2020-06-13T15:17:20.004Z","comments":true,"path":"2020/06/09/eureka组件/","link":"","permalink":"http://yoursite.com/2020/06/09/eureka%E7%BB%84%E4%BB%B6/","excerpt":"","text":"一、EnableDiscoveryClient与EnableEurekaClient的区别Spring Cloud版本：Angle -&gt; Brixton -&gt; Camden -&gt; Dalston -&gt; Edgware -&gt; Finchley-&gt;Greenwich-&gt;Hoxton Dalston或更早期的版本,为了启用服务注册发现功能。需要在主启动类上增加@EnableDiscoveryClient或者@EnableEurekaClient注解。 @EnableEurekaClient内部使用了@EnableDiscoveryClient注解，因此如果要使用eureka的注册发现服务，两者功能是一样的。 EnableDiscoveryClient注解在spring.factories配置中通过配置项EurekaDiscoveryClientConfiguration来开启服务注册发现功能。 @EnableDiscoveryClient注解是基于spring-cloud-commons依赖，并且在classpath中实现。 @EnableEurekaClient注解是基于spring-cloud-netflix依赖，只能为eureka作用。 @EnableEurekaClient只适用于Eureka作为注册中心，@EnableDiscoveryClient 可以是其他注册中心。 二、 @EnableDiscoveryClient注解现在也没用了（Dalston之后的版本中（不含Dalston））只要依赖了以spring-cloud-starter-netflix为前缀的库(例如spring-cloud-starter-netflix-eureka-client)，就启用了服务注册发现功能。 使用配置项spring.cloud.service-registry.auto-registration.enabled=false即可禁止服务注册发现功能。 spring容器在查询spring.factories的过程中，如果找到了EnableDiscoveryClient的配置，就会实例化该配置对应的服务注册发现：例如eureka、consul、zookeeper等。 打开工程spring-cloud-netflix-eureka-client.jar，去看src\\main\\resources\\META-INF目录下的spring.factories文件，发现在springboot的自动配置项中，出现了一个关键配置EurekaDiscoveryClientConfiguration，如下： org.springframework.boot.autoconfigure.EnableAutoConfiguration=\\ org.springframework.cloud.netflix.eureka.config.EurekaClientConfigServerAutoConfiguration,\\ org.springframework.cloud.netflix.eureka.config.DiscoveryClientOptionalArgsConfiguration,\\ org.springframework.cloud.netflix.eureka.EurekaClientAutoConfiguration,\\ org.springframework.cloud.netflix.ribbon.eureka.RibbonEurekaAutoConfiguration,\\ org.springframework.cloud.netflix.eureka.EurekaDiscoveryClientConfiguration,\\ org.springframework.cloud.netflix.eureka.reactive.EurekaReactiveDiscoveryClientConfiguration,\\ org.springframework.cloud.netflix.eureka.loadbalancer.LoadBalancerEurekaAutoConfiguration org.springframework.cloud.bootstrap.BootstrapConfiguration=\\ org.springframework.cloud.netflix.eureka.config.EurekaConfigServerBootstrapConfiguration 在spring.factories配置中，配置类EurekaDiscoveryClientConfiguration被配置到springboot的自动配置注解中，与EnableDiscoveryClient注解没有关系了,也就是说只要开启了springboot的自动配置，服务注册发现功能就会启用。 EnableEurekaClient源码中没有使用注解EnableDiscoveryClient，此时EnableEurekaClient已经没用了。 三、Eureka两个组件：Eureka Server和Eureka Client。Eureka Server Eureka Server 提供服务发现能力，各个微服务启动时，会向Eureka Server注册自己的信息（例如IP、端口、微服务名称等），Eureka Server会存储这些信息。 Eureka Server作为一个独立的部署单元，以REST API的形式为服务实例提供了注册、管理和查询等操作。同时，Eureka Server也为我们提供了可视化的监控页面，可以直观地看到各个Eureka Server当前的运行状态和所有已注册服务的情况。 Eureka Client Erueka Client是一个java客户端，用于简化与Eureka的交互。 微服务启动后，会周期性（默认30s）地向Eureka Server发送心跳以续约自己的“ 租期 ”。 如果Eureka server在一定的时间内没有接收到某个微服务实例的心跳，Eureka Server将注销该实例（默认90s）。 默认情况下，Eureka Server同时也是Eureka Client。 多个Eureka Server 实例互相之间通过复制的方式来实现服务注册表中数据的同步。 Eureka Client 会缓存服务注册表中的信息，这种方式有一定的优势——首先，无须每次请求都查询Eureka Server，从而降低了Eureka Server的压力；其次，即使Eureka Server所有节点都宕掉，服务消费者依然可以使用缓存中的信息找到服务提供者并完成调用。 综上，Eureka通过心跳检查、客户端缓存等机制，提高了系统的灵活性、可伸缩性和可用性。","categories":[{"name":"springCloud","slug":"springCloud","permalink":"http://yoursite.com/categories/springCloud/"}],"tags":[{"name":"eureka","slug":"eureka","permalink":"http://yoursite.com/tags/eureka/"}]},{"title":"RestTemplate使用","slug":"RestTemplate使用","date":"2020-06-08T13:05:44.000Z","updated":"2020-06-08T13:57:05.423Z","comments":true,"path":"2020/06/08/RestTemplate使用/","link":"","permalink":"http://yoursite.com/2020/06/08/RestTemplate%E4%BD%BF%E7%94%A8/","excerpt":"","text":"restTemplate详解 该对象会使用ribbon的自动化配置，同时通过@LoadBalanced注解修饰还能开启客户端负载均衡 一、GET请求1.1 getForEntity 该方法返回的是ResponseEntity，是spring对HTTP响应的封装。 主要存储了HTTP的几个重要元素，如HttpStatus状态码。在HttpEntity中还存储着HttpHeaders以及范型类型的请求体对象。 三种常见的重载方式 getForEntity(String url, Class&lt;T&gt; responseType, Object... uriVariables) // 如 restTemplate.getForEntity(\"http://MYCLOUD-PROVIDER/user?name=&#123;1&#125;\", String.class, \"orange\"); url中使用占位符的方式进行参数绑定。 第二个参数为返回值的包装类型。 RestTemplate restTemplate = new RestTemplate(); Map&lt;String, String&gt; params = new HashMap&lt;&gt;(); params.put(\"key\", \"orange\"); restTemplate.getForEntity(\"http://MYCLOUD-PROVIDER/user?name=&#123;key&#125;\", String.class, params); 参数绑定的方式稍有不同。 RestTemplate restTemplate = new RestTemplate(); UriComponents uriComponents = UriComponentsBuilder .fromUriString(\"http://MYCLOUD-PROVIDER/user?name=&#123;key&#125;\") .build() .expand(\"orange\") .encode(); URI uri = uriComponents.toUri(); ResponseEntity&lt;String&gt; forEntity = restTemplate.getForEntity(uri, String.class); 1.2 getForObject 请求方式基本同getForEntity，可以理解是对其的进一步封装。 它通过HttpMessageConverterExtractor对body进行转换，实现请求直接返回包装好的对象内容。 restTemplate.getForObject(url, Orange.class); 当body是一个Orange对象时，可直接包装。 当不需要关注响应body之外的内容时，建议使用该方式，可以少一个从response中获取body的步骤。 二、POST请求postForEntity(String url, @Nullable Object request, Class&lt;T&gt; responseType, Object... uriVariables) 基本用法与get类似，这里需要注意的是新增加的request参数。 request可以是一个普通对象，也可以是一个HttpEntity对象。 request普通对象会被隐式转换成HttpEntity对象。 这个request不仅包含了body内容，还包含了header内容。 第四个参数uriVariables用于对url中参数绑定。 三、PUT请求put(String url, @Nullable Object request, Object... uriVariables) 四、DELETE请求delete(String url, Object... uriVariables)","categories":[{"name":"springCloud","slug":"springCloud","permalink":"http://yoursite.com/categories/springCloud/"}],"tags":[{"name":"restTemplate","slug":"restTemplate","permalink":"http://yoursite.com/tags/restTemplate/"}]},{"title":"ribbon使用","slug":"ribbon使用","date":"2020-06-08T12:17:27.000Z","updated":"2020-06-14T14:50:00.572Z","comments":true,"path":"2020/06/08/ribbon使用/","link":"","permalink":"http://yoursite.com/2020/06/08/ribbon%E4%BD%BF%E7%94%A8/","excerpt":"","text":"一、什么是ribbon Spring cloud ribbon是一个基于HTTP和TCP的客户端负载均衡工具，它基于netflix ribbon实现。 将面向服务的rest模版请求自动转换成客户端负载均衡的服务调用。 是一个工具类框架，例如API网关的请求转发、Feign的底层都是基于ribbon的。 二、客户端负载均衡1、基础理论 负载均衡是系统高可用、缓解网络压力、处理能力扩容的重要手段之一。 1.1 服务端负载均衡 我们通常所说的负载均衡都是服务端负载均衡，硬件层面如F5，软件层面如nginx。 硬件负载均衡的设备或者软件负载均衡的软件，都会维护一个可用的服务清单，并通过心跳的方式来剔除故障的服务端节点。 当客户端发送请求到负载均衡设备时，该设备按照一定算法（轮询、权重、流量等）从服务端清单中取出一个地址，然后转发请求。 1.2 客户端负载均衡 在客户端负载均衡中，所有的客户端节点都维护着自己的服务端清单，并通过心跳维护清单的健康性。 即客户端负载和服务端负载最大的不同点在于清单所储存的位置。 2、使用方式 服务提供者启动多个实例并注册到一个或多个相关联的注册中心 服务消费者直接调用被@LoadBalanced注解修饰的RestTemplate进行服务调用。 pom文件中需要引入关于Ribbon的包，同时consumer也是一个Eureka Client要去拉 Eureka Server的配置，所以需要Eureka client的包。 &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-ribbon&lt;/artifactId&gt; &lt;version&gt;2.2.3.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt; &lt;version&gt;2.2.3.RELEASE&lt;/version&gt; &lt;/dependency&gt; java中配置负载均衡策略和@LoadBalanced修饰的RestTemplate @Configuration public class RestTemplateConfig &#123; // 负载均衡策略，定义了一个随机方式的服务调用方式，即随即调用某个服务的提供者 @Bean public IRule ribbonRule()&#123; return new RandomRule(); &#125; // 定义一个负载均衡的 RestTemplate，该注解配合负载均衡策略一起使用， RestTemplate 发出的请求才能生效。 @Bean @LoadBalanced RestTemplate restTemplate() &#123; return new RestTemplate(); &#125; &#125; 接下来就可以进行调用了 // 根据服务名去访问，需要将restTemplate注解为@LoadBalanced才会生效 private String service = \"http://MYCLOUD-PROVIDER\"; @RequestMapping(\"/consumer/corps/&#123;id&#125;\") Corp getCorp(@PathVariable(\"id\") String id) &#123; String url = service + \"/corps/\" + id; return restTemplate.getForObject(url, Corp.class); &#125; 3、自动装配方式解读在springCloud实现的服务治理框架中，默认对ribbon自动化整合配置。如eureka中spring.factories: org.springframework.boot.autoconfigure.EnableAutoConfiguration=\\ ··· org.springframework.cloud.netflix.eureka.EurekaClientAutoConfiguration,\\ # 自动整合ribbon相关配置，通过这个类来了解它的配置详情 org.springframework.cloud.netflix.ribbon.eureka.RibbonEurekaAutoConfiguration,\\ org.springframework.cloud.netflix.eureka.EurekaDiscoveryClientConfiguration,\\ ···","categories":[{"name":"springCloud","slug":"springCloud","permalink":"http://yoursite.com/categories/springCloud/"}],"tags":[{"name":"ribbon","slug":"ribbon","permalink":"http://yoursite.com/tags/ribbon/"}]},{"title":"eureka使用","slug":"eureka使用","date":"2020-06-07T15:20:49.000Z","updated":"2020-06-09T15:29:48.178Z","comments":true,"path":"2020/06/07/eureka使用/","link":"","permalink":"http://yoursite.com/2020/06/07/eureka%E4%BD%BF%E7%94%A8/","excerpt":"","text":"一、eureka是什么 服务治理可以说是微服务架构中核心的模块，它主要用来实现各个微服务实例之间的自动化注册与发现。 1、服务注册： 每个服务单元将自己的主机号、版本号、通信协议等告知注册中心，注册中心维护服务清单，并通过心跳的方式监测清单中的服务是否可用，并剔除不可用的服务。 2、服务发现： 各服务单元通过服务名进行相互调用。 3、eureka服务端： 即服务注册中心，提供服务治理，即服务注册与发现的功能。 若eureka以集群方式部署，当集群中有分片出现故障时，eureka进入自我保护模式。它允许再分片故障期间继续提供服务注册与发现，等故障恢复后，其他分片会把它们的状态再次同步回来。 不同服务端通过异步的方式相互复制各自的状态，这意味着在任意时间点，每个实例关于所有服务的状态是有细微差异的。也就是我们通常所说的AP原则。 4、eureka客户端 向注册中心注册自身提供的服务，并周期性的发送心跳来更新服务租约。 将服务端已注册的服务信息缓存到本地，并周期性的刷新。 二、单机配置方式1、服务端1）pom中引入：&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-server&lt;/artifactId&gt; &lt;version&gt;2.2.3.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; 2）配置文件：server: port: 8003 eureka: instance: hostname: localhost # eureka服务端的实例名字 client: service-url: defaultZone: http://$&#123;eureka.instance.hostname&#125;:$&#123;server.port&#125;/eureka/ register-with-eureka: false # 是否向注册中心注册自己，默认true，server应设置为false fetch-registry: false # 服务端本身就是维护服务实例的，所以并不需要去检索服务，默认true，server应设置为false 3）启动类:@SpringBootApplication @EnableEurekaServer //开启Eureka服务端，接受其它微服务注册进来 public class EurekaServer8003 &#123; public static void main(String[] args) &#123; SpringApplication.run(EurekaServer8003.class, args); &#125; &#125; 2、客户端1）pom中引入&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt; &lt;version&gt;2.2.3.RELEASE&lt;/version&gt; &lt;/dependency&gt; 2）配置文件spring: application: name: mycloud-provider # eureka页面 application显示的名称。EurekaServer中服务名默认转成大写的。 eureka: client: service-url: defaultZone: http://localhost:8003/eureka/ instance: instance-id: $&#123;spring.application.name&#125;:$&#123;server.port&#125; # eureka页面status显示的内容 3）启动类@SpringBootApplication // 可不加该配置，Dalston之后的版本中（不含Dalston），只要开启了springboot的自动配置，服务注册发现功能就会启用 // 使用配置项`spring.cloud.service-registry.auto-registration.enabled=false`即可禁止服务注册发现功能。 // eureka.client.register-with-eureka: false 也可禁止服务注册功能。 // @EnableEurekaClient public class CorpProvider8001 &#123; public static void main(String[] args) &#123; SpringApplication.run(CorpProvider8001.class, args); &#125; &#125; 如果不想用主机名作为自定义注册中心的地址，也可以使用IP的形式。在配置文件中配置eureka.instance.prefer-ip-address=true，改值默认为false。 三、info信息完善1）引入依赖&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt; &lt;/dependency&gt; 2）yml中配置info: # eureka页面status点击跳转监控页面 显示的内容 app.name: $&#123;spring.application.name&#125; company.name: www.orange.com build.artifactId: mycloud-provider build.version: 1.0 四、高可用集群配置方式eureka server的高可用实际上就是将自己作为服务向其他注册中心注册自己。 1）创建server1spring: application: name: eureka-server server: port: 8003 eureka: instance: hostname: server-1 client: service-url: defaultZone: http://server-2:8004/eureka/ 2) 创建server2spring: application: name: eureka-server server: port: 8004 eureka: instance: hostname: server-2 client: service-url: defaultZone: http://server-1:8003/eureka/ 3）客户端配置spring: application: name: client eureka: client: service-url: defaultZone: http://server-1:8003/eureka/,http://server-2:8004/eureka/ # 分别向两个服务端注入 五、基础架构服务治理的3个核心要素：服务提供者、服务消费者、服务注册中心。 很多时候，客户端既是服务提供者又是服务消费者 1）服务提供者服务注册： 服务提供者在启动的时候，通过rest请求将自己注册到eureka server，同时附带一些元数据信息。eureka server将它储存在一个双层map中，第一层key是服务名，第二层key是实例名。 在服务注册时，需确认一下eureka.client.register-with-eureka=true参数是否正确。改值默认为true，若设置为false将不会注册。 服务同步： 服务提供者的服务信息可以通过注册中心集群中任意一个获取到。 服务续约renew 服务提供者维持一个心跳用来持续告诉eureka server，防止被server从服务列表清除。 # 续约任务的调用隔离时间，默认30s eureka.instance.lease-renewal-interval-in-seconds=30 # 服务失效时间，默认90s eureka.instance.lease-expiration-duration-in-seconds=30 2）服务消费者获取服务： 客户端通过rest请求，访问获取服务列表，eureka server会维护一份只读的服务清单返回给客户端 # 是否需要获取服务列表，默认为true，客户端需要开启 eureka.client.fetch-registry=true # 缓存清单的更新时间，默认30s eureka.client.registry-fetch-interval-seconds=30 服务调用： 服务消费者在获取到服务清单到，通过服务名根据一定的策略选择一个服务实例进行调用。 服务下线： 客户端正常关闭时，会触发一个rest请求给server，server接收到该请求后，将该服务状态置为下线DOWN，并把该下线事件传播出去。 3）服务注册中心失效剔除： server在启动的时候会创建一个定时任务，默认每隔60s将服务清单中超时（默认90s）没有续约的服务剔除。 自我保护： 默认在15分钟内，若心跳失败的比例低于85%，server会将当前的服务实例清单保护起来，让这些实例不会过期。但是假设保护期内服务异常，客户端拿到失效的实例，就会出现调用失败的情况，所以客户端需要有容错机制。如请求重试、断路器机制。 # 关闭保护机制 eureka.server.enable-self-preservation=false","categories":[{"name":"springCloud","slug":"springCloud","permalink":"http://yoursite.com/categories/springCloud/"}],"tags":[{"name":"eureka","slug":"eureka","permalink":"http://yoursite.com/tags/eureka/"}]},{"title":"【并发】3大JUC工具类","slug":"【并发】3大JUC工具类","date":"2020-06-07T07:40:08.000Z","updated":"2020-06-07T10:33:45.445Z","comments":true,"path":"2020/06/07/【并发】3大JUC工具类/","link":"","permalink":"http://yoursite.com/2020/06/07/%E3%80%90%E5%B9%B6%E5%8F%91%E3%80%913%E5%A4%A7JUC%E5%B7%A5%E5%85%B7%E7%B1%BB/","excerpt":"","text":"一、减法计数器countDownLatchCountDownLatch用于监听某些初始化操作，等待初始化执行完毕，通知主线程继续工作，允许一个或者多个线程等待其他线程完成操作。 通俗的讲就是实现线程等待，主线程countDown.await();进行阻塞，其他线程countDown.countDown();进行计数器-1操作，当计数器归零后，主线程唤醒继续操作。 要实现线程等待还有一个方法就是jion方法。Join用于让当前执行线程等待“Join线程”执行结束，实现原理是，不停的检查Join线程是否存活，如果存活则让当前线程永远等待下去，如果Join线程终止，则调用this.notifyAll方法唤醒等待的线程。 CountDownLatch其实也是来做这件事的，而且比Join更强大，使用起来也很轻便。 public class MyCountDownLatch &#123; public static void main(String[] args) &#123; CountDownLatch countDownLatch = new CountDownLatch(2); // 线程a在执行后，经过await进行阻塞，当其他线程将countDownLatch减为0后，a继续执行 new Thread(()-&gt;&#123; System.out.println(Thread.currentThread().getName() + \"开始执行\"); try &#123; countDownLatch.await(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(Thread.currentThread().getName() + \"执行完成\"); &#125;, \"a\").start(); new Thread(()-&gt;&#123; System.out.println(Thread.currentThread().getName() + \"开始执行\"); countDownLatch.countDown(); System.out.println(Thread.currentThread().getName() + \"执行完成\"); &#125;, \"b\").start(); new Thread(()-&gt;&#123; System.out.println(Thread.currentThread().getName() + \"开始执行\"); countDownLatch.countDown(); System.out.println(Thread.currentThread().getName() + \"执行完成\"); &#125;, \"c\").start(); &#125; &#125; CountDownLatch是通过一个计数器来实现的，当我们在new 一个CountDownLatch对象的时候需要带入该计数器值，该值就表示了线程的数量。每当一个线程完成自己的任务后，计数器的值就会减1。当计数器的值变为0时，就表示所有的线程均已经完成了任务，然后就可以恢复等待的线程继续执行了。 二、加法计数器CyclicbarrierCyclicbarrier指的是可循环使用的屏障，主要是让一组线程到达一个屏障之后被阻塞，当最后一个线程到达时，屏障才会开门，所有被屏障拦截的线程才会继续干活。 public class MyCyclicBarrier &#123; public static void main(String[] args) &#123; // CyclicBarrier cyclicBarrier = new CyclicBarrier(5); // 线程都ready后，会先执行该 barrierAction ，再执行各子线程的下一步任务 CyclicBarrier cyclicBarrier = new CyclicBarrier(5, ()-&gt; System.out.println(\"all is ready\")); for (int i = 0; i &lt; 5; i++) &#123; new Thread(()-&gt;&#123; System.out.println(Thread.currentThread().getName()+\" is ready\"); // int numberWaiting = cyclicBarrier.getNumberWaiting(); try &#123; cyclicBarrier.await(); &#125; catch (InterruptedException | BrokenBarrierException e) &#123; e.printStackTrace(); &#125; System.out.println(Thread.currentThread().getName()+\" is going\"); &#125;, \"线程\"+i).start(); &#125; System.out.println(\"this is main\"); &#125; &#125; 1、区别 CountDownLatch的计数器只能使用一次。而CyclicBarrier的计数器可以使用reset() 方法重置。 CountDownLatch的作用是允许1或N个线程等待其他线程完成执行；而CyclicBarrier则是允许N个线程相互等待。 CountDownLatch的计数器无法被重置；CyclicBarrier的计数器可以被重置后使用，因此它被称为是循环的barrier。 2、使用场景 确保某个计算在其需要的所有的资源都被初始化之后才继续执行。 确保某个服务在其依赖的所有其他服务都已经启动之后才启动。 等待直到某个操作所有参与者都准备就绪再继续执行。 J.U.C之并发工具类：CyclicBarrier J.U.C之并发工具类：CountDownLatch 三、信号量semaphore 信号量维护了一个许可集，线程通过acquire()获得许可，在达到许可上限时，会阻塞其他acquire()的线程。已获得许可的线程进行 release() 后，被阻塞的线程才可获得许可。 信号量，一般用于限流，或者限制访问某些资源的线程数目。 Semaphore默认选择非公平锁。可通过构造函数传入true，声明为公平锁。 当信号量Semaphore = 1 时，它可以当作互斥锁使用。其中0、1就相当于它的状态，当=1时表示其他线程可以获取，当=0时，排他，即其他线程必须要等待。 public class MySemaphore &#123; public static void main(String[] args) &#123; Semaphore semaphore = new Semaphore(3); for (int i = 0; i &lt; 10; i++) &#123; new Thread(()-&gt;&#123; try &#123; semaphore.acquire(); System.out.println(Thread.currentThread().getName()+\"进行占位\"); TimeUnit.SECONDS.sleep(1); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; finally &#123; semaphore.release(); System.out.println(Thread.currentThread().getName()+\"释放位置\"); &#125; &#125;, \"thread-\"+i).start(); &#125; &#125; &#125; J.U.C之并发工具类：Semaphore","categories":[{"name":"java","slug":"java","permalink":"http://yoursite.com/categories/java/"}],"tags":[{"name":"thread","slug":"thread","permalink":"http://yoursite.com/tags/thread/"}]},{"title":"【并发】阻塞队列（BlockingQueue）","slug":"【并发】阻塞队列","date":"2020-06-07T01:43:26.000Z","updated":"2020-06-07T07:41:03.947Z","comments":true,"path":"2020/06/07/【并发】阻塞队列/","link":"","permalink":"http://yoursite.com/2020/06/07/%E3%80%90%E5%B9%B6%E5%8F%91%E3%80%91%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97/","excerpt":"","text":"一、什么是阻塞队列阻塞队列是一种特殊的支持阻塞的插入和移除的特殊容器。 阻塞插入： 当队列满时，向队列中插入元素的线程会被阻塞，直到队列中有元素被移除。 即队列不满时，才能插入元素，否则阻塞。 阻塞移除： 当队列为空时，从队列中移除数据的线程会被阻塞，直到队列中有新的元素被添加。 即队列不为空时，才能取出元素，否则阻塞。 二、常见方法 方法 备注 add/remove 增删元素，失败抛出异常 offer/poll 增删元素，可设置等待时间，失败或超时返回false put/take 增删元素，一直等待 三、常见阻塞队列BlockingQueue是一个接口，主要有下面7种实现类： 实现 备注 ArrayBlockingQueue 基于数组的阻塞队列实现，在其内部，维护了一个定长数组，以便缓存队列中的数据对象；其内部没实现读写分离，也就意味着生产和消费不能完全并行；长度是需要自己定义的，可以指定先进先出或者先进后出，也被称为“有界队列” LinkedBlockingQueue 基于链表的阻塞队列，其内部维持着一个数据缓冲队列（该队列由一个链表构成）；LinkedBlockingQueue之所以能够高效的处理并发数据，是因为其内部实现采用分离锁（读写分离两个锁），从而实现生产者和消费者操作完全并发执行，也是一个“无界队列” PriorityBlockingQueue 基于优先级的阻塞队列（优先级的判断通过构造函数传入的Compator（比较器）对象决定，也就是说传入队列的对象必须实现Comparable接口），在实现PriorityBlockingQueue时，内部控制线程同步的锁采用的是公平锁，是一个“无界队列”PriorityBlockingQueue调用take后需要重新排序，调一次重新排一次 DelayQueue 带有延迟时间的无界阻塞Queue，其中的元素只有当指定的延迟时间到了，才能够从队列中获取该元素。DelayQueue中的元素必须实现Delayed接口，DelayQueue是一个没有大小限制的队列，应用场景比较多，比如对缓存超时的数据进行移除，任务超时处理，空间连接的关闭等等 SynchronousQueue 不存储任何元素的队列，生产者产生的数据直接会被消费者获取并消费，即每一个put操作必须等待一个take操作，否则不能继续添加元素，或者可以理解为是只能存储一个元素的队列，存一个就满了，该元素必须被移除掉，才能继续添加 LinkedTransferQueue 一个由链表结构组成的无界阻塞传输队列，主要体现在LinkedTransferQueue多2个方法transfer(E)：如果当前有消费者正在等待消费，则生产者直接把元素传输给消费者，如果当前没有消费者正在等待消费，则生产者将元素存放在队列的tail节点上，并等到该元素被消费才返回（采用自旋等待）；tryTransfer(E,long,TimeUnit)：将元素立刻给消费者，如果没有消费者就等待指定时间。时间到时，如果还没有消费者则失败返回false； LinkedBlockingDeque 由链表结构组成的双向阻塞队列，即可以从队列的两端插入和移出元素 四、阻塞队列的底层实现阻塞队列的底层是等待通知机制来实现的： 当生产者往一个满队列中添加元素时，生产者会被阻塞；等消费者从该队列中消费了一个元素后，会通知阻塞的插入操作的生产者线程，可以继续执行添加操作。 当消费者从一个空队列中移除元素时，消费者会被阻塞；等生产者向队列中增加了一个元素后，会通知阻塞的移除操作的消费者线程，可以继续执行移除操作。","categories":[{"name":"java","slug":"java","permalink":"http://yoursite.com/categories/java/"}],"tags":[{"name":"thread blockingQueue","slug":"thread-blockingQueue","permalink":"http://yoursite.com/tags/thread-blockingQueue/"}]},{"title":"【并发】生产者消费者","slug":"【并发】生产者消费者","date":"2020-06-05T13:44:03.000Z","updated":"2020-06-07T07:40:54.141Z","comments":true,"path":"2020/06/05/【并发】生产者消费者/","link":"","permalink":"http://yoursite.com/2020/06/05/%E3%80%90%E5%B9%B6%E5%8F%91%E3%80%91%E7%94%9F%E4%BA%A7%E8%80%85%E6%B6%88%E8%B4%B9%E8%80%85/","excerpt":"","text":"一、生产者消费者生产者和消费者在同一时间段内共用同一段存储空间，生产者put数据，消费者take数据 阻塞队列就相当于一个缓冲区，平衡了生产者和消费者的处理能力，将他们解耦。 二、四种实现生产者消费者模型1、Object的wait() / notify()方法wait/notify 是Object的方法，因此我们可以给任何对象实现同步机制。 wait：当缓冲区满时，生产者/消费者放弃锁，让度cpu，使自己处于等待状态。 notify：当生产者/消费者 生产/消费 时，放弃锁，向其他线程发出可执行的通知，使自己处于等待状态。 public class ProducerConsumer &#123; private static final int CAPACITY = 5; private static final Queue&lt;Integer&gt; queue = new LinkedList&lt;Integer&gt;(); public static void main(String[] args) &#123; // 模拟生产者 for (int i = 0; i &lt; 3; i++) &#123; new Thread(()-&gt; produce(),\"procuder-\"+ i).start(); &#125; // 模拟消费者 for (int i = 0; i &lt; 5; i++) &#123; new Thread(()-&gt; consume(),\"consumer-\"+ i).start(); &#125; // 主线程睡眠，便于看效果 try &#123; TimeUnit.SECONDS.sleep(2); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.exit(0); &#125; private static void consume() &#123; while (true) &#123; synchronized (queue) &#123; while (queue.isEmpty()) &#123; try &#123; // 空队列，则不能消费 System.out.println(Thread.currentThread().getName() + \" 等待生产\"); queue.wait(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; // 队列不为空，则正常消费 Integer poll = queue.poll(); System.out.println(Thread.currentThread().getName() + \" 消费了\" + poll); queue.notifyAll(); // 线程睡眠，便于看效果 try &#123; TimeUnit.MILLISECONDS.sleep(100); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125; private static void produce() &#123; int k = 0; while (true) &#123; synchronized (queue) &#123; while (queue.size() == CAPACITY) &#123; try &#123; // 满了则wait System.out.println(Thread.currentThread().getName() + \" 等待消费\"); queue.wait(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; // 没满则往queue中添加元素 System.out.println(Thread.currentThread().getName() + \" 生产了\" + k); queue.offer(k++); queue.notifyAll(); // 线程睡眠，便于看效果 try &#123; TimeUnit.MILLISECONDS.sleep(100); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125; &#125; 使用while进行size=queueSize、isEmpty的判断，使用if会造成虚假唤醒。 2、Lock中condition的await()/signal()方法通过在lock对象上调用newCondition()，将变量和锁对象进行绑定，进而控制并发资源的安全。 public class LockCondition &#123; private static final int CAPACITY = 5; private static final ReentrantLock lock = new ReentrantLock(); private static final Condition fullCondition = lock.newCondition(); private static final Condition emptyCondition = lock.newCondition(); private static final Queue&lt;Integer&gt; queue = new LinkedList&lt;&gt;(); public static void main(String[] args) &#123; for (int i = 0; i &lt; 3; i++) &#123; new Thread(() -&gt; produce(), \"product-\" + i).start(); &#125; for (int i = 0; i &lt; 3; i++) &#123; new Thread(() -&gt; consume(), \"consumer-\" + i).start(); &#125; // 主线程睡眠，便于看效果 try &#123; TimeUnit.SECONDS.sleep(2); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.exit(0); &#125; private static void consume() &#123; while (true) &#123; if (lock.tryLock()) &#123; try &#123; while (queue.isEmpty()) &#123; // 队列为空，释放锁，通知生产者去生产 System.out.println(Thread.currentThread().getName() + \" 队列为空，等待生产\"); emptyCondition.await(); &#125; Integer poll = queue.poll(); System.out.println(Thread.currentThread().getName() + \" 消费了 \" + poll); //唤醒其他所有生产者、消费者 fullCondition.signalAll(); emptyCondition.signalAll(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; finally &#123; if (lock.isHeldByCurrentThread()) &#123; lock.unlock(); &#125; &#125; &#125; // 线程睡眠，便于看效果 try &#123; TimeUnit.MILLISECONDS.sleep(new Random().nextInt(100)); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125; private static void produce() &#123; while (true) &#123; int k = 0; if (lock.tryLock()) &#123; try &#123; while (queue.size() == CAPACITY) &#123; // 队列满了，释放锁，通知消费者去消费 System.out.println(Thread.currentThread().getName() + \" 队列满了，等待消费\"); fullCondition.await(); &#125; System.out.println(Thread.currentThread().getName() + \" 生产了\" + k); queue.offer(k++); //唤醒其他所有生产者、消费者 emptyCondition.signalAll(); fullCondition.signalAll(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; finally &#123; if (lock.isHeldByCurrentThread()) &#123; lock.unlock(); &#125; &#125; &#125; // 线程睡眠，便于看效果 try &#123; TimeUnit.MILLISECONDS.sleep(new Random().nextInt(100)); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125; await和signal需组合使用。在案例中阻塞时用了await，但是唤醒时用的notify，导致运行过程中一直报错IllegalMonitorStateException 3、使用blockQueue阻塞队列方法jdk对2方式的一种封装，可直接使用。 在juc下，有ArrayBlockingQueue、LinkedBlockingQueue、SynchronousQueue、PriorityBlockingQueue四种实现。 实现生产者-消费者模型使用 ArrayBlockingQueue或者 LinkedBlockingQueue即可。 public class MyBlockingQueue &#123; private static final int CAPICITY = 3; private static final int MAX = 30; private static final LinkedBlockingQueue&lt;Integer&gt; queue = new LinkedBlockingQueue&lt;&gt;(CAPICITY); public static void main(String[] args) &#123; for (int i = 0; i &lt; 3; i++) &#123; new Thread(() -&gt; produce(), \"product-\" + i).start(); &#125; for (int i = 0; i &lt; 3; i++) &#123; new Thread(() -&gt; consume(), \"consumer-\" + i).start(); &#125; // 主线程睡眠，便于看效果 try &#123; TimeUnit.SECONDS.sleep(2); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.exit(0); &#125; static void produce() &#123; int k = 0; while (k &lt; MAX) &#123; try &#123; System.out.println(Thread.currentThread().getName() + \" 生产了\" + k); queue.put(k++); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; // 线程睡眠，便于看效果 try &#123; TimeUnit.MILLISECONDS.sleep(new Random().nextInt(100)); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125; static void consume() &#123; while (true) &#123; try &#123; Integer take = queue.take(); System.out.println(Thread.currentThread().getName() + \"消费了\" + take); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; // 线程睡眠，便于看效果 try &#123; TimeUnit.MILLISECONDS.sleep(new Random().nextInt(100)); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125; put()方法：类似于我们上面的生产者线程，容量达到最大时，自动阻塞。 take()方法：类似于我们上面的消费者线程，容量为0时，自动阻塞。 4、PipedInputStream / PipedOutputStream","categories":[{"name":"java","slug":"java","permalink":"http://yoursite.com/categories/java/"}],"tags":[{"name":"thread queue","slug":"thread-queue","permalink":"http://yoursite.com/tags/thread-queue/"}]},{"title":"springboot自定义starter","slug":"springboot自定义starter","date":"2020-06-03T14:46:40.000Z","updated":"2020-06-03T15:02:44.539Z","comments":true,"path":"2020/06/03/springboot自定义starter/","link":"","permalink":"http://yoursite.com/2020/06/03/springboot%E8%87%AA%E5%AE%9A%E4%B9%89starter/","excerpt":"","text":"写在前面按照约定，官方的为spring-boot-xxx-starter ，非官方的为 xxx-spring-boot-starter 一、Spring Boot starter机制 Spring Boot中的starter是一种非常重要的机制，应用者只需要在maven中引入starter依赖，Spring Boot就能自动扫描到要加载的信息并启动相应的默认配置。 starter让我们摆脱了各种依赖库的处理，需要配置各种信息的困扰。 Spring Boot会自动通过classpath路径下的类发现需要的Bean，并注册进IOC容器。 Spring Boot提供了针对日常企业应用研发各种场景的spring-boot-starter依赖模块。所有这些依赖模块都遵循着约定成俗的默认配置，并允许我们调整这些配置，即遵循“约定大于配置”的理念。 二、自定义starter的条件如果想自定义Starter，首选需要实现自动化配置，而要实现自动化配置需要满足以下两个条件： 能够自动配置项目所需要的配置信息，也就是自动加载依赖环境； 能够根据项目提供的信息自动生成Bean，并且注册到Bean管理容器中； 三、自定义starter代码部分1、pom文件&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt; &lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.ztf&lt;/groupId&gt; &lt;artifactId&gt;orange-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;dependencies&gt; &lt;!-- https://mvnrepository.com/artifact/org.springframework.boot/spring-boot-autoconfigure --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-autoconfigure&lt;/artifactId&gt; &lt;version&gt;2.3.0.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-configuration-processor&lt;/artifactId&gt; &lt;version&gt;2.3.0.RELEASE&lt;/version&gt; &lt;!--该依赖只能在本项目中传递，不会传递到引用该项目的父项目中，父项目有需要需主动引用该依赖。--&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;version&gt;1.18.6&lt;/version&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;/project&gt; 2、定义XxxProperties 属性配置类， 设置属性前缀，用于在application.properties中配置。 package com.ztf; import lombok.Data; import org.springframework.boot.context.properties.ConfigurationProperties; @ConfigurationProperties(prefix = \"local.orange\") @Data public class MyProperties &#123; private String id; private String name; private int age; &#125; 3、定义XxxService逻辑操作类package com.ztf; public class MyService &#123; MyProperties myProperties; public void setMyProperties(MyProperties myProperties) &#123; this.myProperties = myProperties; &#125; public MyService(MyProperties myProperties) &#123; this.myProperties = myProperties; &#125; public void helloWorld() &#123; System.out.println(\"hi, 我叫: \" + myProperties.getName() + \", id:\" + myProperties.getId() + \"岁\" + \", 年龄: \" + myProperties.getAge()); &#125; &#125; 4、定义XxxAutoConfiguration自动配置类 用于完成Bean创建等工作。 package com.ztf; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.boot.autoconfigure.condition.ConditionalOnClass; import org.springframework.boot.autoconfigure.condition.ConditionalOnMissingBean; import org.springframework.boot.autoconfigure.condition.ConditionalOnProperty; import org.springframework.boot.context.properties.EnableConfigurationProperties; import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.Configuration; @Configuration @EnableConfigurationProperties(MyProperties.class) @ConditionalOnClass(MyService.class) @ConditionalOnProperty(prefix = \"local.orange\", value = \"enabled\", matchIfMissing = true) public class MyServiceAutoConfiguration &#123; @Autowired MyProperties myProperties; @Bean @ConditionalOnMissingBean(MyService.class) public MyService myService() &#123; return new MyService(myProperties); &#125; &#125; 5、在spring.factories中声明 在resources下创建目录META-INF，在 META-INF 目录下创建 spring.factories，在SpringBoot启动时会根据此文件来加载项目的自动化配置类。 spring.factories内容如下： org.springframework.boot.autoconfigure.EnableAutoConfiguration=com.ztf.MyServiceAutoConfiguration 四、自定义starter使用1、pom中引用自定义starter的jar&lt;dependency&gt; &lt;groupId&gt;com.ztf&lt;/groupId&gt; &lt;artifactId&gt;orange-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;/dependency&gt; 2、yml配置文件中声明参数## 自定义的一个starter local: orange: id: 007 name: myorange age: 18 3、项目中使用@Autowired MyService myService; @GetMapping(\"/test\") public String testMyStarter() &#123; myService.helloWorld(); return \"ok\"; &#125; 六、总结 Spring Boot在启动时扫描项目所依赖的JAR包，寻找包含spring.factories文件的JAR包， 然后读取spring.factories文件获取配置的自动配置类AutoConfiguration， 然后将自动配置类下满足条件(@ConditionalOnXxx)的@Bean放入到Spring容器中(Spring Context) 这样使用者就可以直接用来注入，因为该类已经在容器中了","categories":[{"name":"java","slug":"java","permalink":"http://yoursite.com/categories/java/"}],"tags":[{"name":"springboot","slug":"springboot","permalink":"http://yoursite.com/tags/springboot/"}]},{"title":"mac环境变量配置","slug":"mac环境变量配置","date":"2020-06-03T13:10:43.000Z","updated":"2020-06-03T13:13:25.334Z","comments":true,"path":"2020/06/03/mac环境变量配置/","link":"","permalink":"http://yoursite.com/2020/06/03/mac%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E9%85%8D%E7%BD%AE/","excerpt":"","text":"gradle环境变量配置vi ~/.bash_profile # 增加gradle环境变量，如下： export GRADLE_HOME=/Users/orange/Documents/gradle-6.4 export PATH=$PATH:$GRADLE_HOME/bin # 刷新 source ~/.bash_profile # 查看版本 gradle -version","categories":[{"name":"idea","slug":"idea","permalink":"http://yoursite.com/categories/idea/"}],"tags":[{"name":"环境变量","slug":"环境变量","permalink":"http://yoursite.com/tags/%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/"}]},{"title":"mybatis-generator","slug":"mybatis-generator","date":"2020-06-02T13:36:54.000Z","updated":"2020-06-03T12:18:35.200Z","comments":true,"path":"2020/06/02/mybatis-generator/","link":"","permalink":"http://yoursite.com/2020/06/02/mybatis-generator/","excerpt":"","text":"1.作用用来自动生成MyBatis的 mapper、dao、entity 2.使用MyBatis Generator的使用方式有4种： 命令行生成 Maven方式生成 使用Ant任务生成 使用Java代码生成 其中推荐使用Maven方式进行代码生成，因为集成和使用比较简单。 3.代码自动生成配置Step1：配置pom中plugin依赖&lt;plugin&gt; &lt;groupId&gt;org.mybatis.generator&lt;/groupId&gt; &lt;artifactId&gt;mybatis-generator-maven-plugin&lt;/artifactId&gt; &lt;version&gt;1.4.0&lt;/version&gt; &lt;executions&gt; &lt;execution&gt; &lt;id&gt;Generate MyBatis Artifacts&lt;/id&gt; &lt;phase&gt;package&lt;/phase&gt; &lt;goals&gt; &lt;goal&gt;generate&lt;/goal&gt; &lt;/goals&gt; &lt;/execution&gt; &lt;/executions&gt; &lt;configuration&gt; &lt;!--允许移动生成的文件 --&gt; &lt;verbose&gt;true&lt;/verbose&gt; &lt;!-- 是否覆盖 --&gt; &lt;overwrite&gt;true&lt;/overwrite&gt; &lt;!-- 自动生成的配置 --&gt; &lt;configurationFile&gt;src/main/resources/generatorConfig.xml&lt;/configurationFile&gt; &lt;!--将当前pom的依赖项添加到生成器的类路径中--&gt; &lt;includeCompileDependencies&gt;true&lt;/includeCompileDependencies&gt; &lt;/configuration&gt; &lt;/plugin&gt; Step2：配置generatorConfig.xml文件&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt; &lt;!--mybatis的代码生成器相关配置--&gt; &lt;!DOCTYPE generatorConfiguration PUBLIC \"-//mybatis.org//DTD MyBatis Generator Configuration 1.0//EN\" \"http://mybatis.org/dtd/mybatis-generator-config_1_0.dtd\"&gt; &lt;generatorConfiguration&gt; &lt;!-- 引入配置文件 --&gt; &lt;properties resource=\"application.yml\"/&gt; &lt;context id=\"Mysql\" targetRuntime=\"MyBatis3Simple\" defaultModelType=\"flat\"&gt; &lt;property name=\"autoDelimitKeywords\" value=\"true\" /&gt; &lt;property name=\"beginningDelimiter\" value=\"`\" /&gt; &lt;property name=\"endingDelimiter\" value=\"`\" /&gt; &lt;property name=\"javaFileEncoding\" value=\"utf-8\" /&gt; &lt;plugin type=\"org.mybatis.generator.plugins.SerializablePlugin\" /&gt; &lt;commentGenerator &gt; &lt;!-- 不生成注释 --&gt; &lt;property name=\"suppressAllComments\" value=\"true\"/&gt; &lt;!-- 不生成注释代时间戳--&gt; &lt;property name=\"suppressDate\" value=\"true\" /&gt; &lt;/commentGenerator&gt; &lt;!--数据库链接地址账号密码--&gt; &lt;!--&lt;jdbcConnection driverClass=\"$&#123;spring.datasource.driver-class-name&#125;\"--&gt; &lt;!--connectionURL=\"$&#123;spring.datasource.url&#125;\"--&gt; &lt;!--userId=\"$&#123;spring.datasource.username&#125;\"--&gt; &lt;!--password=\"$&#123;spring.datasource.password&#125;\"&gt;--&gt; &lt;!--&lt;/jdbcConnection&gt;--&gt; &lt;jdbcConnection driverClass=\"com.mysql.cj.jdbc.Driver\" connectionURL=\"jdbc:mysql://localhost:3306/display\" userId=\"root\" password=\"P@ssw0rd\"&gt; &lt;/jdbcConnection&gt; &lt;!-- 类型转换 --&gt; &lt;javaTypeResolver&gt; &lt;!-- 是否使用bigDecimal， false可自动转化以下类型（Long, Integer, Short, etc.） --&gt; &lt;property name=\"forceBigDecimals\" value=\"false\"/&gt; &lt;/javaTypeResolver&gt; &lt;!--生成Model类存放位置--&gt; &lt;javaModelGenerator targetPackage=\"com.ztf.mybatisplus.bean\" targetProject=\"src/main/java\"&gt; &lt;property name=\"enableSubPackages\" value=\"true\"/&gt; &lt;property name=\"trimStrings\" value=\"true\"/&gt; &lt;/javaModelGenerator&gt; &lt;!-- 生成mapxml文件 --&gt; &lt;sqlMapGenerator targetPackage=\"mapper\" targetProject=\"src/main/resources/mybatis\" &gt; &lt;property name=\"enableSubPackages\" value=\"false\" /&gt; &lt;/sqlMapGenerator&gt; &lt;!-- 生成mapper java文件 --&gt; &lt;javaClientGenerator targetPackage=\"com.ztf.mybatisplus.dao\" targetProject=\"src/main/java\" type=\"XMLMAPPER\" &gt; &lt;property name=\"enableSubPackages\" value=\"false\" /&gt; &lt;/javaClientGenerator&gt; &lt;!--具体解析的表，建议配置domainObjectName属性，避免带上表前缀T_--&gt; &lt;table tableName=\"t_corp\" enableCountByExample=\"true\" domainObjectName=\"Corp\" enableUpdateByExample=\"true\" enableDeleteByExample=\"true\" enableSelectByExample=\"true\" selectByExampleQueryId=\"true\"&gt; &lt;!--&lt;generatedKey column=\"id\" sqlStatement=\"Mysql\" identity=\"true\" /&gt;--&gt; &lt;/table&gt; &lt;!--&lt;table tableName=\"user_log\" enableCountByExample=\"true\" --&gt; &lt;!--enableUpdateByExample=\"true\" enableDeleteByExample=\"true\" --&gt; &lt;!--enableSelectByExample=\"true\" selectByExampleQueryId=\"true\"&gt;--&gt; &lt;!--&lt;generatedKey column=\"id\" sqlStatement=\"Mysql\" identity=\"true\" /&gt;--&gt; &lt;!--&lt;/table&gt;--&gt; &lt;/context&gt; &lt;/generatorConfiguration&gt; 4.注意事项 MyBatis Generator 只会覆盖旧的 po、dao、而 mapper.xml 不会覆盖，而是追加，这样做的目的是防止用户自己写的 sql 语句一不小心都被 MyBatis Generator 给覆盖了 &lt;!-- 是否覆盖 --&gt; &lt;overwrite&gt;true&lt;/overwrite&gt; 一般配置了 includeCompileDependencies 后就不需要配置其他依赖了，因为 includeCompileDependencies 会将当前 pom 的 dependencies 中所有 Compile 期的依赖全部添加到生成器的类路径中。 &lt;!--将当前pom的依赖项添加到生成器的类路径中--&gt; &lt;includeCompileDependencies&gt;true&lt;/includeCompileDependencies&gt; 数据库文件yml方式加载不进来配置，写成application.properties&quot;方式就可以 &lt;!-- 引入配置文件 --&gt; &lt;properties resource=\"application-dev.properties\"/&gt; context属性 id : 随便填，保证多个 context id 不重复就行 defaultModelType ： 可以不填，默认值 conditional，flat表示一张表对应一个po targetRuntime ：可以不填，默认值 MyBatis3，常用的还有 MyBatis3Simple。MyBatis3Simple生成的 dao 和 mapper.xml 内容较少，但也包含了最常用的。 context的子元素要求有序 1. **property** (0..N) 2. **plugin** (0..N) 3. **commentGenerator** (0 or 1) 4. **jdbcConnection** (需要connectionFactory 或 jdbcConnection) 5. **javaTypeResolver** (0 or 1) 6. **javaModelGenerator** (至少1个) 7. **sqlMapGenerator** (0 or 1) 8. **javaClientGenerator** (0 or 1) 9. **table** (1..N) commentGenerator 默认生成注释和时间戳，可显式的声明某一项不生成。建议全部显式不生成。 &lt;commentGenerator&gt; &lt;!-- 不希望生成的注释中包含时间戳 --&gt; &lt;property name=\"suppressDate\" value=\"true\"/&gt; &lt;!-- 不希望生成的注释中包含注释 --&gt; &lt;property name=\"suppressAllComments\" value=\"true\"/&gt; &lt;/commentGenerator&gt; type=&quot;XMLMAPPER&quot; 会将接口的实现放在 mapper.xml中，也推荐这样配置。也可以设置 type=&quot;ANNOTATEDMAPPER&quot;，接口的实现通过注解写在接口上面 一个 table 对应一张表，如果想同时生成多张表，需要配置多个 table domainObjectName 不配置时，它会按照帕斯卡命名法将表名转换成类名，建议配置该属性，避免带上表前缀T_ &lt;domainObjectRenamingRule searchString=\"^T\" replaceString=\"\" /&gt; 表字段也会默认带上c_、d_，可设置去掉 &lt;!-- 这个意思就是匹配，开头的任意个非下划线(_)的字符，也就是这种如：c_，d_ 等等 --&gt; &lt;columnRenamingRule searchString=\"^[^_]+\" replaceString=\"\"/&gt; &lt;!-- 也可如下只去掉c_--&gt; &lt;columnRenamingRule searchString=\"^c_\" replaceString=\"\" /&gt; enableXXXByExample 默认为true，但只有在targetRuntime=&quot;MyBatis3&quot;时才生效。当 targetRuntime=&quot;MyBatis3Simple&quot;时，enableXXXByExample 不管为true、还是false 都不生效。一般建议全设置为false，true的话会生成很多Example帮助类，造成很多sonar问题。 4.参考Spring Boot （七）MyBatis代码自动生成和辅助插件 MyBatis Generator 超详细配置","categories":[{"name":"mybatis","slug":"mybatis","permalink":"http://yoursite.com/categories/mybatis/"}],"tags":[{"name":"mybatis-generator","slug":"mybatis-generator","permalink":"http://yoursite.com/tags/mybatis-generator/"}]},{"title":"性能优化策略","slug":"性能优化策略","date":"2020-06-01T12:42:04.000Z","updated":"2020-06-01T13:25:08.525Z","comments":true,"path":"2020/06/01/性能优化策略/","link":"","permalink":"http://yoursite.com/2020/06/01/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E7%AD%96%E7%95%A5/","excerpt":"","text":"一、时空转换1.1 时间换空间 场景1: 降低内存空间的占用。 场景2: 降低数据的大小来方便网络传输和外部存储。 具体方式： 1、改变数据结构或者数据格式，减少要存储的数据大小。 2、使用压缩算法，压缩内存中的数据，使用时解压。 3、把内存中的数据存储到外部的、更便宜的存储设备中，需要时再取回来。 这些节省内存空间的方法，一般都需要付出时间的代价。 衡量任何压缩算法，基本上看三个指标：压缩比例、压缩速度以及使用内存。 如果系统的瓶颈在网络传输速度或者存储空间大小上，那就尽量采取高压缩比的算法。 1.2 空间换时间 场景：要求快速响应。 具体方式： 1、对数据和服务进行多份拷贝，尽大可能的覆盖更多的用户。 典型案例：集群 二、预处理和延后处理2.1 预处理/提前处理使用场景： 1、web静态资源提前加载，preload 和 prefetch。 2、文件系统预读功能。提前从磁盘读取下一次的数据。 这个功能对顺序读取十分有效，可以减少磁盘请求的数量 2.2 延后/惰性处理 尽量将操作推迟到必须执行的时刻。 使用场景： 1、COW（copy on write）写时复制。多线程读取共享资源时，不进行复制操作，当某个线程需要对资源进行修改时，才拷贝一份到工作内存，使其不会影响其他线程。 三、并行和并发四、缓存/批量合并4.1 缓存 缓存的本质是加速访问。 使用场景： 1、对于一个基于 Web 的应用服务，前端会有浏览器缓存，有 CDN 存放在边缘服务器上，有反向代理提供的静态内容缓存；后端则还会有服务器本地缓存。 2、程序设计中，对于可能重复创建和销毁，且创建销毁代价很大的对象（比如套接字和线程），也可以缓存，对应的缓存形式，就是连接池和线程池等。 3、对于消耗较大的计算，也可以将计算结果缓存起来，下次可以直接读取结果。比如对递归代码的一个有效优化手段，就是缓存中间结果。 4.2批量合并 在有 IO（比如网络 IO 和磁盘 IO）的时候，合并操作和批量操作往往能提升吞吐量，提高性能。 使用场景： 1、批量 IO 读写。就是在有多次 IO 的时候，可以把它们合并成一次读写数据。这样可以减少读写时间和协议负担。 2、对数据库的读写操作，也可以尽量合并。比如，对键值数据库的查询，最好一次查询多个键，而不要分成多次。 3、涉及到网络请求的时候，网络传输的时间可能远大于请求的处理时间，因此合并网络请求也很有必要。 五、更高效的算法和数据结构附录：参考文档","categories":[{"name":"总结","slug":"总结","permalink":"http://yoursite.com/categories/%E6%80%BB%E7%BB%93/"}],"tags":[{"name":"性能优化","slug":"性能优化","permalink":"http://yoursite.com/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"}]},{"title":"服务熔断","slug":"服务熔断","date":"2020-05-31T14:43:58.000Z","updated":"2020-05-31T15:45:41.762Z","comments":true,"path":"2020/05/31/服务熔断/","link":"","permalink":"http://yoursite.com/2020/05/31/%E6%9C%8D%E5%8A%A1%E7%86%94%E6%96%AD/","excerpt":"","text":"服务熔断 hystrix，是一个用于处理分布式系统延迟和容错的库，它能够保证在一个子服务出问题的情况下，不会导致整体服务失败，避免级联雪崩，以提高分布式系统的弹性。 “断路器”本身是一个开关装置，当某个服务单元发生故障后，向调用方返回一个服务预期的、可处理的备选响应，而不是长时间等待或者抛出一个服务端无法处理的异常。这样就保证了调用方线程不会被长时间占用，从而避免故障在分布式系统中蔓延，甚至雪崩。 1、服务降级（客户端提供异常响应） 限制其他低相关服务的访问，使他们占用计算机较少的资源，从而保障主服务拥有更多的资源，使其能正常访问。 // 配置文件默认关闭，需手动开启 feign: hystrix: enabled: true # 启用服务降级 @FeignClient(name = \"MYCLOUD-PROVIDER\", fallback = HystrixConsumerService.class) public interface CorpConsumerService &#123; @GetMapping(\"/corps/&#123;id&#125;\") Corp getCorp(@PathVariable(\"id\") String id); @GetMapping(\"/corps\") List&lt;Corp&gt; getCorps(); &#125; // 客户端熔断回调缺省值处理 // 假设服务端未启动，即这么处理 @Service public class HystrixConsumerService implements CorpConsumerService &#123; public Corp getCorp(String id) &#123; return Corp.builder().id(id).name(\"HystrixConsumerService\").age(40).build(); &#125; public List&lt;Corp&gt; getCorps() &#123; return null; &#125; &#125; 2、服务熔断（服务端返回合适的异常响应） 熔断机制是对微服务雪崩效应的一种链路保护机制。 当扇出链路的某个微服务不可用或者响应时间太长时，会进行服务的降级，进而熔断该节点的微服务调用，快速返回错误的响应信息，当检测到该微服务调用响应正常后恢复调用链路。 hystrix会监控微服务之间的调用状况，当失败的调用到一定阈值，缺省是5s内20ci调用失败就会触发。熔断机制的注解是@HystrixCommand。 // 启动类配置enable @SpringBootApplication @EnableEurekaClient @EnableHystrix public class CorpProvider8005 &#123; public static void main(String[] args) &#123; SpringApplication.run(CorpProvider8005.class, args); &#125; &#125; // 添加@HystrixCommand注解 // 发生异常时，会调用hystrixCorp方法，控制台无异常堆栈 @GetMapping(\"/corps/&#123;id&#125;\") @HystrixCommand(fallbackMethod = \"hystrixCorp\") Corp getCorp(@PathVariable(\"id\") String id) &#123; Corp corp = corpService.getCorp(id); if (corp == null) &#123; throw new RuntimeException(\"id \" + id + \" 不存在\"); &#125; return corp; &#125; Corp hystrixCorp(@PathVariable(\"id\") String id) &#123; return Corp.builder().id(id).name(\"hystrix\").age(30).build(); &#125; 3、服务限流4、实时监控","categories":[{"name":"java","slug":"java","permalink":"http://yoursite.com/categories/java/"}],"tags":[{"name":"springCloud hystrix","slug":"springCloud-hystrix","permalink":"http://yoursite.com/tags/springCloud-hystrix/"}]},{"title":"负载均衡","slug":"负载均衡","date":"2020-05-31T13:32:48.000Z","updated":"2020-05-31T14:47:12.805Z","comments":true,"path":"2020/05/31/负载均衡/","link":"","permalink":"http://yoursite.com/2020/05/31/%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/","excerpt":"","text":"负载均衡 LB（load balance）：简单的说就是将用户请求平摊分配到多个服务器上，从而达到系统的高可用。 常见的负载均衡软件有nginx、lvx 常见分类 集中式LB：在服务的消费方和服务方使用独立的Lb方式，如nginx，由它负责请求转发。 进程式LB：将LB逻辑集成到消费方，消费方从注册中心获取可用的服务，再从这里面选一个进行访问，如ribbon。 ribbon 负载均衡// 配置类 @Configuration public class RestTemplateConfig &#123; @Bean @LoadBalanced RestTemplate restTemplate() &#123; return new RestTemplate(); &#125; &#125; // controller调用 // 第二版根据服务名去访问，需要将restTemplate注解为@LoadBalanced才会生效 private String service = \"http://MYCLOUD-PROVIDER\"; @RequestMapping(\"/consumer/corps/&#123;id&#125;\") Corp getCorp(@PathVariable(\"id\") String id) &#123; String url = service + \"/corps/\"; return restTemplate.getForObject(url + id, Corp.class); &#125; 使用服务名去调用，restful风格 feign 负载均衡 feign是声明式的web service客户端，只需提供一个接口，添加注解就可以了。 feign是ribbon的封装，以面向对象方式的去访问。 feign不需要去显式的声明restTemplate 使用接口注解去调用 // 逻辑处理类，映射路径为实际接口路径 @FeignClient(name = \"MYCLOUD-PROVIDER\") public interface CorpConsumerService &#123; @GetMapping(\"/corps/&#123;id&#125;\") Corp getCorp(@PathVariable(\"id\") String id); @GetMapping(\"/corps\") List&lt;Corp&gt; getCorps(); &#125; // 启动类配置enable @SpringBootApplication @EnableEurekaClient @EnableFeignClients public class CorpConsumer8002 &#123; public static void main(String[] args) &#123; SpringApplication.run(CorpConsumer8002.class, args); &#125; &#125;","categories":[{"name":"java","slug":"java","permalink":"http://yoursite.com/categories/java/"}],"tags":[{"name":"springCloud ribbon","slug":"springCloud-ribbon","permalink":"http://yoursite.com/tags/springCloud-ribbon/"}]},{"title":"eureka对比zookeeper","slug":"eureka对比zookeeper","date":"2020-05-31T13:09:42.000Z","updated":"2020-06-09T14:52:36.481Z","comments":true,"path":"2020/05/31/eureka对比zookeeper/","link":"","permalink":"http://yoursite.com/2020/05/31/eureka%E5%AF%B9%E6%AF%94zookeeper/","excerpt":"","text":"cap原则一、回顾 ACID 原则 关系数据库管理系统（Relational Database Management System：RDBMS），如mysql、oracle、sqlserver A（atomicity）原子性 C（consistency）一致性 I（Isolation）隔离性 D（durability）持久性 CAP原则 一般用于redis、mongdb C（consistency）一致性： 分布式环境下，一致性主要指数据在多个副本之间是否一致，（等同于所有节点访问同一份最新的数据副本）。 通过某个节点的写操作结果对后面通过其他节点的读操作可见，如果数据更新后并发访问情况下可立即感知其更新， 称为强一致性，如果允许之后部分或者全部感知不到该更新，称为弱一致性，若在之后一段时间后，一定可以感知该更新，称为最终一致性。 A（avaibility）可用性： 在集群中一部分节点故障后，集群整体是否还能响应客户端的读写请求。（对数据更新具备高可用性） P（partition tolerance）分区容错性： 集群出现网络割裂时，集群还能继续提供一定的可用性和一致性，除非整个网络不可用，也即部分节点宕机或者无法与其他节点通信时，各分区间还可保持分布式系统的功能。 著名的CAP理论指出，一个分布式系统不可能同时满足C(一致性)、A(可用性)和P(分区容错性)。由于分区容错性在是分布式系统中必须要保证的，因此我们只能在A和C之间进行权衡。zookeeper保证的是CP， 而eureka则是AP。 BASE理论 BASE是Basically Available（基本可用）、Soft state（软状态）和Eventually consistent（最终一致性）三个短语的简写，BASE是对CAP中一致性和可用性权衡的结果，其来源于对大规模互联网系统分布式实践的结论，是基于CAP定理逐步演化而来的，其核心思想是即使无法做到强一致性（Strong consistency），但每个应用都可以根据自身的业务特点，采用适当的方式来使系统达到最终一致性（Eventual consistency）。 BASE之基本可用体现在两个方面： 1、响应时间上的损失：比如某些请求1秒内给出响应，有些请求可能会在5秒内给出响应 2、功能上的损失：例如对于电商系统来说，某些区域可能不能购买某些商品，又或者大促时，部分消费者被引流到降级页面。 BASE之弱状态： 也称为软状态，是指允许系统中的数据存在中间状态，并认为该状态不会影响系统的整体可用性，即允许系统在不同节点的数据副本之间存在一定的延时。 BASE之最终一致性： 系统中的数据副本在经过一段时间同步后，组中能够达到一个一致的状态。 二、集群环境下如何保障数据一致性集群环境下有三种方式保障数据一致性：数据复制、WNR和集中存储。 1、数据复制：先向单节点写入，再复制到其他节点，zookeeper是这样实现的。或者多节点同时写入，但只适合多节点写入的数据不是相同数据的应用场景。在master-slave场景中， 同步复制（slave从master全部复制完成才给客户端返回写入成功）可保证强一致性，但会影响可用性；异步复制（数据写入master就返回写入成功，不需要等到slave复制完成， 之后master通过push向slave推送数据或者slave通过ull方式从master拉数据）可提供可用性但会降低一致性。 2、WNR：N代表总副本数，W代表每次写操作要保证的最少写成功的副本数，R代表每次读操作最少读取的副本数，当W+R&gt;N时，可保证每次读取的数据至少有一个副本具有最新的更新 （例如可以通过版本号或者时间戳判断是哪个副本的数据是最新的），多个写操作的顺序难以保证，可能导致多副本的写操作顺序不一致，Dynamo通过箱量时钟在保证最终一致性。 3、集中存储：借助可靠性较高的集中存储，比如NAS存储，分布式缓存（Redis）等。 二、zookeeper保证的是CP 放弃可用性，并不是完全没有可用性，是指允许响应超时的时间可以更长，比如报表可以运行10分钟左右，甚至在某些情况下允许超时。 Zookeeper会出现这样一种情况，当master节点因为网络故障与其他节点失去联系时，剩余节点会重新进行leader选举。问题在于，选举leader的时间太长，30 ~ 120s, 且选举期间整个Zookeeper集群都是不可用的，这就导致在选举期间注册服务瘫痪。在云部署的环境下，因网络问题使得Zookeeper集群失去master节点是较大概率会发生的事，虽然服务能够最终恢复，但是漫长的选举时间导致的注册长期不可用是不能容忍的。 zk集群： 1、zk集群是一种对等集群，所有节点（机器）数据都一样。 2、集群节点之间靠心跳感知彼此的存在。 3、所有写操作都在主节点，其他节点只能读，虽然也可以接收写请求，但是内部会把写操作转给主节点。 4、通过选举机制选出主节点，从而保障了主节点的高可用，这样主节点就不是固定的，万一主节点宕机还可以重新选举出主节点。 5、至少需要三个节点，而且节点个数必须是奇数。 6、当一半以上的数据写入成功后，则返回写入成功，是最终一致性策略。 三、eureka保证的是AP 放弃一致性是放弃数据的强一致性，而保留数据的最终一致性，即数据最终是完全一致的，但有一个时间窗口的问题，这需要根据不同的业务来定义。 当向注册中心查询服务列表时，我们可以容忍注册中心返回的是几分钟以前的注册信息，但不能接受服务直接down掉不可用。也就是说，服务注册功能对可用性的要求要高于一致性。 Eureka在设计时就优先保证可用性。Eureka各个节点都是平等的，几个节点挂掉不会影响正常节点的工作，剩余的节点依然可以提供注册和查询服务。而Eureka的客户端在向某个Eureka注册或时如果发现连接失败，则会自动切换至其它节点，只要有一台Eureka还在，就能保证注册服务可用(保证可用性)，只不过查到的信息可能不是最新的(不保证强一致性)。 除此之外，Eureka还有一种自我保护机制，如果在15分钟内超过85%的节点都没有正常的心跳，那么Eureka就认为客户端与注册中心出现了网络故障，此时会出现以下几种情况： Eureka不再从注册列表中移除因为长时间没收到心跳而应该过期的服务。 Eureka仍然能够接受新服务的注册和查询请求，但是不会被同步到其它节点上(即保证当前节点依然可用) 。 当网络稳定时，当前实例新的注册信息会被同步到其它节点中。因此， Eureka可以很好的应对因网络故障导致部分节点失去联系的情况，而不会像zookeeper那样使整个注册服务瘫痪。","categories":[{"name":"springCloud","slug":"springCloud","permalink":"http://yoursite.com/categories/springCloud/"}],"tags":[{"name":"eureka zookeeper","slug":"eureka-zookeeper","permalink":"http://yoursite.com/tags/eureka-zookeeper/"}]},{"title":"java8方法引用理解","slug":"java8方法引用理解","date":"2020-05-31T04:12:15.000Z","updated":"2020-05-31T04:13:16.886Z","comments":true,"path":"2020/05/31/java8方法引用理解/","link":"","permalink":"http://yoursite.com/2020/05/31/java8%E6%96%B9%E6%B3%95%E5%BC%95%E7%94%A8%E7%90%86%E8%A7%A3/","excerpt":"","text":"什么是方法引用?方法引用可用于在不调用方法的情况下引用方法。它将方法视为Lambda表达式。它们只能作为语法糖来减少一些lambdas的冗长。在方法引用中，将包含方法的对象（或类）放在::运算符之前，将方法的名称放在不带参数的方法之后。例如： Object :: methodName 为什么会出现方法引用？在Java中，我们可以通过创建新对象来使用对象的引用,或者引用已有的对象，例如： //创建新对象来引用该对象 List list = new ArrayList(); dosth(list); //引用已有的对象 List list2 = list; dosth(list2); 如果我们只在另一个方法中使用对象的方法，我们仍然必须将完整的对象作为参数传递。那么将方法作为参数传递不是更有效吗？ 方法引用这种语法糖不能用于所有的方法，它们只能用于只有一个方法的lambda表达式//lambda转方法引用 Consumer&lt;String&gt; c = s -&gt; System.out.println(s); Consumer&lt;String&gt; c = System.out::println; 换句话说，可以使用lambda表达式去代替一个匿名类，如果这个匿名类只有一个方法，就可以用更简短的方法引用来代替lambda表达式。 静态方法引用from (args) -&gt; Class.staticMethod(args) to Class::staticMethod 如上所述，我们不需要显式的传递参数，方法引用中会自动传递参数 Consumer&lt;String&gt; c1 = (s) -&gt; System.out.println(s); Consumer&lt;String&gt; c2 = System.out::println; c2.accept(\"Hello\"); 当我们所使用的lambda表达式仅仅调用了一个静态方法，我们就可以使用静态方法引用。如下所示，将lambda表达式（匿名类）中的值判断提取成isMoreThanFifty这个静态方法，就可以使用静态方法引用这种语法糖。 public class Numbers &#123; //将值判断提取成静态方法 public static boolean isMoreThanFifty(int n1, int n2) &#123; return (n1 + n2) &gt; 50; &#125; //公共接口方法 public static List&lt;Integer&gt; findNumbers(List&lt;Integer&gt; l, BiPredicate&lt;Integer, Integer&gt; p) &#123; List&lt;Integer&gt; newList = new ArrayList&lt;&gt;(); for (Integer i : l) &#123; if (p.test(i, i + 10)) &#123; newList.add(i); &#125; &#125; return newList; &#125; public static void main(String[] args) &#123; List&lt;Integer&gt; list = Arrays.asList(12, 5, 45, 18, 33, 24, 40); // Using an anonymous class List&lt;Integer&gt; res = Numbers.findNumbers(list, new BiPredicate&lt;Integer, Integer&gt;() &#123; @Override public boolean test(Integer integer, Integer integer2) &#123; return Numbers.isMoreThanFifty(integer, integer2); &#125; &#125;); res.stream().forEach(System.out :: println); // res.stream().peek(System.out :: println).collect(Collectors.toList()); // Using a lambda expression Numbers.findNumbers(list, (i1, i2) -&gt; Numbers.isMoreThanFifty(i1, i2)); // Using a method reference Numbers.findNumbers(list, Numbers::isMoreThanFifty); &#125; &#125; 特定类型的对象的实例方法的方法引用from (obj, args) -&gt; obj.instanceMethod(args) to ObjectType::instanceMethod 我们使用实例的类型而非实例本身 参数隐式传递public class People &#123; public double calculateWeight() &#123; double weight = 0; // Calculate weight return weight; &#125; public List&lt;Double&gt; calculateAllWeight(List&lt;People&gt; l, Function&lt;People, Double&gt; f) &#123; List&lt;Double&gt; results = new ArrayList&lt;&gt;(); for (People s : l) &#123; results.add(f.apply(s)); &#125; return results; &#125; &#125; class PeopleClient &#123; public static void main(String[] args) &#123; List&lt;People&gt; list = new ArrayList&lt;&gt;(); People p = new People(); // Using an anonymous class p.calculateAllWeight(list, new Function&lt;People, Double&gt;() &#123; @Override public Double apply(People people) &#123;// The object return people.calculateWeight();// The method &#125; &#125;); // Using a lambda expression p.calculateAllWeight(list, people -&gt; people.calculateWeight()); // Using a method reference p.calculateAllWeight(list, People::calculateWeight); &#125; &#125; 在这个例子中，我们没有给方法传递任何参数，关键在于对象的实例是lambda表达式的一个参数，我们通过实例的类型来完成对实例方法的引用。下面是另一个例子，在这个例子中，我们向方法引用中传递了两个参数。//java中有一个Function接口可以接收一个参数，BiFunction接口接受两个参数，没有接受三个参数的，所以我们自定义一个TriFunction interface TriFunction&lt;T, U, V, R&gt; &#123; R apply(T t, U u, V v); &#125; //然后定义一个类，接收两个参数，并且有一个返回值 class Sum &#123; Integer doSum(String s1, String s2) &#123; return Integer.parseInt(s1) + Integer.parseInt(s1); &#125; &#125; //用匿名类实现TriFunction，来包装doSum() TriFunction&lt;Sum, String, String, Integer&gt; anonymous = new TriFunction&lt;Sum, String, String, Integer&gt;() &#123; @Override public Integer apply(Sum s, String arg1, String arg2) &#123; return s.doSum(arg1, arg2); &#125; &#125;; System.out.println(anonymous.apply(new Sum(), \"1\", \"4\")); //使用lambda表达式来包装 TriFunction&lt;Sum, String, String, Integer&gt; lambda = (Sum s, String arg1, String arg2) -&gt; s.doSum(arg1, arg2); System.out.println(lambda.apply(new Sum(), \"1\", \"4\")); //使用方法引用 TriFunction&lt;Sum, String, String, Integer&gt; mRef = Sum::doSum; System.out.println(mRef.apply(new Sum(), \"1\", \"4\")); 第一个参数是要执行的方法的实例对象 第二、三个参数是传递的其他参数 最后一个参数是要执行的方法的返回值类型 已有对象的实例方法引用from (args) -&gt; obj.instanceMethod(args) to obj::instanceMethod 直接引用已经在其他地方实例化的对象的一个方法，本身不需要再实现一次 class Car &#123; private int id; private String color; public int getId() &#123; return id; &#125; public void setId(int id) &#123; this.id = id; &#125; &#125; class Mechanic &#123; public void fix(Car c) &#123; System.out.println(\"Fixing car \" + c.getId()); &#125; &#125; public class InstanceRef &#123; public static void main(String[] args) &#123; InstanceRef instanceRef = new InstanceRef(); final Mechanic mechanic = new Mechanic(); Car car = new Car(); // Using an anonymous class instanceRef.execute(car, new Consumer&lt;Car&gt;() &#123; public void accept(Car c) &#123; mechanic.fix(c); &#125; &#125;); // Using a lambda expression instanceRef.execute(car, car1 -&gt; mechanic.fix(car1)); //Using a method reference instanceRef.execute(car, mechanic::fix); &#125; private void execute(Car car, Consumer&lt;Car&gt; c) &#123; c.accept(car); &#125; &#125; 构造方法引用from (args) -&gt; new ClassName(args) to ClassName::new 这个lambda表达式唯一能做的就是创建一个新对象，我们通过关键字new来引用类的构造函数。与其他情况一样，参数（如果有）不会在方法引用中传递。 无参构造 // Using an anonymous class Supplier&lt;List&lt;String&gt;&gt; s = new Supplier() &#123; public List&lt;String&gt; get() &#123; return new ArrayList&lt;String&gt;(); &#125; &#125;; List&lt;String&gt; l = s.get(); // Using a lambda expression Supplier&lt;List&lt;String&gt;&gt; s = () -&gt; new ArrayList&lt;String&gt;(); List&lt;String&gt; l = s.get(); // Using a method reference Supplier&lt;List&lt;String&gt;&gt; s = ArrayList::new; List&lt;String&gt; l = s.get(); 带参构造 // Using a anonymous class BiFunction&lt;String, String, Locale&gt; f = new BiFunction&lt;String, String, Locale&gt;() &#123; public Locale apply(String lang, String country) &#123; return new Locale(lang, country); &#125; &#125;; Locale loc = f.apply(\"en\",\"UK\"); // Using a lambda expression BiFunction&lt;String, String, Locale&gt; f = (lang, country) -&gt; new Locale(lang, country); Locale loc = f.apply(\"en\",\"UK\"); // Using a method reference BiFunction&lt;String, String, Locale&gt; f = Locale::new; Locale loc = f.apply(\"en\",\"UK\"); 如果有三个及以上的参数的构造函数，则必须创建自己的函数接口。引用构造函数与引用静态方法非常相似，区别在于构造函数“方法名称”是new。 总结如果使用了方法引用之后能让代码变的更加整洁，就使用它。实际使用中，一种使用方式是将代码包裹在一个方法中，而非使用一个单独的类或者lambda表达式，然后使用方法引用的方式进行调用。方法引用常用于java8的另一种新特性Streams中，而基于方法引用的设计模式也会更加具有拓展性。","categories":[{"name":"java","slug":"java","permalink":"http://yoursite.com/categories/java/"}],"tags":[{"name":"stream","slug":"stream","permalink":"http://yoursite.com/tags/stream/"}]},{"title":"java8新特性之Stream","slug":"java8新特性之Stream","date":"2020-05-31T04:07:12.000Z","updated":"2020-05-31T04:09:19.626Z","comments":true,"path":"2020/05/31/java8新特性之Stream/","link":"","permalink":"http://yoursite.com/2020/05/31/java8%E6%96%B0%E7%89%B9%E6%80%A7%E4%B9%8BStream/","excerpt":"","text":"概述Stream API与InputStream和OutputStream是完全不同的概念，Stream API是对Java中集合操作的增强，可以利用它进行各种过滤、排序、分组、聚合等操作。Stream API配合Lambda表达式可以加大的提高代码可读性和编码效率，Stream API也支持并行操作。 流不是集合，它不关心数据的存放，只关注如何处理数据Stream API主要用于处理集合操作，不过它的处理方式与传统的方式不同，称为“数据流处理”。流（Stream）类似于关系数据库的查询操作，是一种声明式操作。比如要从数据库中获取所有年龄大于20岁的用户的名称，并按照用户的创建时间进行排序，用一条SQL语句就可以搞定，不过使用Java程序实现就会显得有些繁琐，这时候可以使用流： List&lt;String&gt; userNames = users.stream() .filter(user -&gt; user.getAge() &gt; 20) .sorted(comparing(User::getCreationDate)) .map(User::getUserName) .collect(toList()); 在Java中，集合是一种数据结构，或者说是一种容器，用于存放数据，流不是容器，它不关心数据的存放，只关注如何处理。可以把流当做是Java中的Iterator，不过它比Iterator强大多了。 流使用内部迭代方式处理数据流与集合另一个区别在于他们的遍历方式，遍历集合通常使用for-each方式，这种方式称为外部迭代，而流使用内部迭代方式，也就是说它帮你把迭代的工作做了，你只需要给出一个函数来告诉它接下来要干什么： // 外部迭代 List&lt;String&gt; list = Arrays.asList(\"A\", \"B\", \"C\", \"D\"); for (String str : list) &#123; System.out.println(str); &#125; // 内部迭代 list.stream().forEach(System.out::println); 外部迭代更像是作文题，我们不仅要控制元素的迭代方式，还需要定义怎么操作元素；内部迭代更像是填空题，我们只用关注如何操作元素就可以了。 流只能遍历一次流只能遍历一次，遍历结束后，这个流就被关闭掉了。如果要重新遍历，可以从数据源（集合）中重新获取一个流。如果你对一个流遍历两次，就会抛出java.lang.IllegalStateException异常： List&lt;String&gt; list = Arrays.asList(\"A\", \"B\", \"C\", \"D\"); Stream&lt;String&gt; stream = list.stream(); stream.forEach(System.out::println); stream.forEach(System.out::println); // 这里会抛出java.lang.IllegalStateException异常，因为流已经被关闭 流通常由三部分构成： 数据源：数据源一般用于流的获取，比如本文开头那个过滤用户的例子中users.stream()方法。 中间处理：中间处理包括对流中元素的一系列处理，如：过滤（filter()），映射（map()），排序（sorted()）。 终端处理：终端处理会生成结果，结果可以是任何不是流值，如List；也可以不返回结果，如stream.forEach(System.out::println)就是将结果打印到控制台中，并没有返回。 创建流由值创建流使用静态方法Stream.of()创建流，该方法接收一个变长参数： Stream&lt;Stream&gt; stream = Stream.of(\"A\", \"B\", \"C\", \"D\"); //也可以使用静态方法Stream.empty()创建一个空的流： Stream&lt;Stream&gt; stream = Stream.empty(); 由数组、集合 创建流使用静态方法Arrays.stream()从数组创建一个流，该方法接收一个数组参数： String[] strs = &#123;\"A\", \"B\", \"C\", \"D\"&#125;; Stream&lt;Stream&gt; stream = Arrays.stream(strs); 通过文件生成流使用java.nio.file.Files类中的很多静态方法都可以获取流，比如Files.lines()方法，该方法接收一个java.nio.file.Path对象，返回一个由文件行构成的字符串流： Stream&lt;String&gt; stream = Files.lines(Paths.get(\"text.txt\"), Charset.defaultCharset()); 通过函数创建流java.util.stream.Stream中有两个静态方法用于从函数生成流，他们分别是Stream.generate()和Stream.iterate()： // iteartor 打印100以内的所有偶数 Stream.iterate(0, n -&gt; n + 2).limit(51).forEach(System.out::println); // generate 打印10个Hello Man! Stream.generate(() -&gt; \"Hello Man!\").limit(10).forEach(System.out::println); 值得注意的是，这两个方法生成的流都是无限流，没有固定大小，可以无穷的计算下去，可以使用limit()来限制边界。 //一般来说，iterate()用于生成一系列值，比如生成以当前时间开始之后的10天的日期： Stream.iterate(LocalDate.now(), date -&gt; date.plusDays(1)).limit(10).forEach(System.out::println); //generate()方法用于生成一些随机数，比如生成10个UUID： Stream.generate(() -&gt; UUID.randomUUID().toString()).limit(10).forEach(System.out::println); collect(toList())将流中的值转换为集合//of从初识值生成新的stream，再通过collect(toList())生成新的集合 List&lt;String&gt; collect = Stream.of(\"aa\", \"bb\", \"cc\", \"aa\", \"bb\").collect(Collectors.toList()); of是惰性求值，不生成新的集合，通过collect(toList())这种及早求值才生成新的集合。返回值是stream就是惰性求值，返回值为另一个值或者空就是及早求值。 惰性求值与及早求值的区别//如下加count就是及早求值，会sout输出strs。不加count，程序不输出任何信息 strs.stream().filter(str -&gt; &#123; System.out.println(str); return str.startsWith(\"a\"); &#125; ).count(); 过滤+计数，只循环了一次。只执行fileter会返回一个stream，他不是一个新集合，仅仅是创建新集合的配方。 流常用方法过滤和排序Stream.of(1, 8, 5, 2, 1, 0, 9, 2, 0, 4, 8) .filter(n -&gt; n &gt; 2) // 对元素过滤，保留大于2的元素 .distinct() // 去重，类似于SQL语句中的DISTINCT .skip(1) // 跳过前面1个元素 .limit(2) // 返回开头2个元素，类似于SQL语句中的SELECT TOP .sorted() // 对结果排序 .forEach(System.out::println); filter 对集合的值进行过滤，必须返回true或者false 查找和匹配//检查流中的任意元素是否包含字符串\"PHP\" boolean match1 = getStream().anyMatch(s -&gt; s.equals(\"PHP\")); System.out.println(match1); boolean match2 = getStream().collect(Collectors.toList()).contains(\"PHP\"); System.out.println(match2); // 检查流中的所有元素是否都包含字符串\"#\" boolean hasAllMatch = getStream().allMatch(s -&gt; s.contains(\"#\")); // 检查流中的任意元素是否没有以\"C\"开头的字符串 boolean hasNoneMatch = getStream().noneMatch(s -&gt; s.startsWith(\"C\")); // 查找元素 Optional&lt;String&gt; element = getStream().ilter(s -&gt; s.contains(\"C\")) // .findFirst() // 查找第一个元素 .findAny(); // 查找任意元素 //获取初始流 private static Stream&lt;String&gt; getStream() &#123; return Stream.of(\"Java\", \"C#\", \"PHP\", \"C++\", \"Python\"); &#125; 每次都需要重新getStream()来获取新的流，因为之前的流已经使用并且关闭了。可以理解为若返回值不是stream，则表示已经结束了流操作 findAny的返回类型是一个Optional类（java.util.Optional），它一个容器类，代表一个值存在或不存在，用来避免控制正异常。 findFirst()和findAny()返回的都是第一个元素，通过查看javadoc描述，大致意思是findAny()是为了提高并行操作时的性能。数据大时可findany。 归约归约操作就是将流中的元素进行合并，形成一个新的值，常见的归约操作包括求和，求最大值或最小值。归约操作一般使用reduce()方法，与map()方法搭配使用，可以处理一些很复杂的归约操作。 // 获取流 List&lt;Book&gt; books = Arrays.asList( new Book(\"Java编程思想\", \"Bruce Eckel\", \"机械工业出版社\", 108.00D), new Book(\"Java 8实战\", \"Mario Fusco\", \"人民邮电出版社\", 79.00D), new Book(\"MongoDB权威指南（第2版）\", \"Kristina Chodorow\", \"人民邮电出版社\", 69.00D) ); // 计算所有图书的总价 Optional&lt;Double&gt; totalPrice = books.stream() .map(Book::getPrice) .reduce((n, m) -&gt; n + m); // 价格最高的图书 Optional&lt;Book&gt; expensive = books.stream().max(Comparator.comparing(Book::getPrice)); // 价格最低的图书 Optional&lt;Book&gt; cheapest = books.stream().min(Comparator.comparing(Book::getPrice)); // 计算总数 long count = books.stream().count() reduce从一组值中生成一个值，如累加。//0初始值，total总值，index循环的每一个值。 Integer num = Stream.of(1, 2, 3).reduce(0, (total, index) -&gt; total + index); max(min) 传入comparator进行大小比较，返回Optional对象//Optional对象(代表一个可能存在也可能不存在的值，NPE方案),通过get拿到Optional对象中的值 Integer integer = Stream.of(1, 2, 3).min(Comparator.comparing(num -&gt; num)).get(); map 将流中的值转换为新值//将list小写处理成大写 Stream.of(\"aa\", \"bb\", \"cc\", \"aa\", \"bb\").map(str -&gt; str.toUpperCase()).collect(Collectors.toList()); flatmap 把多个stream合并成一个stream并返回与map()方法类似的还有一个flatMap()，flatMap()方法让你把一个流中的每个值都换成另一个流，然后把所有的流连接起来成为一个新的流。 //传统for循环 List&lt;String&gt; names0 = new ArrayList&lt;&gt;(); for (Company company : data) &#123; List&lt;User&gt; users = company.getUesrs(); for (User user : users) &#123; if (user.getAge() &gt; 30) &#123; names0.add(user.getName()); &#125; &#125; &#125; //lambda方式1 List&lt;String&gt; names1 = data.stream() .flatMap(company -&gt; company.getUesrs().stream()) .filter(user -&gt; user.getAge() &gt; 30) .map(user -&gt; user.getName()) .collect(Collectors.toList()); //lambda方式2 List&lt;String&gt; names2 = data.stream() .map(Company::getUesrs) .flatMap(Collection::stream) .filter(user -&gt; user.getAge() &gt; 30) .map(User::getName) .collect(Collectors.toList()); 使用flatMap()方法的效果是，各个数组并不是分别映射成一个流，而是映射成流的内容。所有使用map(Arrays::stream)时生成的单个流都被合并起来，也就是对流扁平化操作。 peek 用于记录中间值（输出流中的值），不会改变流。一般用作日志输出，断点调试。List&lt;Integer&gt; nums = Stream.of(1, 2, 3, 4, 5).collect(Collectors.toList()); nums.stream().filter(num -&gt; num &gt; 3).peek(num -&gt; &#123; System.out.println(num); &#125;).collect(Collectors.toList()); 数据收集前面总结了如何创建流以及流处理，接下来总结下数据收集。数据收集是流式数据处理的终端处理，与中间处理不同的是，终端处理会消耗流，也就是说，终端处理之后，这个流就会被关闭，如果再进行中间处理，就会抛出异常。数据收集主要使用collect方法，该方法也属于归约操作，像reduce()方法那样可以接收各种做法作为参数，将流中的元素累积成一个汇总结果，具体的做法是通过定义新的Collector接口来定义的。 可以静态导入Collectors和Comparator两个类，这样就不用再去写Collectors.counting()和Comparator.comparing()。import static java.util.stream.Collectors.*; import static java.util.Comparator.*; // 求和 long count = books.stream().collect(counting()); // 价格最高的图书 Optional&lt;Book&gt; expensive = books.stream().collect(maxBy(comparing(Book::getPrice))); // 价格最低的图书 Optional&lt;Book&gt; cheapest = books.stream().collect(minBy(comparing(Book::getPrice))); 收集顺序进有序，出有序；进无序，出无序。 特定收集器stream.collect(toCollection(TreeSet::new)); 字符串操作joining//将流中的字符串通过逗号连接成一个新的字符串 String str = Stream.of(\"A\", \"B\", \"C\", \"D\").collect(joining(\",\")); List&lt;Integer&gt; data = Stream.of(1,2,3,4,5).collect(toList()); List&lt;Integer&gt; integers = Arrays.asList(1, 2, 3, 4, 5); //前后缀拼接 //传统for循环 StringBuilder sb = new StringBuilder(\"[\"); for (Integer num : integers) &#123; sb.append(num).append(\", \"); &#125; sb.append(\"]\"); System.out.println(sb); //lambda循环（map是为了将int转为string） String str = data.stream().map(String::valueOf).collect(joining(\",\", \"[\", \"]\")); System.out.println(str); 数据分块（parttitioningBy，将流分解成两个集合），传入一个pridicate对象来判断属于哪部分。//数据分块：将数据分成true和false两部分 Map&lt;Boolean, List&lt;User&gt;&gt; res = users.stream().collect(partitioningBy(user -&gt; user.getName().length() &gt; 3)); 数据分组（groupingBy）//数据分组：将数据以某个key值分成多部分 Map&lt;String, List&lt;User&gt;&gt; result = users.stream().collect(groupingBy(user -&gt; user.getAddress())); Map&lt;String, List&lt;User&gt;&gt; result = users.stream().collect(groupingBy(User::getAddress)); 组合收集器（下游收集器），在主收集器中应用下级收集器，对结果进行再次封装。//将数据分组后，不是返回每组的数据，而是统计每组的个数返回。 Map&lt;String, Long&gt; collect1 = users.stream().collect(groupingBy(User::getName, counting())); //通过mapping可以进行其他二次收集。 Map&lt;String, List&lt;String&gt;&gt; collect2 = users.stream().collect(groupingBy(User::getAddress, mapping(User::getName, toList()) )); 函数拆分示例：collect( groupingBy(key1, mapping(key2, value) ) ) 进阶集合操作map的foreach循环Map&lt;String, Integer&gt; cache = new HashMap&lt;&gt;(); Map&lt;String, List&lt;User&gt;&gt; users = new HashMap&lt;String, List&lt;User&gt;&gt;(); //传统for循环 for (Map.Entry&lt;String, List&lt;User&gt;&gt; entry : users.entrySet()) &#123; String key = entry.getKey(); List&lt;User&gt; value = entry.getValue(); cache.put(key, value.size()); &#125; //lambda方式 users.forEach((key, value) -&gt; &#123; cache.put(key, value.size()); &#125;); computeIfAbsent根据key获取某个值，若值不存在，丛数据库中取 //传统方式 public List&lt;User&gt; getUserByName(String name) &#123; List&lt;User&gt; user = users.get(name); if (user == null) &#123; user = readFromDB(name); users.put(name, user); &#125; return user; &#125; //lambda方式 public List&lt;User&gt; getUser1ByName(String name) &#123; return users.computeIfAbsent(name, this::readFromDB); &#125; private List&lt;User&gt; readFromDB(String name) &#123; return new ArrayList&lt;&gt;(); &#125;","categories":[{"name":"java","slug":"java","permalink":"http://yoursite.com/categories/java/"}],"tags":[{"name":"stream","slug":"stream","permalink":"http://yoursite.com/tags/stream/"}]},{"title":"Hello World","slug":"hello-world","date":"2020-05-31T01:14:54.029Z","updated":"2020-05-31T01:14:54.029Z","comments":true,"path":"2020/05/31/hello-world/","link":"","permalink":"http://yoursite.com/2020/05/31/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post$ hexo new \"My New Post\" More info: Writing Run server$ hexo server More info: Server Generate static files$ hexo generate More info: Generating Deploy to remote sites$ hexo deploy More info: Deployment","categories":[],"tags":[]}],"categories":[{"name":"springCloud","slug":"springCloud","permalink":"http://yoursite.com/categories/springCloud/"},{"name":"java","slug":"java","permalink":"http://yoursite.com/categories/java/"},{"name":"idea","slug":"idea","permalink":"http://yoursite.com/categories/idea/"},{"name":"mybatis","slug":"mybatis","permalink":"http://yoursite.com/categories/mybatis/"},{"name":"总结","slug":"总结","permalink":"http://yoursite.com/categories/%E6%80%BB%E7%BB%93/"}],"tags":[{"name":"ribbon","slug":"ribbon","permalink":"http://yoursite.com/tags/ribbon/"},{"name":"eureka","slug":"eureka","permalink":"http://yoursite.com/tags/eureka/"},{"name":"restTemplate","slug":"restTemplate","permalink":"http://yoursite.com/tags/restTemplate/"},{"name":"thread","slug":"thread","permalink":"http://yoursite.com/tags/thread/"},{"name":"thread blockingQueue","slug":"thread-blockingQueue","permalink":"http://yoursite.com/tags/thread-blockingQueue/"},{"name":"thread queue","slug":"thread-queue","permalink":"http://yoursite.com/tags/thread-queue/"},{"name":"springboot","slug":"springboot","permalink":"http://yoursite.com/tags/springboot/"},{"name":"环境变量","slug":"环境变量","permalink":"http://yoursite.com/tags/%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/"},{"name":"mybatis-generator","slug":"mybatis-generator","permalink":"http://yoursite.com/tags/mybatis-generator/"},{"name":"性能优化","slug":"性能优化","permalink":"http://yoursite.com/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"},{"name":"springCloud hystrix","slug":"springCloud-hystrix","permalink":"http://yoursite.com/tags/springCloud-hystrix/"},{"name":"springCloud ribbon","slug":"springCloud-ribbon","permalink":"http://yoursite.com/tags/springCloud-ribbon/"},{"name":"eureka zookeeper","slug":"eureka-zookeeper","permalink":"http://yoursite.com/tags/eureka-zookeeper/"},{"name":"stream","slug":"stream","permalink":"http://yoursite.com/tags/stream/"}]}